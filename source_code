SOURCE CODE OF ADVANCED TRIGONOMETRY CALCULATOR PROGRAM

Advanced Trigonometry Calculator

Copyright (C) 2011-2015 - Renato Alexandre dos Santos Freitas

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for mor details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>


In the stdafx.h's file:

#pragma once

#include "targetver.h"
#include <stdio.h>
#include <tchar.h>
#include <stdlib.h>
#include <windows.h>
#include <time.h>
#include "resource.h"
#include <boost/math/special_functions/erf.hpp>
#define DIM 5000
#define _USE_MATH_DEFINES
#include <math.h>
void cotan(double x, double y);
void sec(double x, double y);
void cosec(double x, double y);
void cotanh(double x, double y);
void sech(double x, double y);
void cosech(double x, double y);
double functionProcessor(char trigon[DIM], double result, double amplitude, double res);
double initialProcessor(char arithTrig[DIM], double result);
double arithSolver(char trigon1[DIM], double result);
void sinc(double x, double y);
void Clock(int a);
int processTxt(char path[DIM], int re);
int about();
void colors();
void dimensions();
void window();
int applySettings(int toDo);
void mode();
double ln(double z);
void arsinh(double x, double y);
void arcosh(double x, double y);
void artanh(double x, double y);
void arcoth(double x, double y);
void arsech(double x, double y);
void arcsch(double x, double y);
double pot(double base, double exponent, int sig);
double re(double dividend, double divider);
double qu(double dividend, double divider);
void arcosec(double x, double y);
void arcsec(double x, double y);
void arcotg(double x, double y);
void about2();
double processVariable(char variable[DIM]);
void variableController(char variable[DIM], double result);
int variableValidator(char variable[DIM]);
double binaryToDecimal(char binary[DIM]);
double octalToDecimal(char octal[DIM]);
double hexadecimalToDecimal(char hexadecimal[DIM]);
void decimalToBinary(double decimal, char path[DIM], int bp);
void decimalToOctal(double decimal, char path[DIM], int op);
void decimalToHexadecimal(double decimal, char path[DIM], int hp);
double multi(double multip);
double quo(double quotient);
double numericalSystems(char numSystem[DIM]);
void numSystemsController();
double fl(double number);
double returnDeciPart(double number);
double qfunc(double x);
double qfuncinv(double p);
double gerror(double q);
double gerrorinv(double e);
double gerrorc(double q);
double gerrorcinv(double a);
double rt(double radicand, double degree, int sig);
double arcfact(double f);
void siPrefixController();
int prefDet(double n, char path[DIM]);
void actualTimeController();
double convertToNumber(char number[DIM]);
void DayofWeek(int d, int m, int y, char calendar[DIM]);
void Calendar(char yearCalendar[DIM], int year);
double solvint(double result);
double fact(double d);
int dataVerifier(char data[DIM], double result, int comment, int verify);
void variableRenamer(char variable[DIM]);
double prefToNumber(char prefix);
void pathNameController(char pathName[DIM], char path[DIM]);
void pathNameToPath(char pathName[DIM]);
void matrixToValues(char matrix[DIM], double result);
void solveSystem();
void rearrangeValues();
void getSolutions();
void sum(double numR, double numI, double denR, double denI);
void subtraction(double numR, double numI, double denR, double denI);
void multiplication(double numR, double numI, double denR, double denI);
void division(double numR, double numI, double denR, double denI);
void printTimer(int hours, int minutes, int seconds);
int letterVariables(char letter);
int firstLetterVariable(char letter);
int verifyLetter(char letter);
bool IsPreviousToWindowsVista();
void exponentiation(double a, double b, double c, double d, int sig);
double arg(double a, double b);
int verifyNumber(char number);
void complex_log(double a, double b);
void qu_complex(double dividend, double dividendI, double divider, double dividerI);
void re_complex(double dividend, double dividendI, double divider, double dividerI);
void complex_cos(double x, double y);
void complex_sin(double x, double y);
void complex_tan(double x, double y);
void complex_cosh(double x, double y);
void complex_sinh(double x, double y);
void complex_tanh(double x, double y);
void complex_asin(double x, double y);
void complex_acos(double x, double y);
void complex_atan(double x, double y);
void round_complex();
void renamer(char expression[DIM]);
void variableToMultiply(char expression[DIM]);
void toMultiply(char expression[DIM], double result);
int verifyPrefix(char prefix[DIM]);
int firstLetterFunction(char letter);
void manageExpression(char arithTrig[DIM], double result1, int verify);
void openTxt();
void cls();
void wait(int seconds);

In the Advanced Trigonometry Calculator.cpp's file:


#include "stdafx.h"

double ans[DIM], ansI[DIM], values[DIM][DIM], resultFI = 0, valuesS[DIM][DIM], valuesSI[DIM][DIM], valuesF[DIM][DIM], valuesFI[DIM][DIM], valuesI[DIM][DIM], resultR = 0, resultI = 0, intVal = 0;
char integral[DIM] = "", varRename[DIM] = "", revariable[DIM] = "", pathNAme[DIM] = "", expressionF[DIM] = "";;
int Mode = 0, valid = 0, validVar = 0, count = 2, synTest = 0, valRenamedVar = 0;



int main(){
	FILE *fout = NULL, *fclean, *open;
	int tD = 0, s = 0, command = 0, continu = 1, i = 0, g = 0, txt, cleanhistory = 0, Colors = 1, Dimensions = 2, Window = 3, var = 0, space = 0, j = 0, year = 0, v = 0, rf = 0, r = 0;
	char exit[DIM] = "", res, variable[DIM] = "", path[DIM] = "history.txt", varLetters[DIM] = "QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm";
	double result = 0, result1 = 0, result2 = 0;
	applySettings(Colors);
	system("title Advanced Trigonometry Calculator v1.8.4");
	continu = about();
	system("title Advanced Trigonometry Calculator v1.8.4                                                             ==) Enter data (==              ");
	if (continu == 1){
		do{
			char trigData[DIM] = "";
			tD = 0;
			printf(">");
			gets(trigData);
			for (tD = 0; trigData[tD] != '\0'; tD++){
				i = 0;
				char fTrig[DIM] = "", arithTrig[DIM] = "";
				flushall();
				fout = NULL;
				while (fout == NULL){
					fout = fopen(path, "a+");
				}
				v = 0;
				cleanhistory = 0;
				txt = 0;
				valid = 1;
				continu = 1;
				command = 0;
				varRename[0] = '\0'; revariable[0] = '\0'; variable[0] = '\0';
				validVar = 1;
				arithTrig[0] = '\0'; fTrig[0] = '\0';
				var = 0;
				flushall();
				while (trigData[tD] != '\0'&&trigData[tD] != ','){
					arithTrig[i] = trigData[tD];
					i++; tD++;
				}
				arithTrig[i] = '\0';
				for (i = 0; arithTrig[i] != '\0'; i++){
					if (arithTrig[i] == ':'&&arithTrig[i + 1] == '\\'){
						txt = 1;
					}
					if (arithTrig[i] == '='){
						var = 1;
					}
					fTrig[i] = arithTrig[i];
				}
				fTrig[i] = '\0';
				fprintf(fout, ">%s\n", fTrig);
				if (txt == 1){
					int p = 0;
					char pathName[DIM] = "";
					if (var == 1){
						var = 0;
						while (arithTrig[p] != '='){
							pathName[p] = arithTrig[p];
							p++;
						}
						pathName[p] = '\0';
						for (p = 0; pathName[p] != ' '&&pathName[p] != ')'&&pathName[p] != '\0'; p++);
						if (p == strlen(pathName)){
							int lenPath = strlen(pathName) + 1;
							for (p = lenPath; arithTrig[p] != '\0'; p++){
								arithTrig[p - lenPath] = arithTrig[p];
							}
							arithTrig[p - lenPath] = '\0';

							pathNameController(pathName, arithTrig);
						}
						else{
							printf("\n==> Invalid abbreviation! <==\n\n");
							fprintf(fout, "\n==> Invalid abbreviation! <==\n\n");
							arithTrig[0] = '\0';
						}
					}

					if (arithTrig[0] != '\0'){
						command = 1;
						processTxt(arithTrig, rf);
						printf("\n==> Close the file with the answers to continue. <==\n\n");
						fprintf(fout, "\n==> Close the file with the answers to continue. <==\n\n");
						openTxt();
						arithTrig[0] = '\0';
					}
				}
				if (strlen(arithTrig) > 0){
					arithTrig[i] = '+'; arithTrig[i + 1] = '0'; arithTrig[i + 2] = '\0';
				}
				int verify = 0;
				for (s = 0; arithTrig[s] != '\0'; s++){
					if (arithTrig[s] == 'B' || arithTrig[s] == 'O' || arithTrig[s] == 'H' || arithTrig[s] == '_' || arithTrig[s] == '{' || arithTrig[s] == '[' || arithTrig[s] == '(' || arithTrig[s] == '+' || arithTrig[s] == '-' || arithTrig[s] == '*' || arithTrig[s] == '/' || arithTrig[s] == '^' || arithTrig[s] == '0' || arithTrig[s] == '1' || arithTrig[s] == '2' || arithTrig[s] == '3' || arithTrig[s] == '4' || arithTrig[s] == '5' || arithTrig[s] == '6' || arithTrig[s] == '7' || arithTrig[s] == '8' || arithTrig[s] == '9' || (arithTrig[s] == 'r'&&arithTrig[s + 1] == 'e'&&arithTrig[s + 2] == 's') || (arithTrig[s] == 'a'&&arithTrig[s + 1] == 'n'&&arithTrig[s + 2] == 's') || (arithTrig[s] == 'e' && ((arithTrig[s + 1] == 'e' || arithTrig[s + 1] == '\0'&&s == 0 || arithTrig[s + 1] == ')' || arithTrig[s + 1] == 'p' || arithTrig[s - 1] == '_') || (arithTrig[s - 1] == 'e' || arithTrig[s - 1] == '(' || arithTrig[s - 1] == 'i'&&arithTrig[s - 2] != 't'))) || (arithTrig[s] == 'p'&&arithTrig[s + 1] == 'i' && ((arithTrig[s + 2] == 'e' || arithTrig[s + 2] == '\0'&&s == 0 || arithTrig[s + 2] == ')' || arithTrig[s + 2] == 'p' || arithTrig[s - 1] == '_') || (arithTrig[s - 1] == 'e' || arithTrig[s - 1] == '(' || arithTrig[s - 1] == 'i')))){
						verify = 1;
					}
				}
				if (var == 1){
					for (i = 0; arithTrig[i] != '='; i++){
						if (arithTrig[i] == ' '){
							v = 1;
						}
					}
					i++;
					if (arithTrig[i] == '+'&&arithTrig[i + 1] == '0'&&arithTrig[i + 2] == '\0'){
						verify = 0;
						var = 0;
					}
				}
				for (i = 0; arithTrig[i] != '\0'; i++){
					if (arithTrig[i] == ' '){
						space = 1;
						break;
					}
					else{
						space = 0;
					}
				}
				if (space == 1){
					while (space == 1){
						for (i = 0; arithTrig[i] != '\0'; i++){
							if (arithTrig[i] == ' '){
								j = i;
								while (arithTrig[i] != '\0'){
									arithTrig[i] = arithTrig[i + 1];
									i++;
								}
								i = j;
							}
						}
						for (i = 0; arithTrig[i] != '\0'; i++){
							if (arithTrig[i] == ' '){
								space = 1;
								break;
							}
							else{
								space = 0;
							}
						}
					}
				}
				i = 0;
				if (arithTrig[i] == 't'&&arithTrig[i + 1] == 'e'&&arithTrig[i + 2] == 'r'&&arithTrig[i + 3] == 'm'&&arithTrig[i + 4] == 'i'&&arithTrig[i + 5] == 'n'&&arithTrig[i + 6] == 'a'&&arithTrig[i + 7] == 'r'&&arithTrig[i + 8] == 's'&&arithTrig[i + 9] == 'e'&&arithTrig[i + 10] == 's'&&arithTrig[i + 11] == 's'&&arithTrig[i + 12] == 'a'&&arithTrig[i + 13] == 'o'&&arithTrig[i + 16] == '\0' || arithTrig[i] == 'l'&&arithTrig[i + 1] == 'o' && arithTrig[i + 2] == 'g' && arithTrig[i + 3] == 'o'&&arithTrig[i + 4] == 'f'&&arithTrig[i + 5] == 'f'&&arithTrig[i + 8] == '\0'){
					continu = 0;
					command = 1;
					if (IsPreviousToWindowsVista() == true){
						system("C:\\WINDOWS\\System32\\shutdown -l");
					}
					else{
						system("C:\\WINDOWS\\System32\\shutdown /l");
					}
				}
				if (arithTrig[i] == 'r'&&arithTrig[i + 1] == 'u'&&arithTrig[i + 2] == 'n'&&arithTrig[i + 3] == 'a'&&arithTrig[i + 4] == 't'&&arithTrig[i + 5] == 'c'&&arithTrig[i + 8] == '\0'){
					command = 1;
					puts(" ");
					ShellExecute(NULL, _T("open"), _T("Advanced Trigonometry Calculator EN.exe"), NULL, NULL, SW_SHOW);
				}
				if (arithTrig[i] == 'u'&&arithTrig[i + 1] == 'p'&&arithTrig[i + 2] == 'd'&&arithTrig[i + 3] == 'a'&&arithTrig[i + 4] == 't'&&arithTrig[i + 5] == 'e'&&arithTrig[i + 6] == 'p'&&arithTrig[i + 7] == 'o'&&arithTrig[i + 8] == 'r'&&arithTrig[i + 9] == 't'&&arithTrig[i + 10] == 'a'&&arithTrig[i + 11] == 'b'&&arithTrig[i + 12] == 'l'&&arithTrig[i + 13] == 'e'&&arithTrig[i + 16] == '\0'){
					command = 1;
					puts(" ");
					ShellExecute(NULL, _T("open"), _T("C:\\WINDOWS\\system32\\cmd.exe"), _T("/C \"start http://sourceforge.net/projects/advantrigoncalc/files/Advanced%20Trigonometry%20Calculator.zip/download\""), NULL, SW_SHOW);
				}
				if (arithTrig[i] == 'u'&&arithTrig[i + 1] == 'p'&&arithTrig[i + 2] == 'd'&&arithTrig[i + 3] == 'a'&&arithTrig[i + 4] == 't'&&arithTrig[i + 5] == 'e'&&arithTrig[i + 8] == '\0' || arithTrig[i] == 'a'&&arithTrig[i + 1] == 't' && arithTrig[i + 2] == 'u' && arithTrig[i + 3] == 'a'&&arithTrig[i + 4] == 'l'&&arithTrig[i + 5] == 'i'&&arithTrig[i + 6] == 'z'&&arithTrig[i + 7] == 'a'&&arithTrig[i + 8] == 'r'&&arithTrig[i + 11] == '\0'){
					command = 1;
					puts(" ");
					ShellExecute(NULL, _T("open"), _T("C:\\WINDOWS\\system32\\cmd.exe"), _T("/C \"start http://sourceforge.net/projects/advantrigoncalc/files/Setup%20Advanced%20Trigonometry%20Calculator.exe/download\""), NULL, SW_SHOW);
				}
				if (arithTrig[i] == 'u'&&arithTrig[i + 1] == 's'&&arithTrig[i + 2] == 'e'&&arithTrig[i + 3] == 'r'&&arithTrig[i + 4] == 'g'&&arithTrig[i + 5] == 'u'&&arithTrig[i + 6] == 'i'&&arithTrig[i + 7] == 'd'&&arithTrig[i + 8] == 'e'&&arithTrig[i + 11] == '\0' || arithTrig[i] == 'm'&&arithTrig[i + 1] == 'a' && arithTrig[i + 2] == 'n' && arithTrig[i + 3] == 'u'&&arithTrig[i + 4] == 'a'&&arithTrig[i + 5] == 'l'&&arithTrig[i + 8] == '\0'){
					command = 1;
					puts(" ");
					ShellExecute(NULL, _T("open"), _T("Advanced Trigonometry Calculator - User Guide.pdf"), NULL, NULL, SW_SHOW);
				}
				if (arithTrig[i] == 's'&&arithTrig[i + 1] == 'u'&&arithTrig[i + 2] == 's'&&arithTrig[i + 3] == 'p'&&arithTrig[i + 4] == 'e'&&arithTrig[i + 5] == 'n'&&arithTrig[i + 6] == 'd'&&arithTrig[i + 7] == 'e'&&arithTrig[i + 8] == 'r'&&arithTrig[i + 11] == '\0' || arithTrig[i] == 's'&&arithTrig[i + 1] == 'l' && arithTrig[i + 2] == 'e' && arithTrig[i + 3] == 'e'&&arithTrig[i + 4] == 'p'&&arithTrig[i + 7] == '\0'){
					command = 1;
					puts(" ");
					ShellExecute(NULL, _T("runas"), _T("C:\\WINDOWS\\system32\\cmd.exe"), _T("/C \"powercfg -hibernate off\""), NULL, SW_SHOW);
					Sleep(5000);
					system("C:\\WINDOWS\\System32\\Rundll32.exe powrprof.dll,SetSuspendState Sleep");
				}
				if (arithTrig[i] == 'b'&&arithTrig[i + 1] == 'l'&&arithTrig[i + 2] == 'o'&&arithTrig[i + 3] == 'q'&&arithTrig[i + 4] == 'u'&&arithTrig[i + 5] == 'e'&&arithTrig[i + 6] == 'a'&&arithTrig[i + 7] == 'r'&&arithTrig[i + 10] == '\0' || arithTrig[i] == 'l'&&arithTrig[i + 1] == 'o' && arithTrig[i + 2] == 'c' && arithTrig[i + 3] == 'k'&&arithTrig[i + 6] == '\0'){
					command = 1;
					puts(" ");
					system("C:\\WINDOWS\\System32\\Rundll32.exe User32.dll,LockWorkStation");
				}
				if (arithTrig[i] == 'h'&&arithTrig[i + 1] == 'i'&&arithTrig[i + 2] == 'b'&&arithTrig[i + 3] == 'e'&&arithTrig[i + 4] == 'r'&&arithTrig[i + 5] == 'n'&&arithTrig[i + 6] == 'a'&&arithTrig[i + 7] == 'r'&&arithTrig[i + 10] == '\0' || arithTrig[i] == 'h'&&arithTrig[i + 1] == 'i' && arithTrig[i + 2] == 'b' && arithTrig[i + 3] == 'e'&& arithTrig[i + 4] == 'r'&&arithTrig[i + 5] == 'n'&&arithTrig[i + 6] == 'a'&&arithTrig[i + 7] == 't'&&arithTrig[i + 8] == 'e'&&arithTrig[i + 11] == '\0'){
					command = 1;
					puts(" ");
					ShellExecute(NULL, _T("runas"), _T("C:\\WINDOWS\\system32\\cmd.exe"), _T("/C \"powercfg -hibernate on\""), NULL, SW_SHOW);
					Sleep(5000);
					system("C:\\WINDOWS\\System32\\rundll32.exe PowrProf.dll,SetSuspendState Hibernate");
				}
				if (arithTrig[i] == 'e'&&arithTrig[i + 1] == 'n'&&arithTrig[i + 2] == 'c'&&arithTrig[i + 3] == 'e'&&arithTrig[i + 4] == 'r'&&arithTrig[i + 5] == 'r'&&arithTrig[i + 6] == 'a'&&arithTrig[i + 7] == 'r'&&arithTrig[i + 10] == '\0' || arithTrig[i] == 's'&&arithTrig[i + 1] == 'h' && arithTrig[i + 2] == 'u' && arithTrig[i + 3] == 't'&& arithTrig[i + 4] == 'd'&&arithTrig[i + 5] == 'o'&&arithTrig[i + 6] == 'w'&&arithTrig[i + 7] == 'n'&&arithTrig[i + 10] == '\0'){
					continu = 0;
					command = 1;
					if (IsPreviousToWindowsVista() == true){
						system("C:\\WINDOWS\\System32\\shutdown -s");
					}
					else{
						system("C:\\WINDOWS\\System32\\shutdown /s");
					}
				}
				if (arithTrig[i] == 'r'&&arithTrig[i + 1] == 'e'&&arithTrig[i + 2] == 'i'&&arithTrig[i + 3] == 'n'&&arithTrig[i + 4] == 'i'&&arithTrig[i + 5] == 'c'&&arithTrig[i + 6] == 'i'&&arithTrig[i + 7] == 'a'&&arithTrig[i + 8] == 'r' &&arithTrig[i + 11] == '\0' || arithTrig[i] == 'r'&&arithTrig[i + 1] == 'e' && arithTrig[i + 2] == 's' && arithTrig[i + 3] == 't'&& arithTrig[i + 4] == 'a'&&arithTrig[i + 5] == 'r'&&arithTrig[i + 6] == 't'&&arithTrig[i + 9] == '\0'){
					continu = 0;
					command = 1;
					if (IsPreviousToWindowsVista() == true){
						system("C:\\WINDOWS\\System32\\shutdown -r");
					}
					else{
						system("C:\\WINDOWS\\System32\\shutdown /r");
					}
				}
				if (arithTrig[i] == 's'&&arithTrig[i + 1] == 'a'&&arithTrig[i + 2] == 'i'&&arithTrig[i + 3] == 'r'&&arithTrig[i + 6] == '\0' || (arithTrig[i] == 'e' || arithTrig[i] == 'E') && arithTrig[i + 1] == 'x'&&arithTrig[i + 2] == 'i'&&arithTrig[i + 3] == 't'&&arithTrig[i + 6] == '\0'){
					continu = 0;
					fprintf(fout, "\n");
					command = 1;
				}
				if (arithTrig[i] == 'l'&&arithTrig[i + 1] == 'i'&&arithTrig[i + 2] == 'm'&&arithTrig[i + 3] == 'p'&&arithTrig[i + 4] == 'a'&&arithTrig[i + 5] == 'r'&&arithTrig[i + 6] != 'h'&&arithTrig[i + 8] == '\0' || arithTrig[i] == 'c'&&arithTrig[i + 1] == 'l' && (arithTrig[i + 2] == 'e' || arithTrig[i + 2] == 'E') && arithTrig[i + 3] == 'a'&&arithTrig[i + 4] == 'n'&&arithTrig[i + 5] != 'h'&&arithTrig[i + 7] == '\0'){
					cls(); command = 1;
					arithTrig[0] = '\0';
					fprintf(fout, "\n");
				}
				if (arithTrig[i] == 's'&&arithTrig[i + 1] == 'o'&&arithTrig[i + 2] == 'b'&&arithTrig[i + 3] == 'r' && (arithTrig[i + 4] == 'e' || arithTrig[i + 4] == 'E') && arithTrig[i + 7] == '\0' || arithTrig[i] == 'a'&&arithTrig[i + 1] == 'b'&&arithTrig[i + 2] == 'o'&&arithTrig[i + 3] == 'u'&&arithTrig[i + 4] == 't'&&arithTrig[i + 7] == '\0'){
					arithTrig[0] = '\0'; command = 1;
					cls();
					about2();
					fprintf(fout, "\n");
				}
				if (arithTrig[i] == 'm'&&arithTrig[i + 1] == 'o'&&arithTrig[i + 2] == 'd' && (arithTrig[i + 3] == 'e' || arithTrig[i + 3] == 'E') && arithTrig[i + 6] == '\0' || arithTrig[i] == 'm'&&arithTrig[i + 1] == 'o'&&arithTrig[i + 2] == 'd'&&arithTrig[i + 3] == 'o'&&arithTrig[i + 6] == '\0'){
					arithTrig[0] = '\0'; command = 1;
					printf("\n==> Configuration of mode <==\n\n");
					fprintf(fout, "\n==> Configuration of mode <==\n\n");
					mode();
					fprintf(fout, "\n");
					printf("\n");
				}
				if (arithTrig[i] == 'l'&&arithTrig[i + 1] == 'i'&&arithTrig[i + 2] == 'm'&&arithTrig[i + 3] == 'p'&&arithTrig[i + 4] == 'a'&&arithTrig[i + 5] == 'r'&&arithTrig[i + 6] == 'h'&&arithTrig[i + 7] == 'i'&&arithTrig[i + 8] == 's'&&arithTrig[i + 9] == 't'&&arithTrig[i + 10] == 'o'&&arithTrig[i + 11] == 'r'&&arithTrig[i + 12] == 'i'&&arithTrig[i + 13] == 'c'&&arithTrig[i + 14] == 'o'&&arithTrig[i + 17] == '\0' || arithTrig[i] == 'c'&&arithTrig[i + 1] == 'l' && (arithTrig[i + 2] == 'e' || arithTrig[i + 2] == 'E') && arithTrig[i + 3] == 'a'&&arithTrig[i + 4] == 'n'&&arithTrig[i + 5] == 'h'&&arithTrig[i + 6] == 'i'&&arithTrig[i + 7] == 's'&&arithTrig[i + 8] == 't'&&arithTrig[i + 9] == 'o'&&arithTrig[i + 10] == 'r'&&arithTrig[i + 11] == 'y'&&arithTrig[i + 14] == '\0'){
					fclean = NULL;
					while (fclean == NULL){
						fclean = fopen(path, "w");
					}command = 1;
					fclose(fclean);
					printf("\n==> The history was cleaned sucessfully. <==\n\n");
					fprintf(fout, "\n==> The history was cleaned sucessfully. <==\n\n");
					arithTrig[0] = '\0';
					cleanhistory = 1;
				}
				if (arithTrig[i] == 'c'&&arithTrig[i + 1] == 'o'&&arithTrig[i + 2] == 'r' && (arithTrig[i + 3] == 'e' || arithTrig[i + 3] == 'E') && arithTrig[i + 4] == 's'&&arithTrig[i + 7] == '\0' || arithTrig[i] == 'c'&&arithTrig[i + 1] == 'o'&&arithTrig[i + 2] == 'l'&&arithTrig[i + 3] == 'o'&&arithTrig[i + 4] == 'r'&&arithTrig[i + 5] == 's'&&arithTrig[i + 8] == '\0'){
					arithTrig[0] = '\0'; command = 1;
					printf("\n==> Configuration of background and text colors <==\n\n");
					fprintf(fout, "\n==> Configuration of background and text colors <==\n\n");
					colors();
				}
				if (arithTrig[i] == 'd'&&arithTrig[i + 1] == 'i'&&arithTrig[i + 2] == 'm' && (arithTrig[i + 3] == 'e' || arithTrig[i + 3] == 'E') && arithTrig[i + 4] == 'n'&&arithTrig[i + 5] == 's'&&arithTrig[i + 6] == 'o' && (arithTrig[i + 7] == 'e' || arithTrig[i + 7] == 'E') && arithTrig[i + 8] == 's'&&arithTrig[i + 11] == '\0' || arithTrig[i] == 'd'&&arithTrig[i + 1] == 'i'&&arithTrig[i + 2] == 'm' && (arithTrig[i + 3] == 'e' || arithTrig[i + 3] == 'E') && arithTrig[i + 4] == 'n'&&arithTrig[i + 5] == 's'&&arithTrig[i + 6] == 'i'&&arithTrig[i + 7] == 'o'&&arithTrig[i + 8] == 'n'&&arithTrig[i + 9] == 's'&&arithTrig[i + 12] == '\0'){
					arithTrig[0] = '\0'; command = 1;
					printf("\n==> Dimensional configuration of the application window <==\n\n");
					fprintf(fout, "\n==> Dimensional configuration of the application window <==\n\n");
					dimensions();
				}
				if (arithTrig[i] == 'j'&&arithTrig[i + 1] == 'a'&&arithTrig[i + 2] == 'n' && (arithTrig[i + 3] == 'e' || arithTrig[i + 3] == 'E') && arithTrig[i + 4] == 'l'&&arithTrig[i + 5] == 'a'&&arithTrig[i + 8] == '\0' || arithTrig[i] == 'w'&&arithTrig[i + 1] == 'i'&&arithTrig[i + 2] == 'n'&&arithTrig[i + 3] == 'd'&&arithTrig[i + 4] == 'o'&&arithTrig[i + 5] == 'w'&&arithTrig[i + 8] == '\0'){
					arithTrig[0] = '\0'; command = 1;
					printf("\n==> Configuration of the position, width and height of the application window <==\n\n");
					fprintf(fout, "\n==> Configuration of the position, width and height of the application window <==\n\n");
					window();
				}
				if (arithTrig[i] == 'r'&&arithTrig[i + 1] == 'e'&&arithTrig[i + 2] == 's'&&arithTrig[i + 3] == 'o'&&arithTrig[i + 4] == 'l'&&arithTrig[i + 5] == 'v'&&arithTrig[i + 6] == 'e'&&arithTrig[i + 7] == 'r'&&arithTrig[i + 8] == 's'&&arithTrig[i + 9] == 'i'&&arithTrig[i + 10] == 's'&&arithTrig[i + 11] == 't'&&arithTrig[i + 12] == 'e'&&arithTrig[i + 13] == 'm'&&arithTrig[i + 14] == 'a'&&arithTrig[i + 15] == 'd'&&arithTrig[i + 16] == 'e'&&arithTrig[i + 17] == 'e'&&arithTrig[i + 18] == 'q'&&arithTrig[i + 19] == 'u'&&arithTrig[i + 20] == 'a'&&arithTrig[i + 21] == 'c'&&arithTrig[i + 22] == 'o'&&arithTrig[i + 23] == 'e'&&arithTrig[i + 24] == 's' &&arithTrig[i + 25] == '(' || arithTrig[i] == 's'&&arithTrig[i + 1] == 'o'&&arithTrig[i + 2] == 'l'&&arithTrig[i + 3] == 'v'&&arithTrig[i + 4] == 'e'&&arithTrig[i + 5] == 'e'&&arithTrig[i + 6] == 'q'&&arithTrig[i + 7] == 'u'&&arithTrig[i + 8] == 'a'&&arithTrig[i + 9] == 't'&&arithTrig[i + 10] == 'i'&&arithTrig[i + 11] == 'o'&&arithTrig[i + 12] == 'n'&&arithTrig[i + 13] == 's'&&arithTrig[i + 14] == 's'&&arithTrig[i + 15] == 'y'&&arithTrig[i + 16] == 's'&&arithTrig[i + 17] == 't'&&arithTrig[i + 18] == 'e'&&arithTrig[i + 19] == 'm'&&arithTrig[i + 20] == '('){
					int correct = 1;
					count = 2;
					if (arithTrig[i + 25] == '('){
						i = i + 26;
					}
					else{
						if (arithTrig[i + 20] == '('){
							i = i + 21;
						}
					}
					char matrix[DIM] = "";
					int p = 0, countR = 0, countL = 0;
					for (p = i; arithTrig[p] != '\0'; p++){
						if (arithTrig[p] == '(' || arithTrig[p] == '[' || arithTrig[p] == '{'){
							countL++;
						}
						if (arithTrig[p] == ')' || arithTrig[p] == ']' || arithTrig[p] == '}'){
							countR++;
						}
					}
					if (countR > 0){
						countR--;
					}
					if (countL == countR){
						p = 0;
						while (arithTrig[i] != ')'&&arithTrig[i] != '\0' || countR > 0){
							if (arithTrig[i] == '(' || arithTrig[i] == '[' || arithTrig[i] == '{'){
								countL--;
							}
							if (arithTrig[i] == ')' || arithTrig[i] == ']' || arithTrig[i] == '}'){
								countR--;
							}
							matrix[p] = arithTrig[i];
							p++;
							i++;
						}
						matrix[p] = '\0';
						if (arithTrig[i] == '\0'){
							printf("\n==> The character ')' is missing. <==\n\n");
							fprintf(fout, "\n==> The character ')' is missing. <==\n\n");
						}
						else{
							int lines = 0, cols = 0;
							for (p = 0; matrix[p] != '\0'; p++){
								if (matrix[p] == '\\'){
									cols++;
								}
								if (matrix[p] == ';'){
									lines++;
								}
							}
							lines++;
							if (lines*lines == cols){
								matrixToValues(matrix, result);
								rearrangeValues();
								solveSystem();
								getSolutions();

								int q = 0;
								double solutionR = 0, solutionI = 0;
								for (p = 0; p < count - 1; p++){
									for (q = 0; q < count; q++){
										multiplication(valuesS[p][q], valuesSI[p][q], values[q][count - 1], valuesI[q][count - 1]);

										solutionR = solutionR + resultR;
										solutionI = solutionI + resultI;

									}

									char Value[DIM] = "";
									sprintf(Value, "%G", solutionR);
									for (int v = 0; Value[v]; v++){
										if (Value[v] == '-')
											Value[v] = '_';
									}
									solutionR = initialProcessor(Value, 0);
									sprintf(Value, "%G", valuesS[p][count - 1]);
									for (int v = 0; Value[v]; v++){
										if (Value[v] == '-') {
											Value[v] = '_';
										}
										if (Value[v] == '+') {
											Value[v] = '0';
										}
									}
									valuesS[p][count - 1] = initialProcessor(Value, 0);


									sprintf(Value, "%G", solutionI);
									for (int v = 0; Value[v]; v++){
										if (Value[v] == '-')
											Value[v] = '_';
									}
									solutionI = initialProcessor(Value, 0);
									sprintf(Value, "%G", valuesSI[p][count - 1]);
									for (int v = 0; Value[v]; v++){
										if (Value[v] == '-') {
											Value[v] = '_';
										}
										if (Value[v] == '+') {
											Value[v] = '0';
										}
									}
									valuesSI[p][count - 1] = initialProcessor(Value, 0);
									if (solutionR != valuesS[p][count - 1] || solutionI != valuesSI[p][count - 1]){
										printf("\n==> Unsolvable system. <==\n\n");
										fprintf(fout, "\n==> Unsolvable system. <==\n\n");
										correct = 0;
										break;
									}
									solutionR = 0;
									solutionI = 0;
								}
								if (correct == 1){
									puts("");
									for (p = 0; p < count - 1; p++){
										char Value[DIM] = "";
										sprintf(Value, "%f", values[p][count - 1]);
										for (int v = 0; Value[v]; v++){
											if (Value[v] == '-')
												Value[v] = '_';
										}
										values[p][count - 1] = initialProcessor(Value, 0);
										if (values[p][count - 1] > 0 && valuesI[p][count - 1] > 0){
											printf("x%d=%G+%Gi\n", p + 1, values[p][count - 1], valuesI[p][count - 1]);
											fprintf(fout, "x%d=%G+%Gi\n", p + 1, values[p][count - 1], valuesI[p][count - 1]);
										}
										else{
											if (values[p][count - 1] > 0 && valuesI[p][count - 1] < 0)   {
												printf("x%d=%G%Gi\n", p + 1, values[p][count - 1], valuesI[p][count - 1]);
												fprintf(fout, "x%d=%G%Gi\n", p + 1, values[p][count - 1], valuesI[p][count - 1]);
											}
											else{
												if (values[p][count - 1] < 0 && valuesI[p][count - 1] < 0)   {
													printf("x%d=%G%Gi\n", p + 1, values[p][count - 1], valuesI[p][count - 1]);
													fprintf(fout, "x%d=%G%Gi\n", p + 1, values[p][count - 1], valuesI[p][count - 1]);
												}
												else{
													if (values[p][count - 1] < 0 && valuesI[p][count - 1] > 0)   {
														printf("x%d=%G+%Gi\n", p + 1, values[p][count - 1], valuesI[p][count - 1]);
														fprintf(fout, "x%d=%G+%Gi\n", p + 1, values[p][count - 1], valuesI[p][count - 1]);
													}
													else{
														if (values[p][count - 1] == 0 && valuesI[p][count - 1] != 0)   {
															printf("x%d=%Gi\n", p + 1, valuesI[p][count - 1]);
															fprintf(fout, "x%d=%Gi\n", p + 1, valuesI[p][count - 1]);
														}
														else{
															if (values[p][count - 1] != 0 && valuesI[p][count - 1] == 0)   {
																printf("x%d=%G\n", p + 1, values[p][count - 1]);
																fprintf(fout, "x%d=%G\n", p + 1, values[p][count - 1]);
															}
														}

													}
												}
											}
										}
									}
									puts("");
									fputs("", fout);
								}
							}
							else{
								printf("\nError in the introduction of the system of equations matrix.\n ==> Based in the number of rows is concluded that some elements are in fault or they are more than the needed.\n\n");
								fprintf(fout, "\nError in the introduction of the system of equations matrix.\n ==> Based in the number of rows is concluded that some elements are in fault or they are more than the needed.\n\n");
							}
						}
					}
					else{
						printf("\nError in parentheses. \n ==> The number of left and right parenthesis entered must be equal.\n ==> Enter \"[\" or \"{\" is the same as \"(\" and \"]\" or \"}\" is the same as \")\".\n ==> The expression that you entered has %d left parenthesis and %d right parenthesis.\n\n\n", countL, countR);
						fprintf(fout, "\nError in parentheses. \n ==> The number of left and right parenthesis entered must be equal.\n ==> Enter \"[\" or \"{\" is the same as \"(\" and \"]\" or \"}\" is the same as \")\".\n ==> The expression that you entered has %d left parenthesis and %d right parenthesis.\n\n\n", countL, countR);
					}
					arithTrig[0] = '\0'; command = 1;
				}
				if (arithTrig[i] == 'e'&&arithTrig[i + 1] == 'l'&&arithTrig[i + 2] == 'i'&&arithTrig[i + 3] == 'm'&&arithTrig[i + 4] == 'i'&&arithTrig[i + 5] == 'n'&&arithTrig[i + 6] == 'a'&&arithTrig[i + 7] == 'r'&&arithTrig[i + 8] == 'v'&&arithTrig[i + 9] == 'a'&&arithTrig[i + 10] == 'r'&&arithTrig[i + 11] == 'i'&&arithTrig[i + 12] == 'a'&&arithTrig[i + 13] == 'v'&&arithTrig[i + 14] == 'e'&&arithTrig[i + 15] == 'i'&&arithTrig[i + 16] == 's'&&arithTrig[i + 19] == '\0' || arithTrig[i] == 'e'&&arithTrig[i + 1] == 'l'&&arithTrig[i + 2] == 'i'&&arithTrig[i + 3] == 'm'&&arithTrig[i + 4] == 'i'&&arithTrig[i + 5] == 'n'&&arithTrig[i + 6] == 'a'&&arithTrig[i + 7] == 't'&&arithTrig[i + 8] == 'e'&&arithTrig[i + 9] == 'v'&&arithTrig[i + 10] == 'a'&&arithTrig[i + 11] == 'r'&&arithTrig[i + 12] == 'i'&&arithTrig[i + 13] == 'a'&&arithTrig[i + 14] == 'b'&&arithTrig[i + 15] == 'l'&&arithTrig[i + 16] == 'e'&&arithTrig[i + 17] == 's'&&arithTrig[i + 20] == '\0'){
					FILE *open = NULL;
					int r = 0;
					while (open == NULL&&r < 100){
						open = fopen("variables.txt", "w");
						r++;
					}
					if (r < 100){
						command = 1;
						fclose(open);
						open = NULL;
						r = 0;
						while (open == NULL&&r < 100){
							open = fopen("renamedVar.txt", "w");
							r++;
						}
						if (r < 100){
							fclose(open);
							printf("\n==> The variables were eliminated sucessfully. <==\n\n");
							fprintf(fout, "\n==> The variables were eliminated sucessfully. <==\n\n");
							arithTrig[0] = '\0';
						}
					}
				}

				if (arithTrig[i] == 'c'&&arithTrig[i + 1] == 'r'&&arithTrig[i + 2] == 'o'&&arithTrig[i + 3] == 'n'&&arithTrig[i + 4] == 'o'&&arithTrig[i + 5] == 'm'&&arithTrig[i + 6] == 'e'&&arithTrig[i + 7] == 't'&&arithTrig[i + 8] == 'r'&&arithTrig[i + 9] == 'o'&&arithTrig[i + 10] == '(' || arithTrig[i] == 's'&&arithTrig[i + 1] == 't'&&arithTrig[i + 2] == 'o'&&arithTrig[i + 3] == 'p'&&arithTrig[i + 4] == 'w'&&arithTrig[i + 5] == 'a'&&arithTrig[i + 6] == 't'&&arithTrig[i + 7] == 'c'&&arithTrig[i + 8] == 'h'&&arithTrig[i + 9] == '('){
					printf("\nPress \"Enter\" button to mark time.\n");
					fprintf(fout, "\nPress \"Enter\" button to mark time.\n");
					int ct = 0, countT = 0;
					char countTimes[DIM] = "", pause[1000] = "";
					double stopTime = 0;
					if (arithTrig[i] == 'c'){
						i = i + 11;
					}
					else{
						i = i + 10;
					}
					ct = 0;
					while (arithTrig[i] != '\0'&&arithTrig[i] != ')'){
						countTimes[ct] = arithTrig[i];
						ct++; i++;
					}
					countTimes[ct] = '\0';
					countT = abs((int)initialProcessor(countTimes, result));
					clock_t start, end;
					start = clock();
					ct = 0;
					while (ct < countT){
						char pause[1000] = "";
						gets(pause);
						end = clock();
						stopTime = (double)(end - start) / CLOCKS_PER_SEC;
						int days = qu(stopTime, 86400);
						int hours = qu(re(stopTime, 86400), 3600);
						int minutes = qu(re(re(stopTime, 86400), 3600), 60);
						int seconds = re(re(re(stopTime, 86400), 3600), 60);
						int miliseconds = 1000 * (stopTime - qu(stopTime, 1));
						printf("t%d=", ct + 1);
						fprintf(fout, "t%d=", ct + 1);
						if (days != 0){
							printf("%dd ", days);
							fprintf(fout, "%dd ", days);
						}
						if (hours != 0){
							printf("%dh ", hours);
							fprintf(fout, "%dh ", hours);
						}
						if (minutes != 0){
							printf("%dm ", minutes);
							fprintf(fout, "%dm ", minutes);
						}

						if (seconds != 0){
							printf("%ds ", seconds);
							fprintf(fout, "%ds ", seconds);
						}
						if (miliseconds != 0){
							printf("%dms ", miliseconds);
							fprintf(fout, "%dms ", miliseconds);
						}
						printf("\n");
						fprintf(fout, "\n");
						ct++;
					}
					puts("");
					fputs("\n", fout);
					command = 1;
					arithTrig[0] = '\0';
				}

				if (arithTrig[i] == 'e'&&arithTrig[i + 1] == 'l'&&arithTrig[i + 2] == 'i'&&arithTrig[i + 3] == 'm'&&arithTrig[i + 4] == 'i'&&arithTrig[i + 5] == 'n'&&arithTrig[i + 6] == 'a'&&arithTrig[i + 7] == 'r'&&arithTrig[i + 8] == 'r'&&arithTrig[i + 9] == 'e'&&arithTrig[i + 10] == 's'&&arithTrig[i + 11] == 'u'&&arithTrig[i + 12] == 'l'&&arithTrig[i + 13] == 't'&&arithTrig[i + 14] == 'a'&&arithTrig[i + 15] == 'd'&&arithTrig[i + 16] == 'o'&&arithTrig[i + 17] == 's'&&arithTrig[i + 20] == '\0' || arithTrig[i] == 'e'&&arithTrig[i + 1] == 'l'&&arithTrig[i + 2] == 'i'&&arithTrig[i + 3] == 'm'&&arithTrig[i + 4] == 'i'&&arithTrig[i + 5] == 'n'&&arithTrig[i + 6] == 'a'&&arithTrig[i + 7] == 't'&&arithTrig[i + 8] == 'e'&&arithTrig[i + 9] == 'r'&&arithTrig[i + 10] == 'e'&&arithTrig[i + 11] == 's'&&arithTrig[i + 12] == 'u'&&arithTrig[i + 13] == 'l'&&arithTrig[i + 14] == 't'&&arithTrig[i + 15] == 's'&&arithTrig[i + 18] == '\0'){
					r = 0; command = 1;
					while (r < rf){
						ans[r] = 0;
						ansI[r] = 0;
						r++;
					}
					rf = 0;
					printf("\n==> The results were eliminated successfully. <==\n\n");
					fprintf(fout, "\n==> The results were eliminated successfully. <==\n\n");
					arithTrig[0] = '\0';
				}
				if (arithTrig[i] == 'v'&&arithTrig[i + 1] == 'e'&&arithTrig[i + 2] == 'r'&&arithTrig[i + 3] == 'v'&&arithTrig[i + 4] == 'a'&&arithTrig[i + 5] == 'r'&&arithTrig[i + 6] == 'i'&&arithTrig[i + 7] == 'a'&&arithTrig[i + 8] == 'v'&&arithTrig[i + 9] == 'e'&&arithTrig[i + 10] == 'i'&&arithTrig[i + 11] == 's'&&arithTrig[i + 14] == '\0' || arithTrig[i] == 's'&&arithTrig[i + 1] == 'e'&&arithTrig[i + 2] == 'e'&&arithTrig[i + 3] == 'v'&&arithTrig[i + 4] == 'a'&&arithTrig[i + 5] == 'r'&&arithTrig[i + 6] == 'i'&&arithTrig[i + 7] == 'a'&&arithTrig[i + 8] == 'b'&&arithTrig[i + 9] == 'l'&&arithTrig[i + 10] == 'e'&&arithTrig[i + 11] == 's'&&arithTrig[i + 14] == '\0'){
					FILE *open = NULL;
					int r = 0;
					while (open == NULL&&r < 100){
						open = fopen("variables.txt", "a+");
						r++;
					}
					if (r < 100){
						command = 1;
						int w;
						char seeVar[DIM] = "";
						for (w = 0; (seeVar[w] = fgetc(open)) != EOF; w++);
						seeVar[w] = '\0';
						fclose(open);
						if (seeVar[0] != '\0'){
							printf("\nVariable value\n\n%s\n", seeVar);
							fprintf(fout, "\nVariable value\n\n%s\n", seeVar);
						}
						else{
							printf("\n==> No variable created! <==\n\n");
							fprintf(fout, "\n==> No variable created! <==\n\n");
						}
						arithTrig[0] = '\0';
					}
				}
				if (arithTrig[i] == 'e'&&arithTrig[i + 1] == 'l'&&arithTrig[i + 2] == 'i'&&arithTrig[i + 3] == 'm'&&arithTrig[i + 4] == 'i'&&arithTrig[i + 5] == 'n'&&arithTrig[i + 6] == 'a'&&arithTrig[i + 7] == 'r'&&arithTrig[i + 8] == 'a'&&arithTrig[i + 9] == 'b'&&arithTrig[i + 10] == 'r'&&arithTrig[i + 11] == 'e'&&arithTrig[i + 12] == 'v'&&arithTrig[i + 13] == 'i'&&arithTrig[i + 14] == 'a'&&arithTrig[i + 15] == 't'&&arithTrig[i + 16] == 'u'&&arithTrig[i + 17] == 'r'&&arithTrig[i + 18] == 'a'&&arithTrig[i + 19] == 's'&&arithTrig[i + 22] == '\0' || arithTrig[i] == 'e'&&arithTrig[i + 1] == 'l'&&arithTrig[i + 2] == 'i'&&arithTrig[i + 3] == 'm'&&arithTrig[i + 4] == 'i'&&arithTrig[i + 5] == 'n'&&arithTrig[i + 6] == 'a'&&arithTrig[i + 7] == 't'&&arithTrig[i + 8] == 'e'&&arithTrig[i + 9] == 'a'&&arithTrig[i + 10] == 'b'&&arithTrig[i + 11] == 'b'&&arithTrig[i + 12] == 'r'&&arithTrig[i + 13] == 'e'&&arithTrig[i + 14] == 'v'&&arithTrig[i + 15] == 'i'&&arithTrig[i + 16] == 'a'&&arithTrig[i + 17] == 't'&&arithTrig[i + 18] == 'i'&&arithTrig[i + 19] == 'o'&&arithTrig[i + 20] == 'n'&&arithTrig[i + 21] == 's'&&arithTrig[i + 24] == '\0'){
					FILE *open = NULL;	 command = 1;
					while (open == NULL){
						open = fopen("pathName.txt", "w");
					}
					printf("\n==> The abbreviations were eliminated successfully. <==\n\n");
					fprintf(fout, "\n==> The abbreviations were eliminated successfully. <==\n\n");
					arithTrig[0] = '\0';
					fclose(open);
				}
				if (arithTrig[i] == 'v'&&arithTrig[i + 1] == 'e'&&arithTrig[i + 2] == 'r'&&arithTrig[i + 3] == 'a'&&arithTrig[i + 4] == 'b'&&arithTrig[i + 5] == 'r'&&arithTrig[i + 6] == 'e'&&arithTrig[i + 7] == 'v'&&arithTrig[i + 8] == 'i'&&arithTrig[i + 9] == 'a'&&arithTrig[i + 10] == 't'&&arithTrig[i + 11] == 'u'&&arithTrig[i + 12] == 'r'&&arithTrig[i + 13] == 'a'&&arithTrig[i + 14] == 's'&&arithTrig[i + 17] == '\0' || arithTrig[i] == 's'&&arithTrig[i + 1] == 'e'&&arithTrig[i + 2] == 'e'&&arithTrig[i + 3] == 'a'&&arithTrig[i + 4] == 'b'&&arithTrig[i + 5] == 'b'&&arithTrig[i + 6] == 'r'&&arithTrig[i + 7] == 'e'&&arithTrig[i + 8] == 'v'&&arithTrig[i + 9] == 'i'&&arithTrig[i + 10] == 'a'&&arithTrig[i + 11] == 't'&&arithTrig[i + 12] == 'i'&&arithTrig[i + 13] == 'o'&&arithTrig[i + 14] == 'n'&&arithTrig[i + 15] == 's'&&arithTrig[i + 18] == '\0'){
					FILE *open = NULL;	   command = 1;
					while (open == NULL){
						open = fopen("pathName.txt", "a+");
					}
					char dataPath[DIM] = "";
					int b = 0;
					for (b = 0; (dataPath[b] = fgetc(open)) != EOF; b++);
					dataPath[b] = '\0';
					arithTrig[0] = '\0'; command = 1;
					if (dataPath[0] != '\0'){
						printf("\nAbbreviations paths\n\n%s\n", dataPath);
						fprintf(fout, "\nAbbreviations paths\n\n%s\n", dataPath);
					}
					else{
						printf("\n==> No abbreviation created! <==\n\n");
						fprintf(fout, "\n==> No abbreviation created! <==\n\n");
					}
					fclose(open);
				}
				if (arithTrig[i] == 'v'&&arithTrig[i + 1] == 'e'&&arithTrig[i + 2] == 'r'&&arithTrig[i + 3] == 'r'&&arithTrig[i + 4] == 'e'&&arithTrig[i + 5] == 's'&&arithTrig[i + 6] == 'u'&&arithTrig[i + 7] == 'l'&&arithTrig[i + 8] == 't'&&arithTrig[i + 9] == 'a'&&arithTrig[i + 10] == 'd'&&arithTrig[i + 11] == 'o'&&arithTrig[i + 12] == 's'&&arithTrig[i + 15] == '\0' || arithTrig[i] == 's'&&arithTrig[i + 1] == 'e'&&arithTrig[i + 2] == 'e'&&arithTrig[i + 3] == 'r'&&arithTrig[i + 4] == 'e'&&arithTrig[i + 5] == 's'&&arithTrig[i + 6] == 'u'&&arithTrig[i + 7] == 'l'&&arithTrig[i + 8] == 't'&&arithTrig[i + 9] == 's'&&arithTrig[i + 12] == '\0'){
					arithTrig[0] = '\0'; command = 1;
					if (re > 0){
						printf("\nResult value\n\n");
						fprintf(fout, "\nResult value\n\n");
						r = 0;
						while (r < rf){
							if (ans[r] > 0 && ansI[r] > 0){
								printf("#%d=%G+%Gi\n", r, ans[r], ansI[r]);
								fprintf(fout, "#%d=%G+%Gi\n", r, ans[r], ansI[r]);
							}
							if (ans[r] > 0 && ansI[r] < 0){
								printf("#%d=%G%Gi\n", r, ans[r], ansI[r]);
								fprintf(fout, "#%d=%G%Gi\n", r, ans[r], ansI[r]);
							}
							if (ans[r] < 0 && ansI[r] > 0){
								printf("#%d=%G+%Gi\n", r, ans[r], ansI[r]);
								fprintf(fout, "#%d=%G+%Gi\n", r, ans[r], ansI[r]);
							}
							if (ans[r] < 0 && ansI[r] < 0){
								printf("#%d=%G%Gi\n", r, ans[r], ansI[r]);
								fprintf(fout, "#%d=%G%Gi\n", r, ans[r], ansI[r]);
							}
							if (ans[r] == 0 && ansI[r] == 0){
								printf("#%d=%G\n", r, ans[r]);
								fprintf(fout, "#%d=%G\n", r, ans[r]);
							}
							if (ans[r] == 0 && ansI[r] != 0){
								printf("#%d=%Gi\n", r, ansI[r]);
								fprintf(fout, "#%d=%Gi\n", r, ansI[r]);
							}
							if (ans[r] != 0 && ansI[r] == 0){
								printf("#%d=%G\n", r, ans[r]);
								fprintf(fout, "#%d=%G\n", r, ans[r]);
							}


							r++;
						}
						printf("\n");
						fprintf(fout, "\n");
					}
					else{
						printf("\n==> No calculated result! <==\n\n");
						fprintf(fout, "\n==> No calculated result! <==\n\n");
					}

				}
				if (arithTrig[i] == 'v'&&arithTrig[i + 1] == 'a'&&arithTrig[i + 2] == 'r'&&arithTrig[i + 3] == 'i'&&arithTrig[i + 4] == 'a'&&arithTrig[i + 5] == 'v'&&arithTrig[i + 6] == 'e'&&arithTrig[i + 7] == 'i'&&arithTrig[i + 8] == 's'&&arithTrig[i + 9] == 'r'&&arithTrig[i + 10] == 'e'&&arithTrig[i + 11] == 'n'&&arithTrig[i + 12] == 'o'&&arithTrig[i + 13] == 'm'&&arithTrig[i + 14] == 'e'&&arithTrig[i + 15] == 'a'&&arithTrig[i + 16] == 'd'&&arithTrig[i + 17] == 'a'&&arithTrig[i + 18] == 's'&&arithTrig[i + 21] == '\0' || arithTrig[i] == 'r'&&arithTrig[i + 1] == 'e'&&arithTrig[i + 2] == 'n'&&arithTrig[i + 3] == 'a'&&arithTrig[i + 4] == 'm'&&arithTrig[i + 5] == 'e'&&arithTrig[i + 6] == 'd'&&arithTrig[i + 7] == 'v'&&arithTrig[i + 8] == 'a'&&arithTrig[i + 9] == 'r'&&arithTrig[i + 10] == 'i'&&arithTrig[i + 11] == 'a'&&arithTrig[i + 12] == 'b'&&arithTrig[i + 13] == 'l'&&arithTrig[i + 14] == 'e'&&arithTrig[i + 15] == 's'&&arithTrig[i + 18] == '\0'){
					arithTrig[0] = '\0'; command = 1;
					FILE *open = NULL;
					int r = 0;
					while (open == NULL&&r < 100){
						open = fopen("renamedVar.txt", "a+");
						r++;
					}
					if (r < 100){
						int w;
						char seeVar[DIM] = "";
						for (w = 0; (seeVar[w] = fgetc(open)) != EOF; w++);
						seeVar[w] = '\0';
						fclose(open);
						if (seeVar[0] != '\0'){
							printf("\nVariable renaming\n\n%s\n", seeVar);
							fprintf(fout, "\nVariable renaming\n\n%s\n", seeVar);
						}
						else{
							printf("\n==> No variable created! <==\n\n");
							fprintf(fout, "\n==> No variable created! <==\n\n");
						}
					}
				}
				if (arithTrig[i] == 's'&&arithTrig[i + 1] == 'i'&&arithTrig[i + 2] == 's'&&arithTrig[i + 3] == 't'&&arithTrig[i + 4] == 'e'&&arithTrig[i + 5] == 'm'&&arithTrig[i + 6] == 'a'&&arithTrig[i + 7] == 's'&&arithTrig[i + 8] == 'n'&&arithTrig[i + 9] == 'u'&&arithTrig[i + 10] == 'm'&&arithTrig[i + 11] == 'e'&&arithTrig[i + 12] == 'r'&&arithTrig[i + 13] == 'i'&&arithTrig[i + 14] == 'c'&&arithTrig[i + 15] == 'o'&&arithTrig[i + 16] == 's'&&arithTrig[i + 19] == '\0' || arithTrig[i] == 'n'&&arithTrig[i + 1] == 'u'&&arithTrig[i + 2] == 'm'&&arithTrig[i + 3] == 'e'&&arithTrig[i + 4] == 'r'&&arithTrig[i + 5] == 'i'&&arithTrig[i + 6] == 'c'&&arithTrig[i + 7] == 'a'&&arithTrig[i + 8] == 'l'&&arithTrig[i + 9] == 's'&&arithTrig[i + 10] == 'y'&&arithTrig[i + 11] == 's'&&arithTrig[i + 12] == 't'&&arithTrig[i + 13] == 'e'&&arithTrig[i + 14] == 'm'&&arithTrig[i + 15] == 's'&&arithTrig[i + 18] == '\0'){
					char arithTrig[DIM] = ""; command = 1;
					arithTrig[0] = '\0';
					printf("\n==> Configuration of numerical systems response <==\n\n");
					fprintf(fout, "\n==> Configuration of numerical systems response <==\n\n");
					numSystemsController();
					fprintf(fout, "\n");
					printf("\n");
				}
				if (arithTrig[i] == 't'&&arithTrig[i + 1] == 'e'&&arithTrig[i + 2] == 'm'&&arithTrig[i + 3] == 'p'&&arithTrig[i + 4] == 'o'&&arithTrig[i + 5] == 'r'&&arithTrig[i + 6] == 'i'&&arithTrig[i + 7] == 'z'&&arithTrig[i + 8] == 'a'&&arithTrig[i + 9] == 'd'&&arithTrig[i + 10] == 'o'&&arithTrig[i + 11] == 'r'&&arithTrig[i + 12] == '(' || arithTrig[i] == 't'&&arithTrig[i + 1] == 'i'&&arithTrig[i + 2] == 'm'&&arithTrig[i + 3] == 'e'&&arithTrig[i + 4] == 'r'&&arithTrig[i + 5] == '('){
					if (arithTrig[i + 12] == '('){
						i = i + 13;
					}
					else{
						if (arithTrig[i + 5] == '('){
							i = i + 6;

						}
					}
					int t = i, p = 0;
					for (t; arithTrig[t] != '\0'; t++){
						if (arithTrig[t] == ')'){
							p++;
						}
					}
					if (p != 1){
						printf("\n\n==> You need to terminate the expression with ')' character. <==\n\n");
					}
					else{
						char time[DIM] = "", expression[DIM] = "";
						t = 0;
						int b = i;
						while (arithTrig[b] != ')'){
							expression[t] = arithTrig[b];
							b++; t++;
						}
						expression[t] = '\0';
						b = 0;
						int sep = 0;
						for (t = 0; expression[t] != '\0'; t++){
							if (expression[t] == ':' || expression[t] == '0' || expression[t] == '1' || expression[t] == '2' || expression[t] == '3' || expression[t] == '4' || expression[t] == '5' || expression[t] == '6' || expression[t] == '7' || expression[t] == '8' || expression[t] == '9') {
								b++;
								if (expression[t] == ':'){
									sep++;
								}
							}
						}
						if (b == strlen(expression) && sep == 2){
							t = 0;
							while (arithTrig[i] != ':'&&arithTrig[i] != ')') {
								time[t] = arithTrig[i];
								t++; i++;
							}
							i++;
							time[t] = '\0';
							int hours = initialProcessor(time, result);
							t = 0;
							while (arithTrig[i] != ':'&&arithTrig[i] != ')'&&arithTrig[i] != '\0') {
								time[t] = arithTrig[i];
								t++; i++;
							}
							time[t] = '\0';
							i++;
							int minutes = initialProcessor(time, result);
							t = 0;
							while (arithTrig[i] != ')'&&arithTrig[i] != '\0') {
								time[t] = arithTrig[i];
								t++; i++;
							}
							time[t] = '\0';
							int seconds = initialProcessor(time, result);
							clock_t start, end, syn1, syn2;
							int timePassed = 0, totalTime = hours * 3600 + minutes * 60 + seconds;
							int timeActual = 50, timepass = 0, time2syn = 0;
							start = clock();
							if (totalTime > 0){
								while (timeActual > 0){

									end = clock();
									timePassed = (end - start) / CLOCKS_PER_SEC;
									if (timePassed == 0){
										syn1 = clock();
										while (timepass == timePassed){
											end = clock();
											timePassed = (end - start) / CLOCKS_PER_SEC;
											Sleep(1);
										}
										syn2 = clock();
										time2syn = (int)(((double)(end - start) / CLOCKS_PER_SEC) * 1000);
									}
									else{
										Sleep(time2syn - 50);
										while (timepass == timePassed){
											end = clock();
											timePassed = (end - start) / CLOCKS_PER_SEC;
											Sleep(3);
										}
									}
									timeActual = totalTime - timePassed;
									int thours = timeActual / 3600;
									int tminutes = (timeActual % 3600) / 60;
									int tseconds = (timeActual % 3600) % 60;
									timepass = timePassed;
									printTimer(thours, tminutes, tseconds);
								}
							}
							i = 0;
							Sleep(400);
							while (i < 25){
								Beep(777, 400);
								Sleep(400);
								i++;
							}
						}
						else{
							printf("\n==> Your expression has syntax errors. <==\n\n");
						}
					}
					arithTrig[0] = '\0'; command = 1;
				}

				if (arithTrig[i] == 't'&&arithTrig[i + 1] == 'e'&&arithTrig[i + 2] == 'm'&&arithTrig[i + 3] == 'p'&&arithTrig[i + 4] == 'o'&&arithTrig[i + 5] == 'r'&&arithTrig[i + 6] == 'i'&&arithTrig[i + 7] == 'z'&&arithTrig[i + 8] == 'a'&&arithTrig[i + 9] == 'd'&&arithTrig[i + 10] == 'o'&&arithTrig[i + 11] == 'r'&&arithTrig[i + 12] == '(' || arithTrig[i] == 't'&&arithTrig[i + 1] == 'i'&&arithTrig[i + 2] == 'm'&&arithTrig[i + 3] == 'e'&&arithTrig[i + 4] == 'r'&&arithTrig[i + 5] == '('){
					if (arithTrig[i + 12] == '('){
						i = i + 13;
					}
					else{
						if (arithTrig[i + 5] == '('){
							i = i + 6;

						}
					}
					int t = i, p = 0;
					for (t; arithTrig[t] != '\0'; t++){
						if (arithTrig[t] == ')'){
							p++;
						}
					}
					if (p != 1){
						printf("\n\n==> You need to terminate the expression with ')' character. <==\n\n");
					}
					else{
						char time[DIM] = "", expression[DIM] = "";
						t = 0;
						int b = i;
						while (arithTrig[b] != ')'){
							expression[t] = arithTrig[b];
							b++; t++;
						}
						expression[t] = '\0';
						b = 0;
						int sep = 0;
						for (t = 0; expression[t] != '\0'; t++){
							if (expression[t] == ':' || expression[t] == '0' || expression[t] == '1' || expression[t] == '2' || expression[t] == '3' || expression[t] == '4' || expression[t] == '5' || expression[t] == '6' || expression[t] == '7' || expression[t] == '8' || expression[t] == '9') {
								b++;
								if (expression[t] == ':'){
									sep++;
								}
							}
						}
						if (b == strlen(expression) && sep == 2){
							t = 0;
							while (arithTrig[i] != ':'&&arithTrig[i] != ')') {
								time[t] = arithTrig[i];
								t++; i++;
							}
							i++;
							time[t] = '\0';
							int hours = initialProcessor(time, result);
							t = 0;
							while (arithTrig[i] != ':'&&arithTrig[i] != ')'&&arithTrig[i] != '\0') {
								time[t] = arithTrig[i];
								t++; i++;
							}
							time[t] = '\0';
							i++;
							int minutes = initialProcessor(time, result);
							t = 0;
							while (arithTrig[i] != ')'&&arithTrig[i] != '\0') {
								time[t] = arithTrig[i];
								t++; i++;
							}
							time[t] = '\0';
							int seconds = initialProcessor(time, result);
							clock_t start, end, syn1, syn2;
							int timePassed = 0, totalTime = hours * 3600 + minutes * 60 + seconds;
							int timeActual = 50, timepass = 0, time2syn = 0;
							start = clock();
							if (totalTime > 0){
								while (timeActual > 0){

									end = clock();
									timePassed = (end - start) / CLOCKS_PER_SEC;
									if (timePassed == 0){
										syn1 = clock();
										while (timepass == timePassed){
											end = clock();
											timePassed = (end - start) / CLOCKS_PER_SEC;
											Sleep(1);
										}
										syn2 = clock();
										time2syn = (int)(((double)(end - start) / CLOCKS_PER_SEC) * 1000);
									}
									else{
										Sleep(time2syn - 50);
										while (timepass == timePassed){
											end = clock();
											timePassed = (end - start) / CLOCKS_PER_SEC;
											Sleep(3);
										}
									}
									timeActual = totalTime - timePassed;
									int thours = timeActual / 3600;
									int tminutes = (timeActual % 3600) / 60;
									int tseconds = (timeActual % 3600) % 60;
									timepass = timePassed;
									printTimer(thours, tminutes, tseconds);
								}
							}
							i = 0;
							Sleep(400);
							while (i < 25){
								Beep(777, 400);
								Sleep(400);
								i++;
							}
						}
						else{
							printf("\n==> Your expression has syntax errors. <==\n\n");
						}
					}
					arithTrig[0] = '\0'; command = 1;
				}


				if (arithTrig[i] == 'r'&&arithTrig[i + 1] == 'e'&&arithTrig[i + 2] == 'l'&&arithTrig[i + 3] == 'o'&&arithTrig[i + 4] == 'g'&&arithTrig[i + 5] == 'i'&&arithTrig[i + 6] == 'o'&&arithTrig[i + 7] == '(' || arithTrig[i] == 'c'&&arithTrig[i + 1] == 'l'&&arithTrig[i + 2] == 'o'&&arithTrig[i + 3] == 'c'&&arithTrig[i + 4] == 'k'&&arithTrig[i + 5] == '('){
					if (arithTrig[i + 7] == '('){
						i = i + 8;
					}
					else{
						if (arithTrig[i + 5] == '('){
							i = i + 6;

						}
					}
					int t = i, p = 0;
					for (t; arithTrig[t] != '\0'; t++){
						if (arithTrig[t] == ')'){
							p++;
						}
					}
					if (p != 1){
						printf("\n\n==> You need to terminate the expression with ')' character. <==\n\n");
					}
					else{
						char timE[DIM] = "", expression[DIM] = "";
						t = 0;
						int b = i;
						while (arithTrig[b] != ')'){
							expression[t] = arithTrig[b];
							b++; t++;
						}
						expression[t] = '\0';
						b = 0;
						int sep = 0;
						for (t = 0; expression[t] != '\0'; t++){
							if (expression[t] == ':' || expression[t] == '0' || expression[t] == '1' || expression[t] == '2' || expression[t] == '3' || expression[t] == '4' || expression[t] == '5' || expression[t] == '6' || expression[t] == '7' || expression[t] == '8' || expression[t] == '9') {
								b++;
								if (expression[t] == ':'){
									sep++;
								}
							}
						}
						if (b == strlen(expression) && sep == 2){
							t = 0;
							while (arithTrig[i] != ':'&&arithTrig[i] != ')') {
								timE[t] = arithTrig[i];
								t++; i++;
							}
							i++;
							timE[t] = '\0';
							int hours = initialProcessor(timE, result);
							t = 0;
							while (arithTrig[i] != ':'&&arithTrig[i] != ')'&&arithTrig[i] != '\0') {
								timE[t] = arithTrig[i];
								t++; i++;
							}
							timE[t] = '\0';
							i++;
							int minutes = initialProcessor(timE, result);
							t = 0;
							while (arithTrig[i] != ')'&&arithTrig[i] != '\0') {
								timE[t] = arithTrig[i];
								t++; i++;
							}
							timE[t] = '\0';
							int seconds = initialProcessor(timE, result);
							clock_t start, end, syn1, syn2;
							int timePassed = 0, totalTime = hours * 3600 + minutes * 60 + seconds;
							int timeActual = 50, timepass = 0, time2syn = 0;
							int sec = 0;
							char seco[3] = "";
							char *tim;
							time_t hour1;
							time(&hour1);
							tim = ctime(&hour1);
							tim[24] = '\0';
							seco[0] = tim[17]; seco[1] = tim[18]; seco[2] = '\0';
							sec = atoi(seco);
							wait(sec);
							start = clock();
							if (totalTime > 0){
								while (timeActual > 0){

									end = clock();
									timePassed = (end - start) / CLOCKS_PER_SEC;
									if (timePassed == 0){
										syn1 = clock();
										while (timepass == timePassed){
											end = clock();
											timePassed = (end - start) / CLOCKS_PER_SEC;
											Sleep(1);
										}
										syn2 = clock();
										time2syn = (int)(((double)(end - start) / CLOCKS_PER_SEC) * 1000);
									}
									else{
										Sleep(time2syn - 50);
										while (timepass == timePassed){
											end = clock();
											timePassed = (end - start) / CLOCKS_PER_SEC;
											Sleep(3);
										}
									}
									timeActual = totalTime - timePassed;
									int thours = timeActual / 3600;
									int tminutes = (timeActual % 3600) / 60;
									int tseconds = (timeActual % 3600) % 60;
									if (tseconds == -1){ tseconds = 0; }
									timepass = timePassed;
									time_t hour;
									time(&hour);
									char *tim;
									tim = ctime(&hour);
									tim[24] = '\0';
									char hou[3] = { tim[11], tim[12], '\0' };
									int Hours = atoi(hou);
									char min[3] = { tim[14], tim[15], '\0' };
									int Minutes = atoi(min);
									char sec[3] = { tim[17], tim[18], '\0' };
									int Seconds = atoi(sec);
									printTimer(Hours, Minutes, Seconds);
									printf("\n\n%02d:%02d:%02d\n\n", thours, tminutes, tseconds);
								}
							}

						}
						else{
							printf("\n==> Your expression has syntax errors. <==\n\n");
						}
					}
					arithTrig[0] = '\0'; command = 1;
				}


				if (arithTrig[i] == 's'&&arithTrig[i + 1] == 'i'&&arithTrig[i + 2] == 'p'&&arithTrig[i + 3] == 'r'&&arithTrig[i + 4] == 'e'&&arithTrig[i + 5] == 'f'&&arithTrig[i + 6] == 'i'&&arithTrig[i + 7] == 'x'&&arithTrig[i + 8] == 'e'&&arithTrig[i + 9] == 's'&&arithTrig[i + 12] == '\0' || arithTrig[i] == 'p'&&arithTrig[i + 1] == 'r'&&arithTrig[i + 2] == 'e'&&arithTrig[i + 3] == 'f'&&arithTrig[i + 4] == 'i'&&arithTrig[i + 5] == 'x'&&arithTrig[i + 6] == 'o'&&arithTrig[i + 7] == 's'&&arithTrig[i + 8] == 's'&&arithTrig[i + 9] == 'i'&&arithTrig[i + 12] == '\0'){
					arithTrig[0] = '\0'; command = 1;
					printf("\n==> Configuration of SI prefixes response <==\n\n");
					fprintf(fout, "\n==> Configuration of SI prefixes response <==\n\n");
					siPrefixController();
					fprintf(fout, "\n");
					printf("\n");
				}
				if (arithTrig[i] == 't'&&arithTrig[i + 1] == 'i'&&arithTrig[i + 2] == 'm'&&arithTrig[i + 3] == 'e'&&arithTrig[i + 4] != 'r'&&arithTrig[i + 6] == '\0' || arithTrig[i] == 'h'&&arithTrig[i + 1] == 'o'&&arithTrig[i + 2] == 'r'&&arithTrig[i + 3] == 'a'&&arithTrig[i + 4] == 's'&&arithTrig[i + 5] != 'a'&&arithTrig[i + 7] == '\0'){
					arithTrig[0] = '\0'; command = 1;
					Clock(1);
					puts("");
				}
				if (arithTrig[i] == 'a'&&arithTrig[i + 1] == 'c'&&arithTrig[i + 2] == 't'&&arithTrig[i + 3] == 'u'&&arithTrig[i + 4] == 'a'&&arithTrig[i + 5] == 'l'&&arithTrig[i + 6] == 't'&&arithTrig[i + 7] == 'i'&&arithTrig[i + 8] == 'm'&&arithTrig[i + 9] == 'e'&&arithTrig[i + 10] == 'r'&&arithTrig[i + 11] == 'e'&&arithTrig[i + 12] == 's'&&arithTrig[i + 13] == 'p'&&arithTrig[i + 14] == 'o'&&arithTrig[i + 15] == 'n'&&arithTrig[i + 16] == 's'&&arithTrig[i + 17] == 'e'&&arithTrig[i + 20] == '\0' || arithTrig[i] == 'r'&&arithTrig[i + 1] == 'e'&&arithTrig[i + 2] == 's'&&arithTrig[i + 3] == 'p'&&arithTrig[i + 4] == 'o'&&arithTrig[i + 5] == 's'&&arithTrig[i + 6] == 't'&&arithTrig[i + 7] == 'a'&&arithTrig[i + 8] == 'h'&&arithTrig[i + 9] == 'o'&&arithTrig[i + 10] == 'r'&&arithTrig[i + 11] == 'a'&&arithTrig[i + 12] == 's'&&arithTrig[i + 13] == 'a'&&arithTrig[i + 14] == 't'&&arithTrig[i + 15] == 'u'&&arithTrig[i + 16] == 'a'&&arithTrig[i + 17] == 'i'&&arithTrig[i + 18] == 's'&&arithTrig[i + 21] == '\0'){
					arithTrig[0] = '\0'; command = 1;
					printf("\n==> Configuration of actual time response <==\n\n");
					fprintf(fout, "\n==> Configuration of actual time response <==\n\n");
					actualTimeController();
					fprintf(fout, "\n");
					printf("\n");
				}
				if (arithTrig[i] == 'd'&&arithTrig[i + 1] == 'a'&&arithTrig[i + 2] == 'y'&&arithTrig[i + 3] == 'o'&&arithTrig[i + 4] == 'f'&&arithTrig[i + 5] == 'w'&&arithTrig[i + 6] == 'e'&&arithTrig[i + 7] == 'e'&&arithTrig[i + 8] == 'k' &&arithTrig[i + 9] == '(' || arithTrig[i] == 'd'&&arithTrig[i + 1] == 'i'&&arithTrig[i + 2] == 'a'&&arithTrig[i + 3] == 'd'&&arithTrig[i + 4] == 'a'&&arithTrig[i + 5] == 's'&&arithTrig[i + 6] == 'e'&&arithTrig[i + 7] == 'm'&&arithTrig[i + 8] == 'a'&&arithTrig[i + 9] == 'n'&&arithTrig[i + 10] == 'a'&&arithTrig[i + 11] == '('){
					arithTrig[0] = '\0'; command = 1;
					char Day[DIM] = "", Month[DIM] = "", Year[DIM] = "";
					double plusYears = 0;
					int r = 0;
					double day = 0, day1 = 0, month = 0, month1 = 0, year = 0, year1 = 0;
					if (arithTrig[i + 9] == '(' || arithTrig[i + 9] == '[' || arithTrig[i + 9] == '{'){
						i = i + 10;
					}
					if (arithTrig[i + 11] == '(' || arithTrig[i + 11] == '[' || arithTrig[i + 11] == '{'){
						i = i + 12;
					}
					int p = 0, countR = 0, countL = 0;
					for (p = i; arithTrig[p] != '\0'; p++){
						if (arithTrig[p] == '(' || arithTrig[p] == '[' || arithTrig[p] == '{'){
							countL++;
						}
						if (arithTrig[p] == ')' || arithTrig[p] == ']' || arithTrig[p] == '}'){
							countR++;
						}
					}
					int limit = p - 3;
					countR--;
					while (arithTrig[i] != ')'&&arithTrig[i] != ']'&&arithTrig[i] != '}'&&arithTrig[i] != '\0' || countR > 0){
						if (arithTrig[i] == 'd'&&day == 0){
							r = 0;
							i++;
							while (arithTrig[i] != 'y'&&arithTrig[i] != 'm'&&arithTrig[i] != 'a'&&i < limit&&arithTrig[i] != '\0'&&arithTrig[i] != '-'){
								if (arithTrig[i] == '(' || arithTrig[i] == '[' || arithTrig[i] == '{'){
									countL--;
								}
								if (arithTrig[i] == ')' || arithTrig[i] == ']' || arithTrig[i] == '}'){
									countR--;
								}
								Day[r] = arithTrig[i];
								r++; i++;
							}
							if (arithTrig[i] == '-'){
								Day[r] = '+'; Day[r + 1] = '0'; Day[r + 2] = '\0';
								day = initialProcessor(Day, 0);
								r = 0;
								i++;
								char Day[DIM] = "";
								while (arithTrig[i] != 'y'&&arithTrig[i] != 'm'&&arithTrig[i] != 'a'&&i < limit&&arithTrig[i] != '\0'){
									Day[r] = arithTrig[i];
									r++; i++;
								}
								Day[r] = '+'; Day[r + 1] = '0'; Day[r + 2] = '\0';
								day1 = initialProcessor(Day, 0);
							}
							else{
								Day[r] = '+'; Day[r + 1] = '0'; Day[r + 2] = '\0';
								day = initialProcessor(Day, 0);
							}
						}

						if (arithTrig[i] == 'm'&&month == 0){
							r = 0;
							i++;
							while (arithTrig[i] != 'y'&&arithTrig[i] != 'd'&&arithTrig[i] != 'a'&&i < limit&&arithTrig[i] != '\0'&&arithTrig[i] != '-'){
								if (arithTrig[i] == '(' || arithTrig[i] == '[' || arithTrig[i] == '{'){
									countL--;
								}
								if (arithTrig[i] == ')' || arithTrig[i] == ']' || arithTrig[i] == '}'){
									countR--;
								}
								Month[r] = arithTrig[i];
								r++; i++;
							}
							if (arithTrig[i] == '-'){
								Month[r] = '+'; Month[r + 1] = '0'; Month[r + 2] = '\0';
								month = initialProcessor(Month, 0);
								r = 0;
								i++;
								char Month[DIM] = "";
								while (arithTrig[i] != 'y'&&arithTrig[i] != 'd'&&arithTrig[i] != 'a'&&i < limit&&arithTrig[i] != '\0'){
									Month[r] = arithTrig[i];
									r++; i++;
								}
								Month[r] = '+'; Month[r + 1] = '0'; Month[r + 2] = '\0';
								month1 = initialProcessor(Month, 0);
							}
							else{
								Month[r] = '+'; Month[r + 1] = '0'; Month[r + 2] = '\0';
								month = initialProcessor(Month, 0);
							}
						}
						if ((arithTrig[i] == 'y' || arithTrig[i] == 'a') && year == 0){
							r = 0;
							i++;
							while (arithTrig[i] != 'm'&&arithTrig[i] != 'd'&&i < limit&&arithTrig[i] != '\0'&&arithTrig[i] != '-'){
								if (arithTrig[i] == '(' || arithTrig[i] == '[' || arithTrig[i] == '{'){
									countL--;
								}
								if (arithTrig[i] == ')' || arithTrig[i] == ']' || arithTrig[i] == '}'){
									countR--;
								}
								Year[r] = arithTrig[i];
								r++; i++;
							}
							if (arithTrig[i] == '-'){
								Year[r] = '+'; Year[r + 1] = '0'; Year[r + 2] = '\0';
								year = initialProcessor(Year, 0);
								r = 0;
								i++;
								char Year[DIM] = "";
								while (arithTrig[i] != 'm'&&arithTrig[i] != 'd'&&i < limit&&arithTrig[i] != '\0'){
									Year[r] = arithTrig[i];
									r++; i++;
								}
								Year[r] = '+'; Year[r + 1] = '0'; Year[r + 2] = '\0';
								year1 = initialProcessor(Year, 0);

							}
							else{
								Year[r] = '+'; Year[r + 1] = '0'; Year[r + 2] = '\0';
								year = initialProcessor(Year, 0);
							}
						}
						if (arithTrig[i] != 'd'&&arithTrig[i] != 'm'&&arithTrig[i] != 'y'&&arithTrig[i] != 'a'){
							i++;
						}
					}

					if (day1 == 0){
						if (month > 12){
							plusYears = qu(month, 12);
							year = year + plusYears;
							month = qu(re(month, 12), 1);
						}
						if (month == 0){
							month = 12;
							year--;
						}
						if (((qu(re(year, 4), 1) == 0 && qu(re(year, 100), 1) != 0) || qu(re(year, 400), 1) == 0) && month > 2){
							day++;
						}


						while (day > 4000){
							if (day >= 365 && (qu(re(year, 4), 1) != 0 || qu(re(year, 100), 1) == 0 && qu(re(year, 400), 1) != 0)){
								year++;
								day = day - 365;
							}
							else{
								if (day >= 366 && qu(re(year, 4), 1) == 0 && qu(re(year, 100), 1) != 0 || day >= 366 && qu(re(year, 400), 1) == 0){
									year++;
									day = day - 366;
								}
								else{
									if (day >= 365){
										year++;
										day = day - 365;
									}
								}
							}
						}





						while (day >= 29 && (qu(re(year, 4), 1) == 0 && (qu(re(year, 100), 1) != 0) || qu(re(year, 400), 1) == 0) && month == 2 || day >= 28 && month == 2 && (qu(re(year, 4), 1) != 0 || qu(re(year, 100), 1) == 0 && qu(re(year, 400), 1) != 0) || (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) && day >= 31 || day >= 30 && (month == 4 || month == 6 || month == 9 || month == 11)) {

							if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12){
								day = day - 31;

							}
							else{
								if (month == 2){
									if ((qu(re(year, 4), 1) == 0 && qu(re(year, 100), 1) != 0) || qu(re(year, 400), 1) == 0){
										day = day - 29;

									}
									else{
										day = day - 28;

									}

								}


								else{
									day = day - 30;

								}

							}

							month++;
							if (month > 12){
								year++;
								month = qu(re(month, 12), 1);
							}



						}
					}

					else{
						while (day1 > 4000){
							if (day1 >= 365 && (qu(re(year, 4), 1) != 0 || qu(re(year, 100), 1) == 0 && qu(re(year, 400), 1) != 0)){
								year--;
								day1 = day1 - 365;

							}
							else{
								if (day1 >= 366 && qu(re(year, 4), 1) == 0 && qu(re(year, 100), 1) != 0 || day1 >= 366 && qu(re(year, 400), 1) == 0){
									year--;
									day1 = day1 - 366;
								}
								else{
									if (day1 >= 365){
										year--;
										day1 = day1 - 365;

									}
								}
							}
						}

						month--;
						if (month == 0){
							month = 12;
							year--;
						}
						while (day1 > 0) {

							if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12){
								day1 = day1 - 31;


							}
							else{
								if (month == 2){
									if (qu(re(year, 4), 1) == 0){
										if (qu(re(year, 400), 1) == 0){
											day1 = day1 - 29;
										}
										else{
											if (qu(re(year, 100), 1) == 0){
												day1 = day1 - 28;
											}
											else{
												day1 = day1 - 29;
											}
										}
									}
									else{
										day1 = day1 - 28;
									}

								}


								else{
									day1 = day1 - 30;
								}

							}
							month--;
							if (month == 0){
								year--;
								month = 12;
							}

						}
						month++;
						if (month == 13){
							year++;
							month = 1;
						}

						day = day - day1;


						while (day >= 29 && ((qu(re(year, 4), 1) == 0 && qu(re(year, 100), 1) != 0) || qu(re(year, 400), 1) == 0) && month == 2 || day >= 28 && month == 2 && (qu(re(year, 4), 1) != 0 || qu(re(year, 100), 1) == 0 && qu(re(year, 400), 1) != 0) || (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) && day >= 31 || day >= 30 && (month == 4 || month == 6 || month == 9 || month == 11)) {

							if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12){
								day = day - 31;

							}
							else{
								if (month == 2){
									if ((qu(re(year, 4), 1) == 0 && qu(re(year, 100), 1) != 0) || qu(re(year, 400), 1) == 0){
										day = day - 29;

									}
									else{
										day = day - 28;

									}

								}


								else{
									day = day - 30;

								}

							}

							month++;
							if (month > 12){
								year++;
								month = qu(re(month, 12), 1);
							}


						}

						year = year - year1;

						month = month - month1;

						if (month > 12){
							plusYears = qu(month, 12);
							year = year + plusYears;
							month = qu(re(month, 12), 1);
							if (month == 0){
								month = 12;
							}
						}
						else{
							if (month <= 0){
								plusYears = qu((month - 12), 12);
								year = year + plusYears;
								month = 12 - abs(qu(re(month, 12), 1));
								if (month == 0){
									month = 12;
									year++;
								}
							}
						}







					}
					char tim[DIM] = "";
					sprintf(tim, "%G", day);
					int daY = initialProcessor(tim, 0);
					sprintf(tim, "%G", month);
					int montH = initialProcessor(tim, 0);
					sprintf(tim, "%G", year);
					int yeaR = initialProcessor(tim, 0);

					if (daY < 1 || daY>31){
						printf("\nError entering the day.\n ==> In a month, the days only vary between 1 and 31.\n\n");
						fprintf(fout, "\nError entering the day.\n ==> In a month, the days only vary between 1 and 31.\n\n");
					}
					else{
						if (montH < 1 || montH>12){
							printf("\nError entering the month.\n ==> In a year, the months only vary between 1 and 12.\n\n");
							fprintf(fout, "\nError entering the month.\n == > In a year, the months only vary between 1 and 12.\n\n");
						}
						else{
							if (yeaR < 1760){
								printf("\nError entering the year.\n ==> The minimal year to evaluate is 1760.\n\n");
								fprintf(fout, "\nError entering the year.\n ==> The minimal year to evaluate is 1760.\n\n");
							}
							else{
								if ((montH == 2 || montH == 4 || montH == 6 || montH == 9 || montH == 11) && daY == 31){
									printf("\nError entering the month.\n ==> The entered month doesn't have the duration of 31 days.\n\n");
									fprintf(fout, "\nError entering the month.\n == > The entered month doesn't have the duration of 31 days.\n\n");
								}
								else{
									if (montH == 2 && daY > 29){
										printf("\nError entering the day.\n ==> The month of February has a maximal duration of 29 days.\n\n");
										fprintf(fout, "\nError entering the day.\n ==> The month of February has a maximal duration of 29 days.\n\n");
									}
									else{
										if ((montH == 2 && daY == 29) && (yeaR % 4 != 0 && yeaR % 400 != 0)){
											printf("\nError entering the day.\n ==> The month of February in %d has a maximal duration of 28 days.\n\n", yeaR);
											fprintf(fout, "\nError entering the day.\n ==> The month of February in %d has a maximal duration of 28 days.\n\n", yeaR);
										}
										else{
											printf("y%dm%dd%d=", yeaR, montH, daY);
											int h = 0;
											h = ((int)(daY + floor((((montH + 1) * 26) / 10)*1.000) + yeaR + floor((yeaR / 4)*1.0000) + 6 * floor((yeaR / 100)*1.0000) + floor((yeaR / 400)*1.0000)) % 7);
											if (montH < 3){
												if (montH == 1){
													montH = 13;
												}
												if (montH == 2){
													montH = 14;
												}
												yeaR--;
												h = ((int)(daY + floor((((montH + 1) * 26) / 10)*1.000) + (yeaR)+floor(((yeaR) / 4)*1.0000) + 6 * floor(((yeaR) / 100)*1.0000) + floor(((yeaR) / 400)*1.0000)) % 7);

											}

											if (h == 1){
												printf("Sunday\n\n");
												fprintf(fout, "Sunday\n\n");
											}
											if (h == 2){
												printf("Monday\n\n");
												fprintf(fout, "Monday\n\n");
											}
											if (h == 3){
												printf("Tuesday\n\n");
												fprintf(fout, "Tuesday\n\n");
											}
											if (h == 4){
												printf("Wednesday\n\n");
												fprintf(fout, "Wednesday\n\n");
											}
											if (h == 5){
												printf("Thursday\n\n");
												fprintf(fout, "Thursday\n\n");
											}
											if (h == 6){
												printf("Friday\n\n");
												fprintf(fout, "Friday\n\n");
											}
											if (h == 0){
												printf("Saturday\n\n");
												fprintf(fout, "Saturday\n\n");
											}

										}
									}
								}
							}
						}
					}
				}

				if (arithTrig[i] == 'p'&&arithTrig[i + 1] == 'r'&&arithTrig[i + 2] == 'e'&&arithTrig[i + 3] == 'd'&&arithTrig[i + 4] == 'e'&&arithTrig[i + 5] == 'f'&&arithTrig[i + 6] == 'i'&&arithTrig[i + 7] == 'n'&&arithTrig[i + 8] == 'e'&&arithTrig[i + 9] == 't'&&arithTrig[i + 10] == 'x'&&arithTrig[i + 11] == 't'&&arithTrig[i + 14] == '\0' || arithTrig[i] == 'p'&&arithTrig[i + 1] == 'r'&&arithTrig[i + 2] == 'e'&&arithTrig[i + 3] == 'd'&&arithTrig[i + 4] == 'e'&&arithTrig[i + 5] == 'f'&&arithTrig[i + 6] == 'i'&&arithTrig[i + 7] == 'n'&&arithTrig[i + 8] == 'i'&&arithTrig[i + 9] == 'r'&&arithTrig[i + 10] == 't'&&arithTrig[i + 11] == 'x'&&arithTrig[i + 12] == 't'&&arithTrig[i + 15] == '\0'){
					arithTrig[0] = '\0'; command = 1;
					printf("\n==> Drag to here the file to predefine and press the button \"Enter\" <==\n");
					fprintf(fout, "\n==> Drag to here the file to predefine and press the button \"Enter\" <==\n");
					char predTxt[DIM] = "";
					int y = 0;
					gets(predTxt);
					if (predTxt[y] == '"'){
						while (predTxt[y + 1] != '"'&&predTxt[y + 1] != '\0'){
							predTxt[y] = predTxt[y + 1];
							y++;
						}
						predTxt[y] = '\0';
					}
					FILE *pred = NULL;
					while (pred == NULL){
						pred = fopen("predefinedTxt.txt", "w");
					}
					fprintf(pred, "%s", predTxt);
					fclose(pred);
					printf("\n");
					fprintf(fout, "\n");
				}

				if ((arithTrig[i] == 's'&&arithTrig[i + 1] == 'o'&&arithTrig[i + 2] == 'l'&&arithTrig[i + 3] == 'v'&&arithTrig[i + 4] == 'e'&&arithTrig[i + 5] == 't'&&arithTrig[i + 6] == 'x'&&arithTrig[i + 7] == 't' && (arithTrig[i + 10] == '\0' || arithTrig[i + 8] == '(')) || (arithTrig[i] == 'r'&&arithTrig[i + 1] == 'e'&&arithTrig[i + 2] == 's'&&arithTrig[i + 3] == 'o'&&arithTrig[i + 4] == 'l'&&arithTrig[i + 5] == 'v'&&arithTrig[i + 6] == 'e'&&arithTrig[i + 7] == 'r'&&arithTrig[i + 8] == 't'&&arithTrig[i + 9] == 'x'&&arithTrig[i + 10] == 't' && (arithTrig[i + 13] == '\0' || arithTrig[i + 11] == '('))){
					arithTrig[0] = '\0'; command = 1;
					FILE *readPred = NULL;
					char readPath[DIM] = "";
					if (arithTrig[i + 8] != '('&&arithTrig[i + 11] != '('){
						readPred = fopen("predefinedTxt.txt", "r");
						if (readPred == NULL){
							printf("\n==> The file was not yet predefined! <==\n\n");
							fprintf(fout, "\n==> The file was not yet predefined! <==\n\n");
						}
						else{
							fgets(readPath, DIM, readPred);
							fclose(readPred);
							processTxt(readPath, rf);
							printf("\n==> Close the file with the answers to continue. <==\n\n");
							fprintf(fout, "\n==> Close the file with the answers to continue. <==\n\n");
							openTxt();
						}
					}
					else{
						char paName[DIM] = "";
						int x = 0, y = 0;
						if (arithTrig[i + 8] == '(' || arithTrig[i + 11] == '('){
							if (arithTrig[i + 8] == '('){
								y = i + 9;
							}
							if (arithTrig[i + 11] == '('){
								y = i + 12;
							}
							for (x = 0; arithTrig[y] != ')'&&arithTrig[y] != '\0'&&arithTrig[y] != '+'; x++){
								paName[x] = arithTrig[y];
								y++;
							}
							paName[x] = '\0';
							pathNameToPath(paName);
							if (strlen(pathNAme) != 0){
								processTxt(pathNAme, rf);
								printf("\n==> Close the file with the answers to continue. <==\n\n");
								fprintf(fout, "\n==> Close the file with the answers to continue. <==\n\n");
								openTxt();
							}

						}
					}
				}

				if (arithTrig[i] == 'c'&&arithTrig[i + 1] == 'a'&&arithTrig[i + 2] == 'l'&&arithTrig[i + 3] == 'e'&&arithTrig[i + 4] == 'n'&&arithTrig[i + 5] == 'd'&&arithTrig[i + 6] == 'a'&&arithTrig[i + 7] == 'r' && (arithTrig[i + 8] == '(' || arithTrig[i + 8] == '+') || arithTrig[i] == 'c'&&arithTrig[i + 1] == 'a'&&arithTrig[i + 2] == 'l'&&arithTrig[i + 3] == 'e'&&arithTrig[i + 4] == 'n'&&arithTrig[i + 5] == 'd'&&arithTrig[i + 6] == 'a'&&arithTrig[i + 7] == 'r'&&arithTrig[i + 8] == 'i'&&arithTrig[i + 9] == 'o' && (arithTrig[i + 10] == '(' || arithTrig[i + 10] == '+')) {
					FILE *cal = NULL;
					char ye[100], calendar[DIM];
					int k = 0;
					int p = 0, countR = 0, countL = 0;
					for (p = 0; arithTrig[p] != '\0'; p++){
						if (arithTrig[p] == '(' || arithTrig[p] == '[' || arithTrig[p] == '{'){
							countL++;
						}
						if (arithTrig[p] == ')' || arithTrig[p] == ']' || arithTrig[p] == '}'){
							countR++;
						}
					}
					if (countR == countL){
						if (arithTrig[i + 8] == '(' || arithTrig[i + 8] == '[' || arithTrig[i + 8] == '{'){
							i = i + 9;
							for (p = i; arithTrig[p] != '\0'; p++);
							int limit = p - 3;
							if (arithTrig[limit] != ')'){
								limit++;
							}
							k = 0;
							countR = 0; countL = 0;
							while (i < limit){
								if (arithTrig[i] == '(' || arithTrig[i] == '[' || arithTrig[i] == '{'){
									countL++;
								}
								if (arithTrig[i] == ')' || arithTrig[i] == ']' || arithTrig[i] == '}'){
									countR++;
								}
								ye[k] = arithTrig[i];
								k++; i++;
							}
							ye[k] = '\0';
							if (countR == countL){
								year = initialProcessor(ye, 0);
							}

						}
						else{
							if (arithTrig[i + 10] == '(' || arithTrig[i + 10] == '[' || arithTrig[i + 10] == '{'){
								i = i + 11;
								for (p = i; arithTrig[p] != '\0'; p++);

								int limit = p - 3;
								if (arithTrig[limit] != ')'){
									limit++;
								}
								k = 0;
								countR = 0; countL = 0;
								while (i < limit){
									if (arithTrig[i] == '(' || arithTrig[i] == '[' || arithTrig[i] == '{'){
										countL++;
									}
									if (arithTrig[i] == ')' || arithTrig[i] == ']' || arithTrig[i] == '}'){
										countR++;
									}
									ye[k] = arithTrig[i];
									k++; i++;
								}
								ye[k] = '\0';
								if (countR == countL){
									year = initialProcessor(ye, 0);
								}


							}
							else{
								time_t hour;
								time(&hour);
								char *tim;
								tim = ctime(&hour);
								tim[24] = '\0';
								char yea[7] = { tim[20], tim[21], tim[22], tim[23], '.', '0', '\0' };
								year = convertToNumber(yea);
							}
						}
						arithTrig[0] = '\0'; command = 1;

						if (year > 1759){
							Calendar("calendar.txt", year);
							while (cal == NULL){
								cal = fopen("calendar.txt", "r");
							}
							for (s = 0; (calendar[s] = fgetc(cal)) != EOF; s++);
							fclose(cal);
							calendar[s] = '\0';
							cal = fopen(path, "a+");
							fprintf(cal, "\n");
							fprintf(cal, "%s\n\n", calendar);
							fclose(cal);
							for (s = 0; calendar[s] != '\0'; s++){
								if (calendar[s] == 's'&&calendar[s + 3] == 'd'&&calendar[s + 4] == 'o'){
									calendar[s + 1] = 'a';
								}
								if (calendar[s] == 'm'&&calendar[s + 1] == 'a'&&calendar[s + 2] == 'r'&&calendar[s + 4] == 'o'){
									calendar[s + 3] = 'c';
								}
							}
							calendar[s] = '\0';
							printf("\n");
							printf("%s\n\n", calendar);
							fprintf(fout, "\n");
							fprintf(fout, "%s\n\n", calendar);
						}
						else{
							printf("\n");
							printf("Please enter years after 1759\n\n");
							fprintf(fout, "\n");
							fprintf(fout, "Please enter years after 1759\n\n");
							cal = fopen(path, "a+");
							fprintf(cal, "\n");
							fprintf(cal, "Please enter years after 1759\n\n");
							fclose(cal);
						}
					}
				}
				if (command == 0){
					if (var == 1){
						for (i = 0; arithTrig[i] != '='&&arithTrig[i] != '\0'; i++){
							variable[i] = arithTrig[i];
						}
						variable[i] = '\0';
						g = i + 1;
						for (i = 0; arithTrig[i] != '\0'; i++){
							arithTrig[i] = arithTrig[i + g];
						}
						arithTrig[i] = '\0';
						i = 0;
						int hk = variableValidator(variable);
						if (hk == 1 || v == 1){
							processVariable(revariable);
							if (validVar == 0 && valid == 0){
								//printf("\n==> Your variable was renamed to \"%s\", but you can continue using it with the same name that you chose. <==\n\n", revariable);
								fprintf(fout, "\n==> Your variable was renamed to \"%s\", but you can continue using it with the same name that you chose. <==\n\n", revariable);

							}
						}
						if (hk == 2){
							printf("\n==> Your variable was renamed to \"%s\". <==\n\n", revariable);
							fprintf(fout, "\n==> Your variable was renamed to \"%s\". <==\n\n", revariable);
						}
						if (hk == 0){
							printf("\n==> Invalid variable. Use only latin alphabet letters. <==\n\n");
							fprintf(fout, "\n==> Invalid variable. Use only latin alphabet letters. <==\n\n");
							var = 0;
						}
					}
					char dP[DIM] = "", bP[DIM] = "", oP[DIM] = "", hP[DIM] = "";
					int dp = -1, bp = -1, op = -1, hp = -1;
					while (arithTrig[0] == 'd' &&arithTrig[1] == 'p' || arithTrig[0] == 'b' &&arithTrig[1] == 'p' || arithTrig[0] == 'o' &&arithTrig[1] == 'p' || arithTrig[0] == 'h' &&arithTrig[1] == 'p')  {
						if (arithTrig[0] == 'd' &&arithTrig[1] == 'p'){
							i = 2;
							while (arithTrig[i] != 'd'&&arithTrig[i] != '\0'){
								dP[i - 2] = arithTrig[i];
								i++;
							}
							dP[i - 2] = '\0';
							dp = initialProcessor(dP, result);
							i = i + 2;
							int b = 0;
							for (b = 0; arithTrig[b] != '\0'; b++){
								arithTrig[b] = arithTrig[b + i];
							}
						}
						if (arithTrig[0] == 'b' &&arithTrig[1] == 'p'){
							i = 2;
							while (arithTrig[i] != 'b'&&arithTrig[i] != '\0'){
								bP[i - 2] = arithTrig[i];
								i++;
							}
							bP[i - 2] = '\0';
							bp = initialProcessor(bP, result);
							i = i + 2;
							int b = 0;
							for (b = 0; arithTrig[b] != '\0'; b++){
								arithTrig[b] = arithTrig[b + i];
							}
						}
						if (arithTrig[0] == 'o' &&arithTrig[1] == 'p'){
							i = 2;
							while (arithTrig[i] != 'o'&&arithTrig[i] != '\0'){
								oP[i - 2] = arithTrig[i];
								i++;
							}
							oP[i - 2] = '\0';
							op = initialProcessor(oP, result);
							i = i + 2;
							int b = 0;
							for (b = 0; arithTrig[b] != '\0'; b++){
								arithTrig[b] = arithTrig[b + i];
							}
						}
						if (arithTrig[0] == 'h' &&arithTrig[1] == 'p'){
							i = 2;
							while (arithTrig[i] != 'h'&&arithTrig[i] != '\0'){
								hP[i - 2] = arithTrig[i];
								i++;
							}
							hP[i - 2] = '\0';
							hp = initialProcessor(hP, result);
							i = i + 2;
							int b = 0;
							for (b = 0; arithTrig[b] != '\0'; b++){
								arithTrig[b] = arithTrig[b + i];
							}
						}
					}

					for (i = 0; arithTrig[i] != '\0'; i++){
						if (arithTrig[i] == 'a'&&arithTrig[i + 1] == 'n'&&arithTrig[i + 2] == 's'){
							arithTrig[i] = 'r'; arithTrig[i + 1] = 'e'; arithTrig[i + 2] = 's';
							i = i + 3;
						}
					}

					s = 0;
					if (verify == 1){
						res = arithTrig[0];

						if (res == '+' || res == '-' || res == '/' || res == '*' || res == 'x' || res == '^'){
							for (i = 0; arithTrig[i] != '\0'; i++){
								arithTrig[i] = arithTrig[i + 1];
							}
						}
						for (i = 0; arithTrig[i] != '\0'; i++){
							if (arithTrig[i] == 'x'){
								arithTrig[i] = '*';
							}

						}
						arithTrig[i] = '\0';
						synTest = 0;
						manageExpression(arithTrig, result1, verify);
						for (i = 0; expressionF[i] != '\0'; i++){
							arithTrig[i] = expressionF[i];
						}
						arithTrig[i] = '\0';
						synTest = 0;
						verify = dataVerifier(arithTrig, result1, 1, verify);
					}
					for (s = 0; arithTrig[s] != '\0'; s++){
						if ((arithTrig[s] == '+' || arithTrig[s] == '-' || arithTrig[s] == '*' || arithTrig[s] == '/' || arithTrig[s] == '^') && (arithTrig[s + 1] == '+' || arithTrig[s + 1] == '-'&&arithTrig[s - 2] != '1'&&arithTrig[s - 1] != '0' || arithTrig[s + 1] == '*' || arithTrig[s + 1] == '/' || arithTrig[s + 1] == '^' || arithTrig[s + 1] == '!')){
							verify = 0;
						}
					}
					if (arithTrig[s - 1] == '+' || arithTrig[s - 1] == '-' || arithTrig[s - 1] == '*' || arithTrig[s - 1] == '/' || arithTrig[s - 1] == '^'){
						verify = 0;
					}

					int kg = 0, kc = 0;
					for (i = 0; arithTrig[i] != '\0'; i++){
						if (arithTrig[i] == '(' || arithTrig[i] == '[' || arithTrig[i] == '{'){
							kg++;
						}
						if (arithTrig[i] == ')' || arithTrig[i] == ']' || arithTrig[i] == '}'){
							kc++;
						}
					}
					if (kg != kc){
						printf("\nError in parentheses. \n ==> The number of left and right parenthesis entered must be equal.\n ==> Enter \"[\" or \"{\" is the same as \"(\" and \"]\" or \"}\" is the same as \")\".\n ==> The expression that you entered has %d left parenthesis and %d right parenthesis.\n\n\n", kg, kc);
						fprintf(fout, "\nError in parentheses. \n ==> The number of left and right parenthesis entered must be equal.\n ==> Enter \"[\" or \"{\" is the same as \"(\" and \"]\" or \"}\" is the same as \")\".\n ==> The expression that you entered has %d left parenthesis and %d right parenthesis.\n\n\n", kg, kc);
						arithTrig[0] = '\0';
					}


					fclose(fout);
					if (arithTrig[0] != '\0'){

						Clock(0);
					}
					if (continu == 1){
						flushall();
						if (cleanhistory == 0){
							if (arithTrig[0] != '\0'&&verify == 1){
								system("title Advanced Trigonometry Calculator v1.8.4                                                            ==) Calculating... (==              ");
								result = initialProcessor(arithTrig, result);
							}
						}
						if (arithTrig[0] != '\0'&&txt != 1){
							if (res == '+'){
								sum(result1, result2, resultR, resultI);
							}
							if (res == '-'){
								subtraction(result1, result2, resultR, resultI);
							}
							if (res == '/'){
								division(result1, result2, resultR, resultI);
							}
							if (res == '*' || res == 'x'){
								multiplication(result1, result2, resultR, resultI);
							}
							if (res == '^'){
								exponentiation(result1, result2, resultR, resultI, 1);
							}
							if (verify == 1){
								round_complex();
								result1 = resultR;
								result2 = resultI;
								resultFI = result2;

								if (var == 1){
									variableController(revariable, result);
								}
								if (dp == -1){
									ans[rf] = result1;
									ansI[rf] = result2;

									if (result1 > 0 && result2 > 0){
										printf("#%d=%G+%Gi\n", rf, result1, result2);
									}
									else{
										if (result1 > 0 && result2 < 0){
											printf("#%d=%G%Gi\n", rf, result1, result2);
										}
										else{
											if (result1 < 0 && result2 > 0){
												printf("#%d=%G+%Gi\n", rf, result1, result2);
											}
											else{
												if (result1 < 0 && result2 < 0){
													printf("#%d=%G%Gi\n", rf, result1, result2);
												}
												else{
													if (result1 == 0 && result2 == 0){
														printf("#%d=%G\n", rf, result1);
													}
													else{
														if (result1 == 0 && result2 != 0){
															printf("#%d=%Gi\n", rf, result2);
														}
														else{
															if (result1 != 0 && result2 == 0){
																printf("#%d=%G\n", rf, result1);
															}
															else{
																printf("#%d=%G+%Gi\n", rf, result1, result2);
															}
														}
													}
												}
											}
										}
									}


									if (fout != NULL){
										fclose(fout);
									}
									fout = NULL;
									while (fout == NULL){
										fout = fopen(path, "a+");
									}
									if (result1 > 0 && result2 > 0){
										fprintf(fout, "#%d=%G+%Gi\n", rf, result1, result2);
									}
									else{
										if (result1 > 0 && result2 < 0){
											fprintf(fout, "#%d=%G%Gi\n", rf, result1, result2);
										}
										else{
											if (result1 < 0 && result2 > 0){
												fprintf(fout, "#%d=%G+%Gi\n", rf, result1, result2);
											}
											else{
												if (result1 < 0 && result2 < 0){
													fprintf(fout, "#%d=%G%Gi\n", rf, result1, result2);
												}
												else{
													if (result1 == 0 && result2 == 0){
														fprintf(fout, "#%d=%G\n", rf, result1);
													}
													else{
														if (result1 == 0 && result2 != 0){
															fprintf(fout, "#%d=%Gi\n", rf, result2);
														}
														else{
															if (result1 != 0 && result2 == 0){
																fprintf(fout, "#%d=%G\n", rf, result1);
															}
															else{
																fprintf(fout, "#%d=%G+%Gi\n", rf, result1, result2);
															}
														}
													}
												}
											}
										}
									}

									fclose(fout);
									rf++;
								}
								if (dp > -1){
									ans[rf] = result;
									ansI[rf] = resultFI;

									if (result1 > 0 && result2 > 0){
										sprintf(dP, "#%d=%%.%df+%%.%dfi\n", rf, dp, dp);
										printf(dP, result1, result2);
									}
									if (result1 > 0 && result2 < 0){
										sprintf(dP, "#%d=%%.%df%%.%dfi\n", rf, dp, dp);
										printf(dP, result1, result2);
									}
									if (result1 < 0 && result2 > 0){
										sprintf(dP, "#%d = %%.%df+%%.%dfi\n", rf, dp, dp);
										printf(dP, result1, result2);
									}
									if (result1 < 0 && result2 < 0){
										sprintf(dP, "#%d=%%.%df%%.%dfi\n", rf, dp, dp);
										printf(dP, result1, result2);
									}
									if (result1 == 0 && result2 == 0){
										sprintf(dP, "#%d=%%.%df\n", rf, dp);
										printf(dP, result1);
									}

									if (result1 == 0 && result2 != 0){
										sprintf(dP, "#%d=%%.%dfi\n", rf, dp);
										printf(dP, result2);
									}
									if (result1 != 0 && result2 == 0){
										sprintf(dP, "#%d=%%.%df\n", rf, dp);
										printf(dP, result1);
									}
									if (fout != NULL){
										fclose(fout);
									}
									fout = NULL;
									while (fout == NULL){
										fout = fopen(path, "a+");
									}
									fprintf(fout, dP, result);
									fclose(fout);
									rf++;
								}
								open = fopen("numSystems.txt", "r");
								char numSys[DIM] = "";
								int numeriSys = 0;
								if (open != NULL || bp != -1 || op != -1 || hp != -1){
									if (open != NULL){
										fgets(numSys, 10, open);
										numeriSys = atoi(numSys);
										fclose(open);
									}
									if (numeriSys == 1 || bp != -1 || op != -1 || hp != -1){
										char syst[DIM] = "";
										sprintf(syst, "%G", result);
										if (syst[0] == '1'&&syst[1] == '.'&&syst[2] == '#'&&syst[3] == 'I'&&syst[4] == 'N'&&syst[5] == 'F'){
											puts("In binary=11111111111111111111111111111111.#INF");
											puts("In octal=77777777777777777777777777777777.#INF");
											puts("In hexadecimal=FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF.#INF");
											open = fopen(path, "a+");
											fputs("In binary=11111111111111111111111111111111.#INF\n", open);
											fputs("In octal=77777777777777777777777777777777.#INF\n", open);
											fputs("In hexadecimal=FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF.#INF\n", open);
											fclose(open);
										}
										else{
											if (syst[0] == '-'&&syst[1] == '1'&&syst[2] == '.'&&syst[3] == '#'&&syst[4] == 'I'&&syst[5] == 'N'&&syst[6] == 'F'){
												puts("In binary=-11111111111111111111111111111111.#INF");
												puts("In octal=-77777777777777777777777777777777.#INF");
												puts("In hexadecimal=-FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF.#INF");
												open = fopen(path, "a+");
												fputs("In binary=-11111111111111111111111111111111.#INF\n", open);
												fputs("In octal=-77777777777777777777777777777777.#INF\n", open);
												fputs("In hexadecimal=-FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF.#INF\n", open);
												fclose(open);
											}
											else{
												char Value[DIM] = "";
												sprintf(Value, "%G", result);
												for (int v = 0; Value[v]; v++){
													if (Value[v] == '-')  {
														Value[v] = '_';
													}
													if (Value[v] == '+')  {
														Value[v] = '0';
													}
												}
												result = initialProcessor(Value, 0);
												if (result1 != 0 || result1 == 0 && result2 == 0){
													open = fopen(path, "a+");
													fputs("\nReal part:\n", open);
													puts("\nReal part:\n");
													fclose(open);
													decimalToBinary(result1, path, bp);
													decimalToOctal(result1, path, op);
													decimalToHexadecimal(result1, path, hp);
												}
												if (result2 != 0){
													open = fopen(path, "a+");
													fputs("\nImaginary part:\n", open);
													puts("\nImaginary part:\n");
													fclose(open);
													decimalToBinary(result2, path, bp);
													decimalToOctal(result2, path, op);
													decimalToHexadecimal(result2, path, hp);
												}
											}
										}
									}
								}
								open = fopen("siPrefixes.txt", "r");
								char siPref[DIM] = "";
								int niPrefix = 0;
								if (open != NULL){
									fgets(siPref, 10, open);
									fclose(open);
									niPrefix = atoi(siPref);
									if (niPrefix == 1){
										if (result1 != 0 || result1 == 0 && result2 == 0){
											open = fopen(path, "a+");
											printf("\nReal part");
											fprintf(open, "\nReal part");
											fclose(open);
											prefDet(result1, path);
										}
										if (result2 != 0){
											open = fopen(path, "a+");
											printf("\nImaginary part");
											fprintf(open, "\nImaginary part");
											fclose(open);
											prefDet(result2, path);
										}
									}
								}
								open = fopen("actualTime.txt", "r");
								char actualTime[DIM] = "";
								int nactualTime = 0;
								if (open != NULL){
									fgets(actualTime, 10, open);
									fclose(open);
									nactualTime = atoi(actualTime);
									if (nactualTime == 1){
										puts("");
										Clock(1);
									}
								}
								printf("\n");
								FILE *fout = NULL;
								while (fout == NULL){
									fout = fopen(path, "a+");
								}
								fputs("\n", fout);
								fclose(fout);
								system("title Advanced Trigonometry Calculator v1.8.4                                                      ==) Calculated, you can enter more data (==              ");
							}
							else{
								printf("\nError in syntax.\n\n");
								FILE *fout = NULL;
								while (fout == NULL){
									fout = fopen(path, "a+");
								}
								fprintf(fout, "\nError in syntax.\n\n");
								fclose(fout);
								system("title Advanced Trigonometry Calculator v1.8.4                                                             ==) Enter data (==              ");
							}
						}
					}
				}
			}
			flushall();
			if (continu != 1){
				fclose(fout);
			}
		} while (continu == 1);
	}
	return 0;
}

int about(){
	system("title Advanced Trigonometry Calculator v1.8.4");
	HWND a;
	a = GetConsoleWindow();
	MoveWindow(a, 0, 0, 1000, 1000, FALSE);
	system("MODE con cols=84 lines=40");
	flushall();
	char exit[DIM] = "";
	int i, continu = 1;
	puts("\n\n\n\n");
	printf("                   %c%c%c  %c%c%c%c  %c   %c  %c%c%c  %c   %c  %c%c%c  %c%c%c%c%c %c%c%c%c\n", 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177);
	printf("                  %c   %c %c   %c %c   %c %c   %c %c%c  %c %c   %c %c     %c   %c\n", 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177);
	printf("                  %c%c%c%c%c %c   %c %c   %c %c%c%c%c%c %c %c %c %c     %c%c%c   %c   %c\n", 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177);
	printf("                  %c   %c %c   %c  %c %c  %c   %c %c  %c%c %c   %c %c     %c   %c\n", 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177);
	printf("                  %c   %c %c%c%c%c    %c   %c   %c %c   %c  %c%c%c  %c%c%c%c%c %c%c%c%c\n", 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177);
	puts("");
	printf("      %c%c%c%c%c %c%c%c%c  %c%c%c%c%c  %c%c%c%c  %c%c%c  %c   %c  %c%c%c  %c   %c %c%c%c%c%c %c%c%c%c%c %c%c%c%c  %c   %c\n", 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177);
	printf("        %c   %c   %c   %c   %c     %c   %c %c%c  %c %c   %c %c%c %c%c %c       %c   %c   %c %c   %c\n", 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177);
	printf("        %c   %c%c%c%c    %c   %c %c%c%c %c   %c %c %c %c %c   %c %c %c %c %c%c%c     %c   %c%c%c%c   %c %c\n", 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177);
	printf("        %c   %c   %c   %c   %c   %c %c   %c %c  %c%c %c   %c %c   %c %c       %c   %c   %c   %c\n", 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177);
	printf("        %c   %c   %c %c%c%c%c%c  %c%c%c   %c%c%c  %c   %c  %c%c%c  %c   %c %c%c%c%c%c   %c   %c   %c   %c\n", 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177);
	puts("");
	printf("             %c%c%c   %c%c%c  %c      %c%c%c  %c   %c %c      %c%c%c  %c%c%c%c%c  %c%c%c  %c%c%c%c\n", 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177);
	printf("            %c   %c %c   %c %c     %c   %c %c   %c %c     %c   %c   %c   %c   %c %c   %c\n", 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177);
	printf("            %c     %c%c%c%c%c %c     %c     %c   %c %c     %c%c%c%c%c   %c   %c   %c %c%c%c%c\n", 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177);
	printf("            %c   %c %c   %c %c     %c   %c %c   %c %c     %c   %c   %c   %c   %c %c   %c\n", 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177);
	printf("             %c%c%c  %c   %c %c%c%c%c%c  %c%c%c   %c%c%c  %c%c%c%c%c %c   %c   %c    %c%c%c  %c   %c\n", 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177);
	puts("");
	printf("                                     %c%c    %c%c%c    %c   %c\n", 177, 177, 177, 177, 177, 177, 177);
	printf("                                    %c %c   %c   %c   %c   %c\n", 177, 177, 177, 177, 177, 177);
	printf("                             %c   %c %c  %c    %c%c%c    %c%c%c%c%c\n", 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177);
	printf("                              %c %c     %c   %c   %c       %c\n", 177, 177, 177, 177, 177, 177);
	printf("                               %c      %c %c  %c%c%c  %c     %c\n", 177, 177, 177, 177, 177, 177, 177, 177);

	puts("\n                        by Renato Alexandre dos Santos Freitas\n\n            To know how to use this application please enter \"user guide\"\n\n");
	printf("     PRESS THE BUTTON \"Enter\" TO ACCESS THE ENVIRONMENT-RESOLUTION CALCULATIONS\n\n");
	gets(exit);
	for (i = 0; exit[i] != '\0'; i++){
		if (exit[i] == 'A'){
			exit[i] = 'a';
		}
		if (exit[i] == 'E'&&exit[i + 1] == 'N' || exit[i] == 'E'&&exit[i - 1] == 'l' || exit[i] == 'E'&&exit[i - 1] == 'L' || exit[i] == 'E'&&exit[i + 1] == 'n' || exit[i + 1] == 'E'&&exit[i + 1] == 'C' || exit[i] == 'E'&&exit[i + 1] == 'c' || exit[i] == 'E'&&exit[i + 1] == 'C'&&exit[i + 2] == 'H' || exit[i] == 'E'&&exit[i + 1] == 'c'&&exit[i + 2] == 'H' || exit[i] == 'E'&&exit[i + 1] == 'C'&&exit[i + 2] == 'h' || exit[i] == 'E'&&exit[i + 1] == 'x' || exit[i] == 'E'&&exit[i + 1] == 'X'){
			exit[i] = 'e';
		}
		if (exit[i] == 'C'){
			exit[i] = 'c';
		}
		if (exit[i] == 'R'){
			exit[i] = 'r';
		}
		if (exit[i] == 'F'){
			exit[i] = 'f';
		}
		if (exit[i] == 'H'){
			exit[i] = 'h';
		}
		if (exit[i] == 'X'&&exit[i + 1] == 'i' || exit[i] == 'X'&&exit[i + 1] == 'I'){
			exit[i] = 'x';
		}
		if (exit[i] == 'I'){
			exit[i] = 'i';
		}
		if (exit[i] == 'T'){
			exit[i] = 't';
		}
		if (exit[i] == 'S'){
			exit[i] = 's';
		}
	}
	for (i = 0; exit[i] != '\0'; i++){
		if (exit[i] == 's'&&exit[i + 1] == 'o'&&exit[i + 2] == 'b'&&exit[i + 3] == 'r'&&exit[i + 4] == 'e' || exit[i] == 'a'&&exit[i + 1] == 'b'&&exit[i + 2] == 'o'&&exit[i + 3] == 'u'&&exit[i + 4] == 't'){
			about2();
		}
		if (exit[i] == 'u'&&exit[i + 1] == 's'&&exit[i + 2] == 'e'&&exit[i + 3] == 'r'&&exit[i + 4] == ' '&&exit[i + 5] == 'g'&&exit[i + 6] == 'u'&&exit[i + 7] == 'i'&&exit[i + 8] == 'd'&&exit[i + 9] == 'e' || exit[i] == 'm'&&exit[i + 1] == 'a' && exit[i + 2] == 'n' || exit[i + 3] == 'u'&&exit[i + 4] == 'a'&&exit[i + 5] == 'l'){
			ShellExecute(NULL, _T("open"), _T("Advanced Trigonometry Calculator - User Guide.pdf"), NULL, NULL, SW_SHOW);
		}
	}

	if (continu == 1){
		cls();
	}
	if (continu == 1){
		int Window = 3, Dimensions = 2;
		applySettings(Window);
		applySettings(Dimensions);
		system("title Advanced Trigonometry Calculator v1.8.4                                                             ==) Enter data (==              ");
	}
	return continu;
}

void about2(){
	system("title Advanced Trigonometry Calculator v1.8.4");
	system("MODE con cols=150 lines=270");
	cls();
	FILE *open = NULL;
	char about[15000] = "";
	int i;
	while (open == NULL){
		open = fopen("About execution of application.txt", "a+");
	}
	for (i = 0; (about[i] = fgetc(open)) != EOF; i++){
	}
	about[i] = '\0';
	printf("%s\n\n     PRESS THE BUTTON \"Enter\" TO ACCESS THE ENVIRONMENT-RESOLUTION CALCULATIONS \n\n", about);
	gets(about);
	int Window = 3, Dimensions = 2;
	applySettings(Window);
	applySettings(Dimensions);
	system("title Advanced Trigonometry Calculator v1.8.4                                                             ==) Enter data (==              ");

}

double initialProcessor(char arithTrig[DIM], double result){
	resultR = 0; resultI = 0;
	if (strlen(arithTrig) == 0){
		arithTrig[0] = '0'; arithTrig[1] = '\0';
	}
	char arTrig[DIM] = "", trigon[DIM] = "", trig[DIM] = "", paRect[DIM] = "", cN[DIM] = "", ex[DIM] = "", art[DIM] = "";
	int facto = 0, sig[DIM], s = 0, rectPar = 0, h = 0, i = 0, rePar = 0, so = 0, j = 0, g = 0, count = 0, e = 0, d = 0, th = 0, f = 0, trigo = 1, trigono = 0, co = 0, k = 0, l = 0, tr = 0, pa = 0, paren = 1, pare = 0, tg = 0, p = 0, a = 0, c = 1, r = 0, iN = 0, iL = 0;
	double triArith[DIM], triArithI[DIM], exp = 1, result1, result2, amplitude = 1;
	for (s = 0; s < strlen(arithTrig); s++){
		triArith[s] = 0;
		triArithI[s] = 0;
		sig[s] = -1;
	}
	for (s = 0; arithTrig[s] != '\0'; s++){
		if (arithTrig[s] == 's'&&arithTrig[s + 1] == 'o'&&arithTrig[s + 2] == 'l'&&arithTrig[s + 3] == 'v'&&arithTrig[s + 4] == 'i'&&arithTrig[s + 5] == 'n'&&arithTrig[s + 6] == 't'){
			iN = 1;
		}
		if (arithTrig[s] == '|'){
			iL++;
		}
	}
	if (iN == 0 && iL == 2){
		for (s = 0; arithTrig[s] != '\0'; s++){
			integral[s] = arithTrig[s];
		}
		integral[s] = '\0';
	}
	for (i = 0; arithTrig[i] != '\0'; i++){
		if (arithTrig[i] == 'x'){
			arithTrig[i] = '*';
		}
		if (arithTrig[i] == '[' || arithTrig[i] == '{'){
			arithTrig[i] = '(';
		}
		if (arithTrig[i] == ']' || arithTrig[i] == '}'){
			arithTrig[i] = ')';
		}
		if (arithTrig[i] == '^'&&arithTrig[i + 1] == '-'){
			arithTrig[i + 1] = '_';
		}
		if (arithTrig[i] == 'E'&&arithTrig[i + 1] == '_'){
			arithTrig[i + 1] = '-';
		}
		if ((arithTrig[i] == 'B' || arithTrig[i] == 'O' || arithTrig[i] == 'H') && arithTrig[i + 1] == '_'){
			arithTrig[i + 1] = '-';
		}
	}
	arithTrig[i] = '+'; arithTrig[i + 1] = '('; arithTrig[i + 2] = '0'; arithTrig[i + 3] = ')'; arithTrig[i + 4] = '\0';
	if (arithTrig[i - 1] == ')'&&arithTrig[i - 2] == '0'&&arithTrig[i - 3] == '('){
		arithTrig[i] = '\0';
	}
	for (s = 0; arithTrig[s] != '\0'; s++){
		if (arithTrig[s] == '+'&&arithTrig[s - 1] == 'E'&&arithTrig[s - 2] != 'P'){
			r = s;
			s--;
			while (arithTrig[s] != '*'&&arithTrig[s] != '/'&&arithTrig[s] != '^'&&arithTrig[s] != '+' && (arithTrig[s] != '-'&&arithTrig[s - 1] != 'H') && arithTrig[s] != 'H'){
				s--;
			}
			s--;
			if (arithTrig[s] != 'H'){
				arithTrig[r] = '0';
			}
			s = r + 1;
		}
	}

	char paTrig[DIM] = "";
	for (s = 0; arithTrig[s] != '\0'; s++){
		paTrig[s] = arithTrig[s];
	}
	paTrig[s] = '\0';
	s = 0;

	s = 0;
	for (s; paTrig[s] != '\0'; s++){
		if ((paTrig[s] == 'E' || paTrig[s] == 'P') && (s == 0 || paTrig[s - 1] == '_' || paTrig[s - 1] == '*' || paTrig[s - 1] == 'x' || paTrig[s - 1] == '/' || paTrig[s - 1] == '^' || paTrig[s - 1] == '+' || (paTrig[s - 1] == '-'&&paTrig[s - 2] != 'H') || paTrig[s - 1] == '(')){
			arithTrig[s] = '1';
			for (s; paTrig[s] != '\0'; s++){
				arithTrig[s + 1] = paTrig[s];
			}
			arithTrig[s + 1] = '\0';
			s = 0;
			for (s = 0; arithTrig[s] != '\0'; s++){
				paTrig[s] = arithTrig[s];
			}
			paTrig[s] = '\0';
			s = 0;
		}
	}
	s = 0;
	for (s; paTrig[s] != '\0'; s++){
		if ((paTrig[s] == 'i'&&paTrig[s - 1] == 'p' || paTrig[s] == 'e' || paTrig[s] == ')' || arithTrig[s] == 'a' || arithTrig[s] == 'c' || arithTrig[s] == 'd' || arithTrig[s] == 'f' || arithTrig[s] == 'g' || arithTrig[s] == 'h' || arithTrig[s] == 'j' || arithTrig[s] == 'k' || arithTrig[s] == 'm' || arithTrig[s] == 'n' || arithTrig[s] == 'o' || arithTrig[s] == 'p' || arithTrig[s] == 'q' || arithTrig[s] == 'r' || arithTrig[s] == 's' || arithTrig[s] == 't' || arithTrig[s] == 'u' || arithTrig[s] == 'w' || arithTrig[s] == 'v' || arithTrig[s] == 'y' || arithTrig[s] == 'z' || arithTrig[s] == 'G' || arithTrig[s] == 'I' || arithTrig[s] == 'J' || arithTrig[s] == 'K' || arithTrig[s] == 'L' || arithTrig[s] == 'M' || arithTrig[s] == 'N' || arithTrig[s] == 'O' || arithTrig[s] == 'Q' || arithTrig[s] == 'R' || arithTrig[s] == 'S' || arithTrig[s] == 'T' || arithTrig[s] == 'U' || arithTrig[s] == 'V' || arithTrig[s] == 'Y' || arithTrig[s] == 'Z') && (paTrig[s + 1] == 'E' || paTrig[s + 1] == 'P')){
			s++;
			arithTrig[s] = '1';
			for (s; paTrig[s] != '\0'; s++){
				arithTrig[s + 1] = paTrig[s];
			}
			arithTrig[s + 1] = '\0';
			s = 0;
			for (s = 0; arithTrig[s] != '\0'; s++){
				paTrig[s] = arithTrig[s];
			}
			paTrig[s] = '\0';
			s = 0;
		}
	}

	int u = 0;
	for (u = 0; arithTrig[u] != '\0'; u++){
		paTrig[u] = arithTrig[u];
	}
	paTrig[u] = '\0';
	u = 0;
	for (u; paTrig[u] != '\0'; u++){
		if (verifyLetter(paTrig[u]) == 0){
			while (verifyLetter(paTrig[u]) == 0 && paTrig[u] != '\0'){
				u++;
			}
		}
		if (verifyLetter(paTrig[u]) == 1 && firstLetterVariable(paTrig[u]) == 0){
			while (verifyLetter(paTrig[u]) == 1){
				u++;
			}
		}
		if (firstLetterVariable(paTrig[u]) == 1 && firstLetterVariable(paTrig[u - 1]) == 0 && paTrig[u + 1] != 'i'){
			u++;
			while (verifyLetter(paTrig[u]) == 1){
				u++;
			}
			if (paTrig[u] != '*'&&paTrig[u] != '+'&&paTrig[u] != '-'&&paTrig[u] != '/'&&paTrig[u] != '^'&&paTrig[u] != '!'&&paTrig[u] != ')'){
				arithTrig[u] = '*';
				for (u; paTrig[u] != '\0'; u++){
					arithTrig[u + 1] = paTrig[u];
				}
				arithTrig[u + 1] = '\0';
				u = 0;
				for (u = 0; arithTrig[u] != '\0'; u++){
					paTrig[u] = arithTrig[u];
				}
				paTrig[u] = '\0';
				u = 0;
			}
		}

	}
	s = 0;
	for (s; paTrig[s] != '\0'; s++){
		if (paTrig[s] == ')'&&paTrig[s + 1] == '('){
			s++;
			arithTrig[s] = '*';
			for (s; paTrig[s] != '\0'; s++){
				arithTrig[s + 1] = paTrig[s];
			}
			arithTrig[s + 1] = '\0';
			s = 0;
			for (s = 0; arithTrig[s] != '\0'; s++){
				paTrig[s] = arithTrig[s];
			}
			paTrig[s] = '\0';
			s = 0;
		}
	}
	s = 0;
	for (s; paTrig[s] != '\0'; s++){
		if ((arithTrig[s] == 'G' || arithTrig[s] == 'I' || arithTrig[s] == 'J' || arithTrig[s] == 'K' || arithTrig[s] == 'L' || arithTrig[s] == 'M' || arithTrig[s] == 'N' || arithTrig[s] == 'O' || arithTrig[s] == 'P' || arithTrig[s] == 'Q' || arithTrig[s] == 'R' || arithTrig[s] == 'S' || arithTrig[s] == 'T' || arithTrig[s] == 'U' || arithTrig[s] == 'V' || arithTrig[s] == 'X' || arithTrig[s] == 'Y' || arithTrig[s] == 'Z' || arithTrig[s] == 'a' || arithTrig[s] == 'c' || arithTrig[s] == 'd' || arithTrig[s] == 'f' || arithTrig[s] == 'g' || arithTrig[s] == 'h' || arithTrig[s] == 'j' || arithTrig[s] == 'k' || arithTrig[s] == 'm' || arithTrig[s] == 'n' || arithTrig[s] == 'o' || arithTrig[s] == 'p' || arithTrig[s] == 'q' || arithTrig[s] == 'r' || arithTrig[s] == 's' || arithTrig[s] == 't' || arithTrig[s] == 'u' || arithTrig[s] == 'w' || arithTrig[s] == 'v' || arithTrig[s] == 'y' || arithTrig[s] == 'z') && (paTrig[s + 1] == '1'&&paTrig[s + 2] == 'E')){
			s++;
			arithTrig[s] = '*';
			for (s; paTrig[s] != '\0'; s++){
				arithTrig[s + 1] = paTrig[s];
			}
			arithTrig[s + 1] = '\0';
			s = 0;
			for (s = 0; arithTrig[s] != '\0'; s++){
				paTrig[s] = arithTrig[s];
			}
			paTrig[s] = '\0';
			s = 0;
		}
	}
	s = 0;
	for (s; paTrig[s] != '\0'; s++){
		if ((paTrig[s] == '1' || paTrig[s] == '2' || paTrig[s] == '3' || paTrig[s] == '4' || paTrig[s] == '5' || paTrig[s] == '6' || paTrig[s] == '7' || paTrig[s] == '8' || paTrig[s] == '9' || paTrig[s] == '0' || paTrig[s] == 'i'&&paTrig[s + 1] != 'e'&&paTrig[s - 1] == 'p' || paTrig[s] == 'e'&&paTrig[s - 1] != 'r'&&paTrig[s - 1] != 's'&&paTrig[s - 1] != 'i'&&paTrig[s + 2] != 't' || paTrig[s] == ')') && (paTrig[s + 1] == '(' || paTrig[s + 1] == 'a' || paTrig[s + 1] == 's' || paTrig[s + 1] == 'c' || paTrig[s + 1] == 't' || paTrig[s + 1] == 'l' || paTrig[s + 1] == 'p' || paTrig[s + 1] == 'e' || paTrig[s + 1] == 'r'&&paTrig[s + 2] != 'r' || paTrig[s + 1] == 'd' || paTrig[s + 1] == 'q' || paTrig[s + 1] == 'g'&&paTrig[s - 1] != 'd')){
			s++;
			arithTrig[s] = '*';
			for (s; paTrig[s] != '\0'; s++){
				arithTrig[s + 1] = paTrig[s];
			}
			arithTrig[s + 1] = '\0';
			s = 0;
			for (s = 0; arithTrig[s] != '\0'; s++){
				paTrig[s] = arithTrig[s];
			}
			paTrig[s] = '\0';
			s = 0;
		}
	}
	s = 0;
	for (s; paTrig[s] != '\0'; s++){
		if ((paTrig[s] == '1' || paTrig[s] == '2' || paTrig[s] == '3' || paTrig[s] == '4' || paTrig[s] == '5' || paTrig[s] == '6' || paTrig[s] == '7' || paTrig[s] == '8' || paTrig[s] == '9' || paTrig[s] == '0' || paTrig[s] == 'p' || paTrig[s] == 'e' || verifyLetter(paTrig[s]) == 1 && paTrig[s] != 'b'&&paTrig[s] != 'D') && (paTrig[s - 1] == ')')){
			arithTrig[s] = '*';
			for (s; paTrig[s] != '\0'; s++){
				arithTrig[s + 1] = paTrig[s];
			}
			arithTrig[s + 1] = '\0';
			s = 0;
			for (s = 0; arithTrig[s] != '\0'; s++){
				paTrig[s] = arithTrig[s];
			}
			paTrig[s] = '\0';
			s = 0;
		}
	}
	s = 0;
	for (s; paTrig[s] != '\0'; s++){
		if ((paTrig[s + 1] == '1' || paTrig[s + 1] == '2' || paTrig[s + 1] == '3' || paTrig[s + 1] == '4' || paTrig[s + 1] == '5' || paTrig[s + 1] == '6' || paTrig[s + 1] == '7' || paTrig[s + 1] == '8' || paTrig[s + 1] == '9' || paTrig[s + 1] == '0' || paTrig[s + 1] == 'p' || paTrig[s + 1] == 'e') && (paTrig[s - 1] == 'p'&&paTrig[s] == 'i'&&paTrig[s + 1] != 'e' || paTrig[s] == 'e'&&paTrig[s - 1] != 'i')){
			s++;
			arithTrig[s] = '*';
			for (s; paTrig[s] != '\0'; s++){
				arithTrig[s + 1] = paTrig[s];
			}
			arithTrig[s + 1] = '\0';
			s = 0;
			for (s = 0; arithTrig[s] != '\0'; s++){
				paTrig[s] = arithTrig[s];
			}
			paTrig[s] = '\0';
			s = 0;
		}
	}
	s = 0;
	for (s; paTrig[s] != '\0'; s++){
		if (paTrig[s] == '_' && (paTrig[s + 1] == '(' || paTrig[s + 1] == 'r'&&paTrig[s + 2] == 'e'&&paTrig[s + 3] == 's')){
			arithTrig[s + 1] = '1'; arithTrig[s + 2] = '*'; s++;
			for (s; paTrig[s] != '\0'; s++){
				arithTrig[s + 2] = paTrig[s];
			}
			arithTrig[s + 2] = '\0';
			s = 0;
			for (s = 0; arithTrig[s] != '\0'; s++){
				paTrig[s] = arithTrig[s];
			}
			paTrig[s] = '\0';
			s = 0;
		}
	}
	s = 0;
	for (s; paTrig[s] != '\0'; s++){
		if ((paTrig[s - 2] == 'r'&&paTrig[s - 1] == 'e'&&paTrig[s] == 's'&&paTrig[s + 2] != '('&&paTrig[s + 1] != '!'&&verifyLetter(paTrig[s + 1]) == 0) && (paTrig[s + 1] != '+'&&paTrig[s + 1] != '-'&&paTrig[s + 1] != '*'&&paTrig[s + 1] != '/'&&paTrig[s + 1] != '^'&&paTrig[s + 1] != ')'&&paTrig[s + 1] != 'b')){
			s++;
			arithTrig[s] = '*';
			for (s; paTrig[s] != '\0'; s++){
				arithTrig[s + 1] = paTrig[s];
			}
			arithTrig[s + 1] = '\0';
			s = 0;
			for (s = 0; arithTrig[s] != '\0'; s++){
				paTrig[s] = arithTrig[s];
			}
			paTrig[s] = '\0';
			s = 0;
		}
	}
	s = 0;
	for (s; paTrig[s] != '\0'; s++){
		if ((paTrig[s] == 'e' || paTrig[s - 1] == 'p'&&paTrig[s] == 'i') && (paTrig[s + 1] == 'p'&&paTrig[s + 2] == 'i' || paTrig[s + 1] == 'e')){
			s++;
			arithTrig[s] = '*';
			for (s; paTrig[s] != '\0'; s++){
				arithTrig[s + 1] = paTrig[s];
			}
			arithTrig[s + 1] = '\0';
			s = 0;
			for (s = 0; arithTrig[s] != '\0'; s++){
				paTrig[s] = arithTrig[s];
			}
			paTrig[s] = '\0';
			s = 0;
		}
	}
	s = 0;
	for (s; paTrig[s] != '\0'; s++){
		if (paTrig[s + 1] == '_'&&paTrig[s] != '+'&&paTrig[s] != '-'&&paTrig[s] != '*'&&paTrig[s] != '/'&&paTrig[s] != '^'&&paTrig[s] != '(' && (paTrig[s] != 'D'&&paTrig[s - 1] != 't'&&paTrig[s - 2] != 'r') && (paTrig[s] != 'b'&&paTrig[s - 1] != 'g'&&paTrig[s - 2] != 'o'&&paTrig[s - 3] != 'l')){
			s++;
			arithTrig[s] = '*';
			for (s; paTrig[s] != '\0'; s++){
				arithTrig[s + 1] = paTrig[s];
			}
			arithTrig[s + 1] = '\0';
			s = 0;
			for (s = 0; arithTrig[s] != '\0'; s++){
				paTrig[s] = arithTrig[s];
			}
			paTrig[s] = '\0';
			s = 0;
		}
	}
	int cp = 0, mark = 0;
	c = 0; d = 0; k = 0; l = 0; h = 0;
	int parent[DIM];
	for (s = 0; arithTrig[s] != '\0'; s++){
		if (arithTrig[s] == '('){
			d = 0;
			c++;
			parent[s] = c;
			d = 1;
			k = c;
		}
		else{
			if (arithTrig[s] == ')'){
				d = 0;
				h = 0;
				l = 2;
				do{
					l = 0;
					h = 0;
					while (h < strlen(arithTrig)){
						if (parent[h] == k){
							l++;
						}
						if (l == 2){
							l = 0;
							k--;
						}
						h++;
					}

				} while (l == 2);
				h = 0;
				while (l != 1){
					h = 0;
					l = 0;
					while (h < strlen(arithTrig)){
						if (parent[h] == k){
							l++;
						}
						if (l == 2){
							k--;
							h = 0;
							l = 0;
						}
						h++;
					}
				}
				parent[s] = k;
			}
			else{
				parent[s] = 0;
			}
		}
	}
	int klp = s;
	arithTrig[s] = '\0';
	int curPar = 0, cur = 0;
	for (i = 0; arithTrig[i] != '\0'; i++){
		if (arithTrig[i] == '(' || arithTrig[i] == ')'){
			curPar = 1;
		}
	}
	arithTrig[i] = '\0';
	if (curPar == 0){
		result1 = arithSolver(arithTrig, result);
		return result1;
	}
	a = 0;
	int de = 0, b = 0, ju = 0;
	c = 0;
	char pas[DIM] = "";
	int se = 0;
	int thj = 0;
	if (curPar == 1){
		for (i = 0; i < strlen(arithTrig); i++){
			int jk = 0;
			char op[DIM] = "";
			while (parent[i] < 1 && i <= klp){
				if (arithTrig[i] == '_' && (arithTrig[i + 1] == 'g' || arithTrig[i + 1] == 's' || arithTrig[i + 1] == 'c' || arithTrig[i + 1] == 't' || arithTrig[i + 1] == 'a' || arithTrig[i + 1] == 'l' || arithTrig[i + 1] == 'd' || arithTrig[i + 1] == 'r') || arithTrig[i] == 'q' || arithTrig[i] == 's' || arithTrig[i] == 'c' || arithTrig[i] == 't' || arithTrig[i] == 'a' || arithTrig[i] == 'r' && (arithTrig[i + 3] == 't'&&arithTrig[i + 4] != 'g'&&arithTrig[i + 4] != 'a' || arithTrig[i + 1] == 'a'&&arithTrig[i + 2] == 'd' || arithTrig[i + 1] == 't'&&arithTrig[i + 2] == 'D') || arithTrig[i] == 'd' || arithTrig[i] == 'l' || arithTrig[i] == 'g'){
					if (arithTrig[i] == '_'){
						thj = 1;
					}
					if (arithTrig[i - 1] == '1' || arithTrig[i - 1] == '2' || arithTrig[i - 1] == '3' || arithTrig[i - 1] == '4' || arithTrig[i - 1] == '5' || arithTrig[i - 1] == '6' || arithTrig[i - 1] == '7' || arithTrig[i - 1] == '8' || arithTrig[i - 1] == '9' || arithTrig[i - 1] == '0' || arithTrig[i - 1] == 'i' || arithTrig[i - 1] == 'e' || arithTrig[i - 1] == ')'){
						jk = 1;
					}ju = 0;
					while (arithTrig[i] != '('&&arithTrig[i] != '\0'){
						if ((arithTrig[i] == 'b'&&arithTrig[i - 1] != 'c') || arithTrig[i] == 'D'){
							op[ju] = arithTrig[i];
							ju++; i++;
							while ((arithTrig[i] == 'b'&&arithTrig[i + 1] == '(') == false && (arithTrig[i] == 'D'&&arithTrig[i + 1] == '(') == false && arithTrig[i] != '\0'){
								op[ju] = arithTrig[i];
								ju++; i++;
							}
						}
						op[ju] = arithTrig[i];
						ju++; i++;
					}
					op[ju] = '\0';
				}
				else{
					a = 0; if (arithTrig[i] == '_'&&arithTrig[i + 1] != 's'&&arithTrig[i + 1] != 'c'&&arithTrig[i + 1] != 't'&&arithTrig[i + 1] != 'a'&&arithTrig[i + 1] != 'l'&&arithTrig[i + 1] != 'd'&&arithTrig[i + 1] != 'r'&&arithTrig[i + 1] != 'g'){
						pas[a] = arithTrig[i]; a++; i++;
					}
					while (arithTrig[i] != '+'&&arithTrig[i] != '-'&&arithTrig[i] != '*'&&arithTrig[i] != '/'&&arithTrig[i] != '^'&&arithTrig[i] != '!'){
						pas[a] = arithTrig[i];
						a++;
						i++;
						if (arithTrig[i] == '-'&&arithTrig[i - 1] == 'E' || arithTrig[i] == '-'&&arithTrig[i - 1] == 'O' || arithTrig[i] == '-'&&arithTrig[i - 1] == 'B' || arithTrig[i] == '-'&&arithTrig[i - 1] == 'H'){
							pas[a] = arithTrig[i];
							a++;
							i++;
						}
					}
				}
				pas[a] = '\0';
				if (jk == 1){
					arTrig[c] = '*';
				}
				if (arithTrig[i] == '+' || arithTrig[i] == '-' || arithTrig[i] == '*' || arithTrig[i] == '/' || arithTrig[i] == '^' || arithTrig[i] == '!'){
					arTrig[c] = arithTrig[i]; c++;
				}
				if (strlen(pas) > 0){
					triArith[b] = arithSolver(pas, result);
					triArithI[b] = resultI;
					pas[0] = '\0';
					b++;
				}
				i++;
				if (strlen(op) > 0){
					i--;
				}
			}
			pas[a] = '\0';
			cur = parent[i];
			j = i;
			if (parent[i] == cur){
				i = j;
				a = 0;
				i++;
				while (parent[i] != cur){
					pas[a] = arithTrig[i];
					a++; i++;
				}
				pas[a] = '\0';
				int kl = 0;
				for (de = 0; pas[de] != '\0'; de++){
					if (pas[de] == '(' || pas[de] == ')'){
						kl = 1;
					}
				}
				a = 0;
				if (kl == 0){
					triArith[b] = arithSolver(pas, result);
					triArithI[b] = resultI;
					sig[b] = 1;
					pas[0] = '\0';
					if (strlen(op) > 0){
						if (op[3] == 't' && (op[2] == 's' || op[2] == 'o'&&op[1] != 'c')){
							resultI = triArithI[b]; resultR = triArithI[b - 1];
							triArith[b - 1] = functionProcessor(op, triArith[b], triArith[b - 1], result);
							triArith[b] = 0;
							triArithI[b - 1] = resultI;
							triArithI[b] = 0;
							arTrig[b - 1] = '+';
						}
						else{
							triArith[b] = functionProcessor(op, triArith[b], amplitude, result);
							triArithI[b] = resultI;
						}
						if (thj == 1){ thj = 0; sig[b] = 0; }
						else{
							sig[b] = 1;
						}
						pas[0] = '\0';
						ju = 0;
					}
				}
				if (kl == 1){
					triArith[b] = initialProcessor(pas, result);
					triArithI[b] = resultI;
					sig[b] = 1;
					char pas[DIM] = "";
					if (strlen(op) > 0){
						resultI = triArithI[b];
						triArith[b] = functionProcessor(op, triArith[b], amplitude, result);
						triArithI[b] = resultI;
						if (thj == 1){ thj = 0; sig[b] = 0; }
						else{
							sig[b] = 1;
						}
						pas[0] = '\0';
					}
					ju = 0;
				}

				b++;
			}


		}
		arTrig[c] = '=';
	}
	int negFact = 0;
	for (s = 0; s < c; s++){
		if (arTrig[s] == '!'){
			if (triArith[s] < 0){
				negFact = 1;
			}
			while (arTrig[s] == '!'){
				triArith[s] = fact(abs(triArith[s]));
				while (s < c){
					arTrig[s] = arTrig[s + 1];
					s++;
				}
				s = 0;
			}
			if (negFact == 1){
				triArith[s] = triArith[s] * -1;
			}
		}
	}

	a = 0;
	int fr;
	so = 0;
	int ca = 0;
	double asdf = 0, asdfI = 0;
	for (so = 0; so < c; so++){
		int sa = so;
		int b = 0;
		if (arTrig[so] == '^'&&arTrig[so + 1] == '^'){
			while (arTrig[so] == '^'&&a != 1){
				if (arTrig[so + 1] != '^'&&arTrig[so - 1] == '^'&&a != 2){
					asdf = triArith[so + 1];
					asdfI = triArithI[so + 1];
					if (sig[so] == -1){
						if (triArith[so] < 0 || triArithI[so]){
							sig[so] = 0;
						}
						else{ sig[so] = 1; }
					}
					exponentiation(triArith[so], triArithI[so], asdf, asdfI, sig[so]);
					asdf = resultR;
					asdfI = resultI;
					triArith[so + 1] = 0;
					triArith[so] = 0;
					triArithI[so + 1] = 0;
					triArithI[so] = 0;
					arTrig[so] = '+';
					so--;
					a = 2;
				}
				else{
					if (arTrig[so + 1] == '^'&&a == 0){
						so++;
						fr = so;
					}
					else{
						if (a == 2){
							while (a != 1){
								if (sig[so] == -1){
									if (triArith[so] < 0 || triArithI[so] < 0){
										sig[so] = 0;
									}
									else{ sig[so] = 1; }
								}
								exponentiation(triArith[so], triArithI[so], asdf, asdfI, sig[so]);
								asdf = resultR;
								asdfI = resultI;
								triArith[so] = 0; triArithI[so] = 0;
								arTrig[so] = '+';
								so--;

								if (arTrig[so] != '^'){
									a = 1;
									so = fr++;
								}
							}
						}
					}


				}
				if (a == 1){
					triArith[sa] = asdf; a = 0;
					triArithI[sa] = asdfI;
				}

			}
		}
		else{
			if (arTrig[so] == '^'&&arTrig[so + 1] != '^'){
				while (arTrig[so] == '^'){
					if (sig[sa] == -1){
						if (triArith[sa] < 0 || triArithI[sa] < 0){
							sig[sa] = 0;
						}
						else{ sig[sa] = 1; }
					}
					exponentiation(triArith[sa], triArithI[sa], triArith[so + 1], triArithI[so + 1], sig[sa]);
					triArith[sa] = resultR; triArithI[sa] = resultI;
					triArith[so + 1] = 0; triArithI[so + 1] = 0;
					arTrig[so] = '+';
					so = so + 1;
				}
			}
		}

	}
	for (so = 0; so < c; so++){
		int sa = so;
		while (arTrig[so] == '*'){
			multiplication(triArith[sa], triArithI[sa], triArith[so + 1], triArithI[so + 1]);
			triArith[sa] = resultR; triArithI[sa] = resultI;
			triArith[so + 1] = 0; triArithI[so + 1] = 0;
			arTrig[so] = '+';
			so++;
		}
		while (arTrig[so] == '/'){
			division(triArith[sa], triArithI[sa], triArith[so + 1], triArithI[so + 1]);
			triArith[sa] = resultR; triArithI[sa] = resultI;
			triArith[so + 1] = 0; triArithI[so + 1] = 0;
			arTrig[so] = '+';
			so++;
		}
	}
	char func[DIM] = "";
	int lo = 0;
	for (j = 0; j < c; j++){
		if (j == 0){
			result1 = triArith[0];
			result2 = triArithI[0];
		}
		if (arTrig[j] == '^'){
			exponentiation(result1, result2, triArith[j + 1], triArithI[j + 1], 1);
			result1 = resultR;
			result2 = resultI;
		}
		if (arTrig[j] == '*'){
			multiplication(result1, result2, triArith[j + 1], triArithI[j + 1]);
			result1 = resultR;
			result2 = resultI;
		}
		if (arTrig[j] == '/'){
			division(result1, result2, triArith[j + 1], triArithI[j + 1]);
			result1 = resultR;
			result2 = resultI;
		}
		if (arTrig[j] == '-'){
			subtraction(result1, result2, triArith[j + 1], triArithI[j + 1]);
			result1 = resultR;
			result2 = resultI;
		}
		if (arTrig[j] == '+'){
			sum(result1, result2, triArith[j + 1], triArithI[j + 1]);
			result1 = resultR;
			result2 = resultI;
		}
	}
	resultR = result1;
	resultI = result2;
	round_complex();
	result1 = resultR;
	result2 = resultI;
	return result1;
}

double arithSolver(char trigon1[DIM], double result){
	resultR = 0; resultI = 0;
	int i = 0, negImag = 0, j = 0, e = 0, f = 0, h = 0, so = 0, sa = 0, n = 0, c = 0, sig[DIM], sign = 0, s = 0, facto = 0, y = 0, sif = 0, res = 0, v = 0;
	char number2[DIM] = "", ex[DIM] = "", trigon[DIM] = "", amp[DIM] = "", prefCalc[10] = "";
	double exp = 1, ampl[DIM], amplI[DIM], result1 = 0, result2 = 0, fa = 0;
	for (i = 0; trigon1[i] != '\0'; i++){
		ampl[i] = 0; amplI[i] = 0;
	}
	if (trigon1[i - 1] != '='){
		trigon1[i] = '='; trigon1[i + 1] = '\0';
	}
	for (i = 0; trigon1[i] != '\0'; i++){
		if (trigon1[i] == '-' && (trigon1[i - 1] == 'B' || trigon1[i - 1] == 'O' || trigon1[i - 1] == 'H') && (i - 1 == 0 || trigon1[i - 2] == '+' || trigon1[i - 2] == '-' || trigon1[i - 2] == '*' || trigon1[i - 2] == '/' || trigon1[i - 2] == '^')){
			trigon1[i] = '_';
		}
	}
	int si = 0;
	j = 0;
	for (i = 0; trigon1[i] != '\0'; i++){
		if (trigon1[i] != '*'&&trigon1[i] != '+'&&trigon1[i] != '-'&&trigon1[i] != '/'&&trigon1[i] != '^'&&trigon1[i] != '='){
			while (trigon1[i] != '*'&&trigon1[i] != '+'&&trigon1[i] != '-'&&trigon1[i] != '/'&&trigon1[i] != '^'&&trigon1[i] != '='){
				if (((trigon1[i] == 'B' || trigon1[i] == 'O' || trigon1[i] == 'H') && trigon1[i + 1] != '-'&&trigon1[i + 1] != '+'&&trigon1[i + 1] != '*'&&trigon1[i + 1] != '/'&&trigon1[i + 1] != '^'&&trigon1[i + 1] != '=') || (trigon1[i] == 'E'&&trigon1[i + 1] != '=')){
					number2[j] = trigon1[i];
					number2[j + 1] = trigon1[i + 1];
					j = j + 2; i = i + 2;
					while (trigon1[i] != '*'&&trigon1[i] != '+'&&trigon1[i] != '-'&&trigon1[i] != '/'&&trigon1[i] != '^'&&trigon1[i] != '='){
						if (trigon1[i] == '='){ number2[j] = '\0'; j++; i++; sif = 1; }
						number2[j] = trigon1[i];
						j++; i++;
					}
				}
				else{
					number2[j] = trigon1[i];
					j++; i++;
				}
			}
			i--;
			if (sif == 0){
				number2[j] = '.';
				number2[j + 1] = '0';
				number2[j + 2] = '\0';
			}
		}
		int complex = 0;
		if (number2[0] == 'i'){
			complex = 1;
			for (y = 0; number2[y + 1] != '\0'; y++){
				number2[y] = number2[y + 1];
			}
			number2[y] = '\0';
		}
		if (number2[0] == '_'&&number2[1] == 'i'&&number2[2] == '1'){
			complex = 1;
			for (y = 0; number2[y + 1] != '\0'; y++){
				number2[y] = number2[y + 1];
			}
			number2[y] = '\0';
			negImag = 1;
		}
		if (number2[strlen(number2) - 4] != 'p'&&number2[strlen(number2) - 3] == 'i'){
			complex = 1;
			for (y = strlen(number2) - 3; number2[y + 1] != '\0'; y++){
				number2[y] = number2[y + 1];
			}
			number2[y] = '\0';
		}
		for (y = 0; number2[y] != '\0'; y++){
			if (number2[y] == '='){
				number2[y] = '\0';
				break;
			}
		}
		for (y = 0; number2[y] != '\0'; y++){
			if (number2[y] == '!'){
				facto++;
			}
		}
		if (facto > 0){
			y = 0;
			while (number2[y] != '!'){
				y++;
			}
			number2[y] = '.'; number2[y + 1] = '0'; number2[y + 2] = '\0';
		}

		v = 0;
		for (j = 0; number2[j] != '\0'; j++){
			if (number2[j] == 'P'){
				y = j;
				while (number2[j] != '.'){
					prefCalc[v] = number2[j];
					v++; j++;
				}
				prefCalc[v] = '\0';
				number2[y] = '.'; number2[y + 1] = '0'; number2[y + 2] = '\0';
			}
		}
		if (number2[0] == '#'){
			res = 1;
			for (y = 0; number2[y + 1] != '\0'&&number2[y + 1] != 'E'; y++){
				number2[y] = number2[y + 1];
			}
			number2[y] = '\0';

			ampl[n] = convertToNumber(number2);
			ampl[n] = ans[(int)ampl[n]];
			amplI[n] = convertToNumber(number2);
			amplI[n] = ansI[(int)amplI[n]];
			complex = 2;
			y++;
			if (number2[y] == 'E'){
				number2[0] = '1';
				j = 1;
				while (number2[y] != '\0'){
					number2[j] = number2[y];
					j++; y++;
				}
				number2[j] = '\0';
				ampl[n] = ampl[n] * convertToNumber(number2);
			}
			number2[0] = '\0';
		}
		if (number2[0] == '_'&&number2[1] == '#'){
			res = 1;
			for (y = 0; number2[y + 2] != '\0'&&number2[y + 2] != 'E'; y++){
				number2[y] = number2[y + 2];
			}
			number2[y] = '\0';
			ampl[n] = convertToNumber(number2);
			ampl[n] = ans[(int)ampl[n]] * -1;
			amplI[n] = convertToNumber(number2);
			amplI[n] = ansI[(int)amplI[n]] * -1;
			y = y + 2;
			if (number2[y] == 'E'){
				number2[0] = '1';
				j = 1;
				while (number2[y] != '\0'){
					number2[j] = number2[y];
					j++; y++;
				}
				number2[j] = '\0';
				ampl[n] = ampl[n] * convertToNumber(number2);
			}
			number2[0] = '\0';
		}

		sif = 0;
		int df = j;

		j = 0;
		if (number2[0] != 'B'&&number2[0] != 'O'&&number2[0] != 'H'&&number2[0] != 'P'){
			if (number2[0] == '_'&&number2[1] != 'e'&&number2[1] != 'p'&&number2[1] != 'B'&&number2[1] != 'O'&&number2[1] != 'H'){
				if (number2[1] == '.'){
					j = strlen(number2);
					while (j > 1){
						number2[j] = number2[j - 1];
						j--;
					}
					number2[j] = '0';
				}

				for (j = 0; number2[j] != '\0'; j++){
					number2[j] = number2[j + 1];
				}
				if (number2[0] != '0'&&number2[0] != '1'&&number2[0] != '2'&&number2[0] != '3'&&number2[0] != '4'&&number2[0] != '5'&&number2[0] != '6'&&number2[0] != '7'&&number2[0] != '8'&&number2[0] != '9'){
					sign = 1;
					for (j = 0; number2[j] != '\0'; j++){
						if (number2[j] == '.'){
							number2[j] = '\0';
						}
					}
				}

				if (res == 0){
					ampl[n] = -1 * convertToNumber(number2);
				}
			}
			else{
				if (res == 0 && number2[0] != '_'){
					ampl[n] = convertToNumber(number2);
				}
			}
			if (prefCalc[0] == 'P'){
				if (prefCalc[1] == 'd'&&prefCalc[2] == 'a'){
					prefCalc[1] = 'D';
				}
				ampl[n] = ampl[n] * prefToNumber(prefCalc[1]);
			}
			number2[df] = '\0';
		}
		double var = 0;
		if (number2[0] == 'f' || number2[0] == 'h' || number2[0] == 'j' || number2[0] == 'k' || number2[0] == 'm' || number2[0] == 'n' || number2[0] == 'o' || number2[0] == 'p' || number2[0] == 'u' || number2[0] == 'w' || number2[0] == 'v' || number2[0] == 'y' || number2[0] == 'z' || number2[0] == 'G' || number2[0] == 'I' || number2[0] == 'J' || number2[0] == 'K' || number2[0] == 'L' || number2[0] == 'M' || number2[0] == 'N' || number2[0] == 'Q' || number2[0] == 'R' || number2[0] == 'S' || number2[0] == 'T' || number2[0] == 'U' || number2[0] == 'V' || number2[0] == 'X' || number2[0] == 'Y' || number2[0] == 'Z'){
			for (j = 0; number2[j] != '\0'; j++){
				if (number2[j] == '.'){
					number2[j] = '\0';
				}
			}
			processVariable(number2);
			if (resultR != 0){
				ampl[n] = resultR;
				if (sign == 1){
					sign = 0;
					ampl[n] = ampl[n] * -1;
				}
			}
			if (resultI != 0){
				complex = 2;
				amplI[n] = resultI;
				if (sign == 1){
					sign = 0;
					amplI[n] = amplI[n] * -1;
				}
			}
		}
		if (number2[1] == 'f' || number2[1] == 'h' || number2[1] == 'j' || number2[1] == 'k' || number2[1] == 'm' || number2[1] == 'n' || number2[1] == 'o' || number2[1] == 'p' &&number2[2] != 'i' || number2[1] == 'u' || number2[1] == 'w' || number2[1] == 'v' || number2[1] == 'y' || number2[1] == 'z' || number2[1] == 'G' || number2[1] == 'I' || number2[1] == 'J' || number2[1] == 'K' || number2[1] == 'L' || number2[1] == 'M' || number2[1] == 'N' || number2[1] == 'Q' || number2[1] == 'R' || number2[1] == 'S' || number2[1] == 'T' || number2[1] == 'U' || number2[1] == 'V' || number2[1] == 'X' || number2[1] == 'Y' || number2[1] == 'Z'){
			if (number2[0] == '_'){
				for (j = 0; number2[j + 1] != '\0'; j++){
					number2[j] = number2[j + 1];
				}
				number2[j] = '\0';
				sign = 1;
				for (j = 0; number2[j] != '\0'; j++){
					if (number2[j] == '.'){
						number2[j] = '\0';
					}
				}
				var = processVariable(number2);
				if (var != 0){ ampl[n] = var; if (sign == 1){ sign = 0; ampl[n] = ampl[n] * -1; } }
			}
		}
		if (number2[0] == 'B' || number2[0] == 'O' || number2[0] == 'H'){
			ampl[n] = numericalSystems(number2);
		}
		if (number2[0] == '_' && (number2[1] == 'B' || number2[1] == 'O' || number2[1] == 'H')){
			for (j = 0; number2[j] != '\0'; j++){
				number2[j] = number2[j + 1];
			}
			ampl[n] = numericalSystems(number2)*-1;
		}
		j = 0;
		f = 0;
		char ex[DIM] = "";
		if (number2[0] == 'p'&&number2[1] == 'i'){
			ampl[n] = M_PI;
		}
		if (number2[0] == '_'&&number2[1] == 'p'&&number2[2] == 'i'){
			ampl[n] = (-1)*(M_PI);
		}
		if (number2[0] == 'e'){
			ampl[n] = M_E;
		}
		if (number2[0] == '_'&&number2[1] == 'e'){
			ampl[n] = (-1)*(M_E);
		}
		if (number2[0] == 'r'&&number2[1] == 'e'&&number2[2] == 's' || number2[0] == '['&&number2[1] == 'r'&&number2[2] == 'e'&&number2[3] == 's'){
			ampl[n] = result;
			amplI[n] = resultFI;
			complex = 2;
		}
		if (number2[0] == '_'&&number2[1] == 'r'&&number2[2] == 'e'&&number2[3] == 's' || number2[0] == '['&&number2[1] == '_'&&number2[2] == 'r'&&number2[3] == 'e'&&number2[4] == 's'){
			ampl[n] = result*(-1);
			amplI[n] = resultFI*-1;
			complex = 2;
		}
		if (facto > 0){
			if (ampl[n] < 0){
				number2[0] = '_';
			}
			while (facto > 0){
				ampl[n] = fact(abs(ampl[n]));
				facto--;
			}
			if (number2[0] == '_'){
				ampl[n] = ampl[n] * -1;
			}
		}
		while (trigon1[i] != '+'&&trigon1[i] != '-'&&trigon1[i] != '*'&&trigon1[i] != '/'&&trigon1[i] != '^'&&trigon1[i] != '='&&trigon1[i] != '\0'){ i++; }
		amp[n] = trigon1[i];
		if (complex == 1){
			amplI[n] = ampl[n];
			ampl[n] = 0;
			if (negImag == 1){
				negImag = 0;
				amplI[n] = amplI[n] * -1;
			}
		}
		else{
			if (complex != 2){
				amplI[n] = 0;
			}
		}
		n++;
		char number2[DIM] = "";
		char trigon1[] = "";
		res = 0;
	}

	int a = 0;
	int fr;
	so = 0;
	int ca = 0;
	double asdf = 0, asdfI = 0;
	for (so = 0; so < n; so++){
		int sa = so;
		int b = 0;
		if (amp[so] == '^'&&amp[so + 1] == '^'){
			while (amp[so] == '^'&&a != 1){
				if (amp[so + 1] != '^'&&amp[so - 1] == '^'&&a != 2){
					asdf = ampl[so + 1];
					asdfI = amplI[so + 1];
					if (ampl[so] < 0){
						sig[so] = 0;
					}
					else{ sig[so] = 1; }

					exponentiation(ampl[so], amplI[so], asdf, asdfI, sig[so]);
					asdf = resultR;
					asdfI = resultI;
					ampl[so + 1] = 0;
					ampl[so] = 1;
					amplI[so + 1] = 0;
					amplI[so] = 0;
					amp[so] = '+';
					so--;
					a = 2;
				}
				else{
					if (amp[so + 1] == '^'&&a == 0){
						so++;
						fr = so;
					}
					else{
						if (a == 2){
							while (a != 1){
								if (ampl[so] < 0 || amplI[so] < 0){
									sig[so] = 0;
								}
								else{ sig[so] = 1; }

								exponentiation(ampl[so], amplI[so], asdf, asdfI, sig[so]);
								asdf = resultR;
								asdfI = resultI;
								ampl[so] = 0;
								amplI[so] = 0;
								amp[so] = '+';
								so--;

								if (amp[so] != '^'){
									a = 1;
									so = fr++;
								}
							}
						}
					}


				}
				if (a == 1){
					ampl[sa] = asdf; a = 0;
					amplI[sa] = asdfI;
				}

			}
		}
		else{
			if (amp[so] == '^'&&amp[so + 1] != '^'){
				while (amp[so] == '^'){
					if (ampl[sa] < 0 || amplI[sa] < 0){
						sig[sa] = 0;
					}
					else{ sig[sa] = 1; }

					exponentiation(ampl[sa], amplI[sa], ampl[so + 1], amplI[so + 1], sig[sa]);
					ampl[sa] = resultR;
					amplI[sa] = resultI;
					ampl[so + 1] = 0;
					amplI[so + 1] = 0;
					amp[so] = '+';
					so++;
				}
			}
		}

	}
	for (so = 0; so < n; so++){
		int sa = so;

		while (amp[so] == '*'){
			multiplication(ampl[sa], amplI[sa], ampl[so + 1], amplI[so + 1]);
			ampl[sa] = resultR;
			amplI[sa] = resultI;
			ampl[so + 1] = 0;
			amplI[so + 1] = 0;
			amp[so] = '+';
			so++;
		}
		while (amp[so] == '/'){
			division(ampl[sa], amplI[sa], ampl[so + 1], amplI[so + 1]);
			ampl[sa] = resultR;
			amplI[sa] = resultI;
			ampl[so + 1] = 0;
			amplI[so + 1] = 0;
			amp[so] = '+';
			so++;
		}
	}
	for (h = 0; h < n; h++){
		if (h == 0){
			result1 = ampl[0];
			result2 = amplI[0];
		}
		if (amp[h] == '^'){
			exponentiation(result1, result2, ampl[h + 1], amplI[h + 1], 1);
			result1 = resultR;
			result2 = resultI;
		}
		if (amp[h] == '*'){
			multiplication(result1, result2, ampl[h + 1], amplI[h + 1]);
			result1 = resultR;
			result2 = resultI;
		}
		if (amp[h] == '/'){
			division(result1, result2, ampl[h + 1], amplI[h + 1]);
			result1 = resultR;
			result2 = resultI;
		}
		if (amp[h] == '-'){
			subtraction(result1, result2, ampl[h + 1], amplI[h + 1]);
			result1 = resultR;
			result2 = resultI;
		}
		if (amp[h] == '+'){
			sum(result1, result2, ampl[h + 1], amplI[h + 1]);
			result1 = resultR;
			result2 = resultI;
		}
	}
	resultR = result1;
	resultI = result2;
	round_complex();
	result1 = resultR;
	result2 = resultI;
	return result1;

}

double functionProcessor(char trigon[DIM], double result, double amplitude, double res){
	int i = 0, var = 0, j = 0, n = 0, count = 0, opt = 0, l = 0, p = 0, v1, va, cn = 0, s, rad = 1, jg = 1, gon = 0, tri = 0, co = 0, trigono = 0, paren = 1, pare = 0, parent = 0, e = 0, f = 0, kl = 0, ar = 0, deg = 0, type = 0;
	char trig[DIM] = "0", base[DIM], number[DIM] = "0", number1[DIM] = "0", number2[DIM] = "0", op[DIM] = "0", signal = '*', numb[DIM] = "0", sig = '0', point = '0', cieNot[DIM] = "0", arg[DIM] = "0", amp[DIM] = "0", trigon1[DIM] = "0", ex[DIM] = "", eX[DIM] = "", trig1[DIM] = "", function[DIM] = "cos,acos,sin,asin,tan,atan,sec,asec,cosec,acosec,cotan,acotan,log,ln,rest,quotient,sqrt,cbrt,afact,cosh,acosh,sinh,asinh,tanh,atanh,sech,asech,cosech,acosech,cotanh,acotanh,sinc,gerror,gerrorinv,gerrorc,gerrorcinv,qfunc,qfuncinv,cbrt,sqrt";
	double num = 0, v[DIM], vI[DIM], argu[DIM], ampl[DIM], exp = 1, result1 = 0, baLog = 0, dgrt = 0, result2 = resultI, dgrt2 = 0;

	for (i = 0; trigon[i] != '\0'; i++){
		if (trigon[i] == '?'){
			var = 1;
			trigon[i] = '\0';
			break;
		}
	}


	v[0] = 0; v[1] = 0; v[7] = 0;
	if (trigon[0] == '_'){
		jg = -1;
		for (s = 0; trigon[s] != '\0'; s++){
			trigon[s] = trigon[s + 1];
		}
	}
	if (Mode == 0){
		opt = applySettings(4);
		if (opt == 3){
			deg = 0;
			rad = 0;
			gon = 1;
		}
		if (opt == 2){
			deg = 1;
			rad = 0;
			gon = 0;
		}
		if (opt == 1){
			rad = 1;
			deg = 0;
			gon = 0;
		}
	}
	for (s = 0; s < DIM; s++){
		v[s] = 0;
		argu[s] = 0;
		ampl[s] = 0;
	}
	v[0] = amplitude;
	v[1] = result;
	vI[0] = resultR;
	vI[1] = resultI;
	result = 0;
	op[0] = '0';
	if (trigon[0] == 'r'&&trigon[1] == 'a'&&trigon[2] == 'd'){
		rad = 1;
		deg = 0;
		gon = 0;
		for (s = 0; trigon[s] != '\0'; s++){
			trigon[s] = trigon[s + 3];
		}
		trigon[s] = '\0';
	}
	if (trigon[0] == 'd'&&trigon[1] == 'e'&&trigon[2] == 'g'){
		deg = 1;
		rad = 0;
		gon = 0;
		for (s = 0; trigon[s] != '\0'; s++){
			trigon[s] = trigon[s + 3];
		}
		trigon[s] = '\0';
	}
	if (trigon[0] == 'g'&&trigon[1] == 'o'&&trigon[2] == 'n'){
		gon = 1;
		deg = 0;
		rad = 0;
		for (s = 0; trigon[s] != '\0'; s++){
			trigon[s] = trigon[s + 3];
		}
		trigon[s] = '\0';
	}
	if (var == 1){
		if ((trigon[0] == 'r'&&trigon[1] == 't'&&trigon[2] == 'D'&&trigon[3] == 'D'&&trigon[4] == '\0') || (trigon[0] == 'l'&&trigon[1] == 'o'&&trigon[2] == 'g'&&trigon[3] == 'b'&&trigon[4] == 'b'&&trigon[5] == '\0')){
			return 0.5;
		}
		for (i = 0; function[i] != '\0'; i++){
			j = 0;
			if (function[i] == trigon[j]){
				j = 0;
				while (function[i] != '\0'&&function[i] != ','){
					if (function[i] == trigon[j]){
						j++;
					}
					i++;
				}
				if (j == strlen(trigon)){
					return 0.5;
				}
			}
		}
	}
	i = 0; j = 0;
	for (s = 0; trigon[s] != '\0'; s++){
		if ((trigon[s] == 'b'&&trigon[s - 1] != 'c') || trigon[s] == 'D'){
			j = s;
			s++;
			while ((trigon[s] == 'b'&&trigon[s + 1] == '\0') == false && (trigon[s] == 'D'&&trigon[s + 1] == '\0') == false && trigon[s] != '\0'){
				base[i] = trigon[s];
				i++; s++;
			}
			base[i] = '\0';
			baLog = initialProcessor(base, res);
			dgrt = baLog;
			dgrt2 = resultI;
			trigon[j] = '\0';
		}

	}i = 0; j = 0;
	n = 0;
	for (i; i < trigon[i] != '\0'&&trigon[i] != '('; i++){
		if (trigon[i] == 'r'&&trigon[i + 1] == 'e'&&trigon[i + 2] == 's'&&trigon[i + 3] != 't'){
			i = i + 3;
		}
		if (trigon[i] == 'l' || trigon[i] == 'f' || trigon[i] == 'v' || trigon[i] == 'h' || trigon[i] == 't' || trigon[i] == 'e'&&trigon[i + 1] != '='&&trigon[i + 1] != '^' || trigon[i + 1] == 's' || trigon[i] == 'c' || trigon[i] == 'a' || trigon[i] == 'i' || trigon[i] == 'n' || trigon[i] == 's' || trigon[i] == 'o' || trigon[i] == 'r' || trigon[i] == 'g' || trigon[i] == '=' || trigon[i] == 'q' || trigon[i] == 'u' || trigon[i] == 'b'){
			if (n == 0){
				va = i;
			}
			op[n] = trigon[i];
			n++;
			va++;
		}
	}
	if (op[n - 1] == 'e'){
		op[n - 1] = '\0';
		va--;
	}
	va--;
	v1 = va;
	int h = 0;
	for (i = 0; op[i] != '\0'; i++){
		if (op[i] == 'h'){
			h = 1;
		}
	}
	if (op[i - 1] == 't'&&op[i - 2] == 'c'&&op[i - 3] == 'a'&&op[i - 4] == 'f'){
		h = 1;
	}
	if (h == 0 && op[0] != 'a'){
		if (rad == 1){
			v[7] = ((v[1] * 180) / M_PI);
			if (v[7] < 0){
				v[7] = re(v[7], -360);
			}
			else{
				if (v[7] >= 0){
					v[7] = re(v[7], 360);
				}
			}

			vI[7] = ((vI[1] * 180) / M_PI);
			if (vI[7] < 0){
				vI[7] = re(vI[7], -360);
			}
			else{
				if (vI[7] >= 0){
					vI[7] = re(vI[7], 360);
				}
			}

		}
		if (deg == 1){
			v[7] = v[1];
			if (v[7] < 0){
				v[7] = re(v[7], -360);
			}
			else{
				if (v[7] >= 0){
					v[7] = re(v[7], 360);
				}
			}

			vI[7] = vI[1];
			if (vI[7] < 0){
				vI[7] = re(vI[7], -360);
			}
			else{
				if (vI[7] >= 0){
					vI[7] = re(vI[7], 360);
				}

			}
		}
		if (gon == 1){
			v[7] = v[1] * 0.9;
			if (v[7] < 0){
				v[7] = re(v[7], -360);
			}
			else{
				if (v[7] >= 0){
					v[7] = re(v[7], 360);
				}
			}

			vI[7] = vI[1] * 0.9;
			if (vI[7] < 0){
				vI[7] = re(vI[7], -360);
			}
			else{
				if (vI[7] >= 0){
					vI[7] = re(vI[7], 360);
				}
			}
		}
	}
	if (op[0] == 'l'&&op[1] == 'o'&&op[2] == 'g'&&op[3] == '\0'){
		if (dgrt != 0 || dgrt2 != 0){
			complex_log(dgrt, dgrt2);
			double baR = resultR, baI = resultI;
			complex_log(v[1], result2);
			division(resultR, resultI, baR, baI);
			result1 = resultR;
			result2 = resultI;
		}
		else{
			complex_log(10.0, 0);
			double baR = resultR, baI = resultI;
			complex_log(v[1], result2);
			division(resultR, resultI, baR, baI);
			result1 = resultR;
			result2 = resultI;
		}
	}

	if (op[0] == 'r'&&op[1] == 't'&&op[2] == '\0'){
		division(1, 0.0, dgrt, dgrt2);
		exponentiation(v[1], result2, resultR, resultI, 1);
		result1 = resultR;
		result2 = resultI;
	}
	if (op[0] == 's'&&op[1] == 'q'&&op[2] == 'r'&&op[3] == 't'&&op[4] == '\0'){
		exponentiation(v[1], result2, 1 / 2.0, 0, 1);
		result1 = resultR;
		result2 = resultI;
	}
	if (op[0] == 'c'&&op[1] == 'b'&&op[2] == 'r'&&op[3] == 't'&&op[4] == '\0'){
		exponentiation(v[1], result2, 1 / 3.0, 0, 1);
		result1 = resultR;
		result2 = resultI;
	}

	if (op[0] == 'l'&&op[1] == 'n'&&op[2] == '\0'){
		complex_log(v[1], result2);
		result1 = resultR;
		result2 = resultI;
	}
	if ((op[0] == 'c'&&op[1] == 'o'&&op[2] == 's'&&op[3] == 'e'&&op[4] == 'c'&&op[5] == '\0') || (op[0] == 'c'&&op[1] == 's'&&op[2] == 'c'&&op[3] == '\0')){
		if (deg == 1){
			v[1] = ((v[1] * M_PI) / 180);
			vI[1] = ((vI[1] * M_PI) / 180);
		}
		if (gon == 1){
			v[1] = v[1] * (M_PI / 200);
			vI[1] = vI[1] * (M_PI / 200);
		}
		cosec(v[1], vI[1]);
		result1 = resultR;
		result2 = resultI;
	}
	if ((op[0] == 'c'&&op[1] == 'o'&&op[2] == 's'&&op[3] == 'e'&&op[4] == 'c'&&op[5] == 'h'&&op[6] == '\0') || (op[0] == 'c'&&op[1] == 's'&&op[2] == 'c'&&op[3] == 'h')){
		cosech(v[1], vI[1]);
		result1 = resultR;
		result2 = resultI;
	}

	if (op[0] == 's'&&op[1] == 'e'&&op[2] == 'c'&&op[3] == '\0'){
		if (deg == 1){
			v[1] = ((v[1] * M_PI) / 180);
			vI[1] = ((vI[1] * M_PI) / 180);
		}
		if (gon == 1){
			v[1] = v[1] * (M_PI / 200);
			vI[1] = vI[1] * (M_PI / 200);

		}
		sec(v[1], vI[1]);
		result1 = resultR;
		result2 = resultI;
	}
	if (op[0] == 's'&&op[1] == 'e'&&op[2] == 'c'&&op[3] == 'h'&&op[4] == '\0'){
		sech(v[1], vI[1]);
		result1 = resultR;
		result2 = resultI;
	}

	if ((op[0] == 'c'&&op[1] == 'o'&&op[2] == 't'&&op[3] == 'g'&&op[4] == '\0') || (op[0] == 'c'&&op[1] == 'o'&&op[2] == 't'&&op[3] == 'a'&&op[4] == 'n'&&op[5] == '\0') || (op[0] == 'c'&&op[1] == 't'&&op[2] == 'g'&&op[3] == '\0')){
		if (deg == 1){
			v[1] = ((v[1] * M_PI) / 180);
			vI[1] = ((vI[1] * M_PI) / 180);
		}
		if (gon == 1){
			v[1] = v[1] * (M_PI / 200);
			vI[1] = vI[1] * (M_PI / 200);
		}
		cotan(v[1], vI[1]);
		result1 = resultR;
		result2 = resultI;
	}
	if ((op[0] == 'c'&&op[1] == 'o'&&op[2] == 't'&&op[3] == 'g'&&op[4] == 'h'&&op[5] == '\0') || (op[0] == 'c'&&op[1] == 'o'&&op[2] == 't'&&op[3] == 'a'&&op[4] == 'n'&&op[5] == 'h'&&op[6] == '\0') || (op[0] == 'c'&&op[1] == 't'&&op[2] == 'g'&&op[3] == 'h'&&op[4] == '\0')){
		cotanh(v[1], vI[1]);
		result1 = resultR;
		result2 = resultI;
	}
	if ((op[0] == 'a'&&op[1] == 'c'&&op[2] == 'o'&&op[3] == 's'&&op[4] == '\0') || (op[0] == 'a'&&op[1] == 'r'&&op[2] == 'c'&&op[3] == 'o'&&op[4] == 's'&&op[5] == '\0')){
		complex_acos(v[1], vI[1]);
		result1 = resultR;
		result2 = resultI;
	}
	if ((op[0] == 'a'&&op[1] == 's'&&op[2] == 'i'&&op[3] == 'n'&&op[4] == '\0') || (op[0] == 'a'&&op[1] == 'r'&&op[2] == 'c'&&op[3] == 's'&&op[4] == 'e'&&op[5] == 'n'&&op[6] == '\0') || (op[0] == 'a'&&op[1] == 'r'&&op[2] == 'c'&&op[3] == 's'&&op[4] == 'i'&&op[5] == 'n'&&op[6] == '\0') || (op[0] == 'a'&&op[1] == 's'&&op[2] == 'e'&&op[3] == 'n'&&op[4] == '\0')){
		complex_asin(v[1], vI[1]);
		result1 = resultR;
		result2 = resultI;
	}
	if ((op[0] == 'a'&&op[1] == 't'&&op[2] == 'a'&&op[3] == 'n'&&op[4] == '\0') || (op[0] == 'a'&&op[1] == 'r'&&op[2] == 'c'&&op[3] == 't'&&op[4] == 'a'&&op[5] == 'n'&&op[6] == '\0') || (op[0] == 'a'&&op[1] == 'r'&&op[2] == 'c'&&op[3] == 't'&&op[4] == 'g'&&op[5] == '\0') || (op[0] == 'a'&&op[1] == 't'&&op[2] == 'g'&&op[3] == '\0')){
		complex_atan(v[1], vI[1]);
		result1 = resultR;
		result2 = resultI;
	}
	if (op[0] == 'c'&&op[1] == 'o'&&op[2] == 's'&&op[3] == '\0'){
		if (deg == 1){
			v[1] = ((v[1] * M_PI) / 180);
			vI[1] = ((vI[1] * M_PI) / 180);
		}
		if (gon == 1){
			v[1] = v[1] * (M_PI / 200);
			vI[1] = vI[1] * (M_PI / 200);
		}
		complex_cos(v[1], vI[1]);
		result1 = resultR;
		result2 = resultI;
		if (v[7] == 270 || v[7] == 90 || v[7] == -90 || v[7] == -270){
			result1 = v[0] * sqrt(1 - (sin(v[1])*sin(v[1])));
		}
	}
	if (op[0] == 'c'&&op[1] == 'o'&&op[2] == 's'&&op[3] == 'h'&&op[4] == '\0'){
		complex_cosh(v[1], vI[1]);
		result1 = resultR;
		result2 = resultI;
	}
	if ((op[0] == 's'&&op[1] == 'i'&&op[2] == 'n'&&op[3] == '\0') || (op[0] == 's'&&op[1] == 'e'&&op[2] == 'n'&&op[3] == '\0')){
		if (deg == 1){
			v[1] = ((v[1] * M_PI) / 180);
			vI[1] = ((vI[1] * M_PI) / 180);
		}
		if (gon == 1){
			v[1] = v[1] * (M_PI / 200);
			vI[1] = vI[1] * (M_PI / 200);
		}
		complex_sin(v[1], vI[1]);
		result1 = resultR;
		result2 = resultI;
		if ((v[7] == 180 || v[7] == 0 || v[7] == -180) && vI[7] == 0){
			result1 = v[0] * sqrt(1 - (cos(v[1])*cos(v[1])));
		}
	}

	if ((op[0] == 's'&&op[1] == 'i'&&op[2] == 'n'&&op[3] == 'h'&&op[4] == '\0') || (op[0] == 's'&&op[1] == 'e'&&op[2] == 'n'&&op[3] == 'h'&&op[4] == '\0')){
		complex_sinh(v[1], vI[1]);
		result1 = resultR;
		result2 = resultI;
	}
	if (op[0] == 's'&&op[1] == 'i'&&op[2] == 'n'&&op[3] == 'c'&&op[4] == '\0'){
		sinc(v[1], vI[1]);
		result1 = resultR;
		result2 = resultI;
	}

	if ((op[0] == 't'&&op[1] == 'a'&&op[2] == 'n'&&op[3] == '\0') || (op[0] == 't'&&op[1] == 'g'&&op[2] == '\0')){
		if (deg == 1){
			v[1] = ((v[1] * M_PI) / 180);
			vI[1] = ((vI[1] * M_PI) / 180);
		}
		if (gon == 1){
			v[1] = v[1] * (M_PI / 200);
			vI[1] = vI[1] * (M_PI / 200);
		}
		complex_tan(v[1], vI[1]);
		result1 = resultR;
		result2 = resultI;
		if ((v[7] == 90 || v[7] == -90 || v[7] == 270 || v[7] == -270 || v[7] == 0 || v[7] == 180 || v[7] == -180)&vI[7] == 0){
			result1 = v[0] * (sqrt(1 - cos(v[1])*cos(v[1])) / sqrt(1 - sin(v[1])*sin(v[1])));
		}
	}
	if ((op[0] == 't'&&op[1] == 'a'&&op[2] == 'n'&&op[3] == 'h'&&op[4] == '\0') || (op[0] == 't'&&op[1] == 'g'&&op[2] == 'h'&&op[3] == '\0')){
		complex_tanh(v[1], vI[1]);
		result1 = resultR;
		result2 = resultI;
		type = 1;
	}
	if ((op[0] == 'a'&&op[1] == 's'&&op[2] == 'i'&&op[3] == 'n'&&op[4] == 'h'&&op[5] == '\0') || (op[0] == 'a'&&op[1] == 'r'&&op[2] == 's'&&op[3] == 'i'&&op[4] == 'n'&&op[5] == 'h'&&op[6] == '\0') || (op[0] == 'a'&&op[1] == 'r'&&op[2] == 'c'&&op[3] == 's'&&op[4] == 'i'&&op[5] == 'n'&&op[6] == 'h'&&op[7] == '\0') || (op[0] == 'a'&&op[1] == 'r'&&op[2] == 'c'&&op[3] == 's'&&op[4] == 'e'&&op[5] == 'n'&&op[6] == 'h'&&op[7] == '\0')){
		arsinh(v[1], vI[1]);
		result1 = resultR;
		result2 = resultI;
		type = 1;
	}
	if ((op[0] == 'a'&&op[1] == 'c'&&op[2] == 'o'&&op[3] == 's'&&op[4] == 'h'&&op[5] == '\0') || (op[0] == 'a'&&op[1] == 'r'&&op[2] == 'c'&&op[3] == 'o'&&op[4] == 's'&&op[5] == 'h'&&op[6] == '\0') || (op[0] == 'a'&&op[1] == 'r'&&op[2] == 'c'&&op[3] == 'o'&&op[4] == 's'&&op[5] == 'h'&&op[6] == '\0')){
		arcosh(v[1], vI[1]);
		result1 = resultR;
		result2 = resultI;
		type = 1;
	}
	if ((op[0] == 'a'&&op[1] == 't'&&op[2] == 'a'&&op[3] == 'n'&&op[4] == 'h'&&op[5] == '\0') || (op[0] == 'a'&&op[1] == 'r'&&op[2] == 'c'&&op[3] == 't'&&op[4] == 'g'&&op[5] == 'h'&&op[6] == '\0') || (op[0] == 'a'&&op[1] == 'r'&&op[2] == 't'&&op[3] == 'a'&&op[4] == 'n'&&op[5] == 'h'&&op[6] == '\0') || (op[0] == 'a'&&op[1] == 'r'&&op[2] == 'c'&&op[3] == 't'&&op[4] == 'a'&&op[5] == 'n'&&op[6] == 'h'&&op[7] == '\0')){
		artanh(v[1], vI[1]);
		result1 = resultR;
		result2 = resultI;
		type = 1;
	}
	if ((op[0] == 'a'&&op[1] == 'c'&&op[2] == 'o'&&op[3] == 't'&&op[4] == 'a'&&op[5] == 'n'&&op[6] == 'h'&&op[7] == '\0') || (op[0] == 'a'&&op[1] == 'c'&&op[2] == 'o'&&op[3] == 't'&&op[4] == 'h'&&op[5] == '\0') || (op[0] == 'a'&&op[1] == 'r'&&op[2] == 'c'&&op[3] == 'o'&&op[4] == 't'&&op[5] == 'h'&&op[6] == '\0') || (op[0] == 'a'&&op[1] == 'r'&&op[2] == 'c'&&op[3] == 'o'&&op[4] == 't'&&op[5] == 'g'&&op[6] == 'h'&&op[7] == '\0') || (op[0] == 'a'&&op[1] == 'r'&&op[2] == 'c'&&op[3] == 'o'&&op[4] == 't'&&op[5] == 'a'&&op[6] == 'n'&&op[7] == 'h'&&op[8] == '\0')){
		arcoth(v[1], vI[1]);
		result1 = resultR;
		result2 = resultI;
		type = 1;
	}
	if ((op[0] == 'a'&&op[1] == 's'&&op[2] == 'e'&&op[3] == 'c'&&op[4] == 'h'&&op[5] == '\0') || (op[0] == 'a'&&op[1] == 'r'&&op[2] == 's'&&op[3] == 'e'&&op[4] == 'c'&&op[5] == 'h'&&op[6] == '\0') || (op[0] == 'a'&&op[1] == 'r'&&op[2] == 'c'&&op[3] == 's'&&op[4] == 'e'&&op[5] == 'c'&&op[6] == 'h'&&op[7] == '\0')){
		arsech(v[1], vI[1]);
		result1 = resultR;
		result2 = resultI;
		type = 1;
	}
	if ((op[0] == 'a'&&op[1] == 'c'&&op[2] == 'o'&&op[3] == 's'&&op[4] == 'e'&&op[5] == 'c'&&op[6] == 'h'&&op[7] == '\0') || (op[0] == 'a'&&op[1] == 'c'&&op[2] == 's'&&op[3] == 'c'&&op[4] == 'h'&&op[5] == '\0') || (op[0] == 'a'&&op[1] == 'r'&&op[2] == 'c'&&op[3] == 's'&&op[4] == 'c'&&op[5] == 'h'&&op[6] == '\0') || (op[0] == 'a'&&op[1] == 'r'&&op[2] == 'c'&&op[3] == 'o'&&op[4] == 's'&&op[5] == 'e'&&op[6] == 'c'&&op[7] == 'h'&&op[8] == '\0')){
		arcsch(v[1], vI[1]);
		result1 = resultR;
		result2 = resultI;
		type = 1;
	}
	if (op[0] == 'q'&&op[1] == 'u'&&op[2] == 'o'&&op[3] == 't'&&op[4] == 'i'&&op[5] == 'e'&&op[6] == 'n'&&op[7] == 't'&&op[8] == '\0'){
		qu_complex(v[0], vI[0], v[1], vI[1]);
		result1 = resultR;
		result2 = resultI;
	}
	if (op[0] == 'r'&&op[1] == 'e'&&op[2] == 's'&&op[3] == 't'&&op[4] == '\0'){
		re_complex(v[0], vI[0], v[1], vI[1]);
		result1 = resultR;
		result2 = resultI;
	}
	if ((op[0] == 'a'&&op[1] == 'c'&&op[2] == 'o'&&op[3] == 's'&&op[4] == 'e'&&op[5] == 'c'&&op[6] == '\0') || (op[0] == 'a'&&op[1] == 'r'&&op[2] == 'c'&&op[3] == 'o'&&op[4] == 's'&&op[5] == 'e'&&op[6] == 'c'&&op[7] == '\0') || (op[0] == 'a'&&op[1] == 'r'&&op[2] == 'c'&&op[3] == 's'&&op[4] == 'c'&&op[5] == '\0') || (op[0] == 'a'&&op[1] == 'c'&&op[2] == 's'&&op[3] == 'c'&&op[4] == '\0')){
		arcosec(v[1], vI[1]);
		result1 = resultR;
		result2 = resultI;
	}
	if ((op[0] == 'a'&&op[1] == 's'&&op[2] == 'e'&&op[3] == 'c'&&op[4] == '\0') || (op[0] == 'a'&&op[1] == 'r'&&op[2] == 'c'&&op[3] == 's'&&op[4] == 'e'&&op[5] == 'c'&&op[6] == '\0') || (op[0] == 'a'&&op[1] == 's'&&op[2] == 'c'&&op[3] == '\0')){
		arcsec(v[1], vI[1]);
		result1 = resultR;
		result2 = resultI;
	}
	if ((op[0] == 'a'&&op[1] == 'c'&&op[2] == 'o'&&op[3] == 't'&&op[4] == 'a'&&op[5] == 'n'&&op[6] == '\0') || (op[0] == 'a'&&op[1] == 'r'&&op[2] == 'c'&&op[3] == 'o'&&op[4] == 't'&&op[5] == 'g'&&op[6] == '\0') || (op[0] == 'a'&&op[1] == 'c'&&op[2] == 't'&&op[3] == 'g'&&op[4] == '\0') || (op[0] == 'a'&&op[1] == 'r'&&op[2] == 'c'&&op[3] == 'o'&&op[4] == 't'&&op[5] == 'a'&&op[6] == 'n'&&op[7] == '\0')){
		arcotg(v[1], vI[1]);
		result1 = resultR;
		result2 = resultI;
	}
	if (op[0] == 'q'&&op[1] == 'f'&&op[2] == 'u'&&op[3] == 'n'&&op[4] == 'c'&&op[5] == '\0'){
		result1 = v[0] * qfunc(v[1]);
	}
	if (op[0] == 'q'&&op[1] == 'f'&&op[2] == 'u'&&op[3] == 'n'&&op[4] == 'c'&&op[5] == 'i'&&op[6] == 'n'&&op[7] == 'v'&&op[8] == '\0'){
		result1 = v[0] * qfuncinv(v[1]);
	}
	if (op[0] == 'g'&&op[1] == 'e'&&op[2] == 'r'&&op[3] == 'r'&&op[4] == 'o'&&op[5] == 'r'&&op[6] == '\0'){
		result1 = v[0] * gerror(v[1]);
	}
	if (op[0] == 'g'&&op[1] == 'e'&&op[2] == 'r'&&op[3] == 'r'&&op[4] == 'o'&&op[5] == 'r'&&op[6] == 'c'&&op[7] == '\0'){
		result1 = v[0] * gerrorc(v[1]);
	}
	if (op[0] == 'g'&&op[1] == 'e'&&op[2] == 'r'&&op[3] == 'r'&&op[4] == 'o'&&op[5] == 'r'&&op[6] == 'i'&&op[7] == 'n'&&op[8] == 'v'&&op[9] == '\0'){
		result1 = v[0] * gerrorinv(v[1]);
	}
	if (op[0] == 'g'&&op[1] == 'e'&&op[2] == 'r'&&op[3] == 'r'&&op[4] == 'o'&&op[5] == 'r'&&op[6] == 'c'&&op[7] == 'i'&&op[8] == 'n'&&op[9] == 'v'&&op[10] == '\0'){
		result1 = v[0] * gerrorcinv(v[1]);
	}
	if (op[0] == 'a'&&op[1] == 'r'&&op[2] == 'c'&&op[3] == 'f'&&op[4] == 'a'&&op[5] == 'c'&&op[6] == 't'&&op[7] == '\0' || op[0] == 'a'&&op[1] == 'f'&&op[2] == 'a'&&op[3] == 'c'&&op[4] == 't'&&op[5] == '\0'){
		result1 = v[0] * arcfact(v[1]);
		type = 1;
	}
	if (op[0] == 's'&&op[1] == 'o'&&op[2] == 'l'&&op[3] == 'v'&&op[4] == 'i'&&op[5] == 'n'&&op[6] == 't'&&op[7] == '\0'){
		result1 = v[0] * solvint(res);
	}


	if (op[0] == 'a'&&type == 0){
		if (deg == 1){
			result1 = ((result1 * 180) / M_PI);
			result2 = ((result2 * 180) / M_PI);
		}
		if (gon == 1){
			result1 = result1*(200 / M_PI);
			result2 = result2*(200 / M_PI);
		}
	}
	char trigon[DIM] = "";
	result1 = result1*jg;
	resultR = result1;
	resultI = result2;
	round_complex();
	return result1;
}

void cotan(double x, double y){
	complex_tan(x, y);
	division(1.0, 0.0, resultR, resultI);
	round_complex();
}

void sec(double x, double y){
	complex_cos(x, y);
	division(1.0, 0.0, resultR, resultI);
	round_complex();
}

void cosec(double x, double y){
	resultR = 0; resultI = 0;
	complex_sin(x, y);
	division(1.0, 0.0, resultR, resultI);
	round_complex();
}

void cotanh(double x, double y){
	complex_tanh(x, y);
	division(1.0, 0.0, resultR, resultI);
	round_complex();
}

void sech(double x, double y){
	complex_cosh(x, y);
	division(1.0, 0.0, resultR, resultI);
	round_complex();
}

void cosech(double x, double y){
	resultR = 0; resultI = 0;
	complex_sinh(x, y);
	division(1.0, 0.0, resultR, resultI);
	round_complex();
}

void sinc(double x, double y){
	resultR = 0; resultI = 0;
	if (x != 0 || y != 0){
		complex_sin(M_PI*x, M_PI*y);
		division(resultR, resultI, M_PI*x, M_PI*y);
	}
	else{
		resultR = 1.0; resultI = 0;
	}
	round_complex();
}

double gerrorc(double q){
	double result = 0;
	result = boost::math::erfc(q);
	return result;
}

double gerrorcinv(double a){
	double result = 0;
	if (a <= 2 && a >= 0){
		if (a == 0){ result = pow(2.0, 2000); return result; }
		result = boost::math::erfc_inv(a);
	}
	else{
		result = 0;
	}
	return result;
}

double gerror(double q){
	double result = 0;
	result = boost::math::erf(q);
	return result;
}

double gerrorinv(double e){
	double result = 0;
	if (e <= 1 && e >= -1){
		if (e == 1){ result = pow(2.0, 2000); return result; }
		if (e == -1){ result = -pow(2.0, 2000); return result; }
		result = boost::math::erf_inv(e);
	}
	else{
		result = 0;
	}
	return result;
}

double qfunc(double x){
	double result = 0, y = 0;
	y = x / sqrt(2.0);
	result = 0.5*gerrorc(y);
	return result;
}

double qfuncinv(double p){
	double result = 0, d = 0;
	d = p / 0.5;
	result = sqrt(2.0)*gerrorcinv(d);
	return result;
}

double ln(double z){
	double result1 = 0;
	result1 = log10(z) / log10(M_E);
	return result1;
}

void arsinh(double x, double y){
	resultR = 0; resultI = 0;
	double radicandR = pot(x, 2.0, 1) - pot(y, 2.0, 1) + 1;
	double radicandI = 2 * x*y;
	exponentiation(radicandR, radicandI, 1 / 2.0, 0.0, 1);
	sum(x, y, resultR, resultI);
	complex_log(resultR, resultI);
	round_complex();
}

void arcosh(double x, double y){
	resultR = 0; resultI = 0;
	if (x >= 1 || y >= 1){
		double radicandR = pot(x, 2.0, 1) - pot(y, 2.0, 1) - 1;
		double radicandI = 2 * x*y;
		exponentiation(radicandR, radicandI, 1 / 2.0, 0.0, 1);
		sum(x, y, resultR, resultI);
		complex_log(resultR, resultI);
	}
	round_complex();
}

void artanh(double x, double y){
	resultR = 0; resultI = 0;
	if (abs(x) < 1 || abs(y) < 1){
		double numR = 1 + x, numI = y;
		double denR = 1 - x, denI = -1 * y;
		division(numR, numI, denR, denI);
		complex_log(resultR, resultI);
		multiplication(1 / 2.0, 0.0, resultR, resultI);
	}
	round_complex();
}

void arcoth(double x, double y){
	resultR = 0; resultI = 0;
	if (abs(x) > 1 || abs(y) > 1){
		division(1.0, 0.0, x, y);
		artanh(resultR, resultI);
	}
	round_complex();
}

void arsech(double x, double y){
	resultR = 0; resultI = 0;
	if (x > 0 && x <= 1 || y > 0 && y <= 1){
		division(1.0, 0.0, x, y);
		arcosh(resultR, resultI);
	}
	round_complex();
}

void arcsch(double x, double y){
	resultR = 0; resultI = 0;
	if (x != 0 || y != 0){
		division(1.0, 0.0, x, y);
		arsinh(resultR, resultI);
	}
	round_complex();
}

void arcosec(double x, double y){
	resultR = 0; resultI = 0;
	division(1.0, 0.0, x, y);
	complex_asin(resultR, resultI);
	round_complex();
}

void arcsec(double x, double y){
	resultR = 0; resultI = 0;
	division(1.0, 0.0, x, y);
	complex_acos(resultR, resultI);
	round_complex();
}

void arcotg(double x, double y){
	resultR = 0; resultI = 0;
	division(1.0, 0.0, x, y);
	complex_atan(resultR, resultI);
	round_complex();
}

void Clock(int a)
{
	FILE *fout;
	int s = 0, m = 0, h = 0, d = 0, days = 0, seconds, minutes, hours, years, day = 0, initialTime = 0, dayss = 0, ho = 0, mi = 0, se = 0, signal = -1, Time = 0;
	time_t hour;
	time(&hour);
	char *tim;
	tim = ctime(&hour);
	tim[24] = '\0';
	fout = fopen("history.txt", "a+");
	char min[3] = { tim[14], tim[15], '\0' };
	minutes = atoi(min);
	char hou[3] = { tim[11], tim[12], '\0' };
	hours = atoi(hou);
	char yea[5] = { tim[20], tim[21], tim[22], tim[23], '\0' };
	years = atoi(yea);
	char da[3] = { tim[8], tim[9], '\0' };
	days = atoi(da);
	if (tim[0] == 'M'&&tim[1] == 'o'&&tim[2] == 'n'){
		if (a == 0){
			fprintf(fout, "Monday, ");
		}
		if (a == 1){
			printf("Monday, ");
		}
	}
	if (tim[0] == 'T'&&tim[1] == 'u'&&tim[2] == 'e'){
		if (a == 0){
			fprintf(fout, "Tuesday, ");
		}
		if (a == 1){
			printf("Tuesday, ");
		}
	}
	if (tim[0] == 'W'&&tim[1] == 'e'&&tim[2] == 'd'){
		if (a == 0){
			fprintf(fout, "Wednesday, ");
		}
		if (a == 1){
			printf("Wednesday, ");
		}
	}
	if (tim[0] == 'T'&&tim[1] == 'h'&&tim[2] == 'u'){
		if (a == 0){
			fprintf(fout, "Thursday, ");
		}
		if (a == 1){
			printf("Thursday, ");
		}
	}
	if (tim[0] == 'F'&&tim[1] == 'r'&&tim[2] == 'i'){
		if (a == 0){
			fprintf(fout, "Friday, ");
		}
		if (a == 1){
			printf("Friday, ");
		}
	}
	if (tim[0] == 'S'&&tim[1] == 'a'&&tim[2] == 't'){
		if (a == 0){
			fprintf(fout, "Saturday, ");
		}
		if (a == 1){
			printf("Saturday, ");
		}
	}
	if (tim[0] == 'S'&&tim[1] == 'u'&&tim[2] == 'n'){
		if (a == 0){
			fprintf(fout, "Sunday, ");
		}
		if (a == 1){
			printf("Sunday, ");
		}
	}
	if (tim[4] == 'J'&&tim[5] == 'a'&&tim[6] == 'n'){
		if (a == 0){
			fprintf(fout, "January");
		}
		if (a == 1){
			printf("January");
		}
	}
	if (tim[4] == 'F'&&tim[5] == 'e'&&tim[6] == 'b'){
		if (a == 0){
			fprintf(fout, "February");
		}
		if (a == 1){
			printf("February");
		}
	}
	if (tim[4] == 'M'&&tim[5] == 'a'&&tim[6] == 'r'){
		if (a == 0){
			fprintf(fout, "March");
		}
		if (a == 1){
			printf("March");
		}
	}
	if (tim[4] == 'A'&&tim[5] == 'p'&&tim[6] == 'r'){
		if (a == 0){
			fprintf(fout, "April");
		}
		if (a == 1){
			printf("April");
		}
	}
	if (tim[4] == 'M'&&tim[5] == 'a'&&tim[6] == 'y'){
		if (a == 0){
			fprintf(fout, "May");
		}
		if (a == 1){
			printf("May");
		}
	}
	if (tim[4] == 'J'&&tim[5] == 'u'&&tim[6] == 'n'){
		if (a == 0){
			fprintf(fout, "June");
		}
		if (a == 1){
			printf("June");
		}
	}
	if (tim[4] == 'J'&&tim[5] == 'u'&&tim[6] == 'l'){
		if (a == 0){
			fprintf(fout, "July");
		}
		if (a == 1){
			printf("July");
		}
	}
	if (tim[4] == 'A'&&tim[5] == 'u'&&tim[6] == 'g'){
		if (a == 0){
			fprintf(fout, "August");
		}
		if (a == 1){
			printf("August");
		}
	}
	if (tim[4] == 'S'&&tim[5] == 'e'&&tim[6] == 'p'){
		if (a == 0){
			fprintf(fout, "September");
		}
		if (a == 1){
			printf("September");
		}
	}
	if (tim[4] == 'O'&&tim[5] == 'c'&&tim[6] == 't'){
		if (a == 0){
			fprintf(fout, "October");
		}
		if (a == 1){
			printf("October");
		}
	}
	if (tim[4] == 'N'&&tim[5] == 'o'&&tim[6] == 'v'){
		if (a == 0){
			fprintf(fout, "November");
		}
		if (a == 1){
			printf("November");
		}
	}
	if (tim[4] == 'D'&&tim[5] == 'e'&&tim[6] == 'c'){
		if (a == 0){
			fprintf(fout, "December");
		}
		if (a == 1){
			printf("December");
		}
	}
	if (a == 0){
		fprintf(fout, " %d", days);
	}
	if (a == 1){
		printf(" %d", days);
	}
	if (tim[9] == '1'&&tim[8] != '1'){
		if (a == 0){
			fputs("st", fout);
		}
		if (a == 1){
			printf("st");
		}
	}
	else{
		if (tim[9] == '2'&&tim[8] != '1'){
			if (a == 0){
				fputs("nd", fout);
			}
			if (a == 1){
				printf("nd");
			}
		}
		else{
			if (tim[9] == '3'&&tim[8] != '1'){
				if (a == 0){
					fputs("rd", fout);
				}
				if (a == 1){
					printf("rd");
				}
			}
			else{
				if (a == 0){
					fputs("th", fout);
				}
				if (a == 1){
					printf("th");
				}
			}
		}
	}
	if (a == 0){
		fprintf(fout, ", %d,", years);
	}
	if (a == 1){
		printf(", %d,", years);
	}
	char sec[3] = { tim[17], tim[18], '\0' };
	seconds = atoi(sec);
	if (a == 0){
		fprintf(fout, " %dh %dm %ds\n", hours, minutes, seconds);
	}
	if (a == 1){
		printf(" %dh %dm %ds\n", hours, minutes, seconds);
	}
	fclose(fout);
}

int processTxt(char path[DIM], int re){
	double result = 0, result1 = 0, result2 = 0, anstxt[DIM], anstxtI[DIM];
	FILE *fin = NULL, *fout = NULL, *open = NULL, *read = NULL;
	char addBar[DIM] = "", arith[DIM] = "", res, sendFunc[DIM] = "", resp[30] = "_answers.txt", varLetters[DIM] = "QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm";
	int tD = 0, i, j, cP = 0, k, d, e, f, space = 0, v = 0, l = 0, m = 0, re1 = 0;
	i = 0;
	while (i < re){
		anstxt[i] = ans[i];
		anstxtI[i] = ansI[i];
		i++;
	}
	i = 0;
	for (i = 0; path[i] != '\0'; i++){
		if (path[i] == '"'){
			i++;
			j = i;
			while (path[i] != '\0'){
				path[i - 1] = path[i];
				i++;
			}
			i = j;
		}
	}
	for (i = 0; path[i] != '\0'; i++){
		if (path[i] == '"'){
			path[i] = '\0';
		}
	}
	j = 0;

	for (i = 0; path[i] != '\0'; i++){
		if (path[i] != '\\'){
			addBar[j] = path[i];
			j++;
		}
		else{
			if (path[i] == '\\'){
				addBar[j] = path[i];
				addBar[j + 1] = '\\';
				j = j + 2;
			}
		}
	}
	addBar[j] = '\0';
	for (i = 0; addBar[i] != '\0'; i++){
		path[i] = addBar[i];
	}
	path[i] = '\0';
	i = 0;
	if (read != NULL){
		fclose(read);
	}
	read = NULL;
	while (read == NULL&&i < 100){
		read = fopen(path, "a+");
		i++;
	}
	if (i < 100){
		char sD[DIM] = "";
		for (i = 0; (sendFunc[i] = fgetc(read)) != EOF; i++){
			if (sendFunc[i] == '\n'){
				cP++;
			}
		}
		if (read != NULL){
			fclose(read);
		}
		sendFunc[i] = '\0';
		if (sendFunc[i - 1] != '\n'){
			sendFunc[i] = '\n'; sendFunc[i + 1] = '\0';
			cP++;
		}
		m = 0;
		l = 0;
		while (m == 0){
			if (path[l] == '.'&&path[l + 1] == 't'&&path[l + 2] == 'x'&&path[l + 3] == 't'&&path[l + 4] == '\0'){
				m = 1;
			}
			l++;
		}
		m = 0;
		l--;
		while (resp[m] != '\0'){
			path[l] = resp[m];
			l++; m++;
		}
		path[l] = '\0';
		while (fin == NULL){
			fin = fopen(path, "w");
		}
		fclose(fin);
		d = 0;
		tD = 0;
		char variable[DIM] = "";
		for (k = 0; k < cP; k++){
			char trigData[DIM] = "";
			tD = 0;
			e = 0;
			for (f = d; sendFunc[f] != '\n'&&sendFunc[f] != '\0'; f++){
				trigData[e] = sendFunc[f];
				e++;
			}
			trigData[e] = '\0';
			for (tD = 0; trigData[tD] != '\0'; tD++){
				i = 0;
				char arith[DIM] = "";
				while (trigData[tD] != '\0'&&trigData[tD] != ','){
					arith[i] = trigData[tD];
					i++; tD++;
				}
				arith[i] = '\0';
				valid = 0;
				validVar = 1;
				if (fin != NULL){
					fclose(fin);
				}
				fin = NULL;
				while (fin == NULL){
					fin = fopen(path, "a+");
				}
				fprintf(fin, "\n>%s", arith);
				i = 0;
				while (arith[i] != '='&&arith[i] != '\0'){
					i++;
				}
				if (arith[i] == '='){
					i = i + 1;
					for (i; arith[i] != '\0'; i++){
						if (arith[i] == 'x'){
							arith[i] = '*';
						}
					}
					arith[i] = '\0';
				}
				else{
					for (i = 0; arith[i] != '\0'; i++){
						if (arith[i] == 'x'){
							arith[i] = '*';
						}
					}
					arith[i] = '\0';
				}
				v = 0;
				if (arith[i] == '\0'){
					arith[i] = '+'; arith[i + 1] = '0'; arith[i + 2] = '\0';
				}
				int var = 0, g = 0;
				int s = 0;
				int verify = 0;
				for (s = 0; arith[s] != '\0'; s++){
					if (arith[s] == 'B' || arith[s] == 'O' || arith[s] == 'H' || arith[s] == '_' || arith[s] == '{' || arith[s] == '[' || arith[s] == '(' || arith[s] == '+' || arith[s] == '-' || arith[s] == '*' || arith[s] == '/' || arith[s] == '^' || arith[s] == '0' || arith[s] == '1' || arith[s] == '2' || arith[s] == '3' || arith[s] == '4' || arith[s] == '5' || arith[s] == '6' || arith[s] == '7' || arith[s] == '8' || arith[s] == '9' || (arith[s] == 'r'&&arith[s + 1] == 'e'&&arith[s + 2] == 's') || (arith[s] == 'a'&&arith[s + 1] == 'n'&&arith[s + 2] == 's') || (arith[s] == 'e' && ((arith[s + 1] == 'e' || arith[s + 1] == '\0'&&s == 0 || arith[s + 1] == ')' || arith[s + 1] == 'p' || arith[s - 1] == '_') || (arith[s - 1] == 'e' || arith[s - 1] == '(' || arith[s - 1] == 'i'&&arith[s - 2] != 't'))) || (arith[s] == 'p'&&arith[s + 1] == 'i' && ((arith[s + 2] == 'e' || arith[s + 2] == '\0'&&s == 0 || arith[s + 2] == ')' || arith[s + 2] == 'p' || arith[s - 1] == '_') || (arith[s - 1] == 'e' || arith[s - 1] == '(' || arith[s - 1] == 'i')))){
						verify = 1;
					}
				}
				for (i = 0; arith[i] != '\0'; i++){
					if (arith[i] == '='){
						var = 1;
					}
				}
				if (var == 1){
					for (i = 0; arith[i] != '='; i++){
						if (arith[i] == ' '){
							v = 1;
						}
					}
					i++;
					if (arith[i] == '\0'){
						verify = 0;
						var = 0;
					}
				}
				for (i = 0; arith[i] != '\0'; i++){
					if (arith[i] == ' '){
						space = 1;
						break;
					}
					else{
						space = 0;
					}
				}
				if (space == 1){
					while (space == 1){
						for (i = 0; arith[i] != '\0'; i++){
							if (arith[i] == ' '){
								j = i;
								while (arith[i] != '\0'){
									arith[i] = arith[i + 1];
									i++;
								}
								i = j;
							}
						}
						for (i = 0; arith[i] != '\0'; i++){
							if (arith[i] == ' '){
								space = 1;
								break;
							}
							else{
								space = 0;
							}
						}
					}
				}
				if (var == 1){
					for (i = 0; arith[i] != '='; i++){
						variable[i] = arith[i];
					}
					variable[i] = '\0';
					g = i + 1;
					for (i = 0; arith[i] != '\0'; i++){
						arith[i] = arith[i + g];
					}
					arith[i] = '\0';
					int hk = variableValidator(variable);
					if (hk == 1 || v == 1){
						processVariable(revariable);
						if (validVar == 0){
							fprintf(fin, "\n==> Your variable was renamed to \"%s\", but you can continue using it with the same name that you chose. <==\n\n", revariable);
						}
					}

					if (hk == 2){
						fprintf(fin, "\n==> Your variable was renamed to \"%s\". <==\n\n", revariable);
					}
					if (hk == 0){
						fprintf(fin, "\n==> Invalid variable. Use only latin alphabet letters. <==\n\n");
						var = 0;
					}
				}
				v = 0;
				char dP[DIM] = "", bP[DIM] = "", oP[DIM] = "", hP[DIM] = "";
				int dp = -1, bp = -1, op = -1, hp = -1;
				while (arith[0] == 'd' &&arith[1] == 'p' || arith[0] == 'b' &&arith[1] == 'p' || arith[0] == 'o' &&arith[1] == 'p' || arith[0] == 'h' &&arith[1] == 'p')  {
					if (arith[0] == 'd' &&arith[1] == 'p'){
						i = 2;
						while (arith[i] != 'd'&&arith[i] != '\0'){
							dP[i - 2] = arith[i];
							i++;
						}
						dP[i - 2] = '\0';
						dp = initialProcessor(dP, result);
						i = i + 2;
						int b = 0;
						for (b = 0; arith[b] != '\0'; b++){
							arith[b] = arith[b + i];
						}
					}
					if (arith[0] == 'b' &&arith[1] == 'p'){
						i = 2;
						while (arith[i] != 'b'&&arith[i] != '\0'){
							bP[i - 2] = arith[i];
							i++;
						}
						bP[i - 2] = '\0';
						bp = initialProcessor(bP, result);
						i = i + 2;
						int b = 0;
						for (b = 0; arith[b] != '\0'; b++){
							arith[b] = arith[b + i];
						}
					}
					if (arith[0] == 'o' &&arith[1] == 'p'){
						i = 2;
						while (arith[i] != 'o'&&arith[i] != '\0'){
							oP[i - 2] = arith[i];
							i++;
						}
						oP[i - 2] = '\0';
						op = initialProcessor(oP, result);
						i = i + 2;
						int b = 0;
						for (b = 0; arith[b] != '\0'; b++){
							arith[b] = arith[b + i];
						}
					}
					if (arith[0] == 'h' &&arith[1] == 'p'){
						i = 2;
						while (arith[i] != 'h'&&arith[i] != '\0'){
							hP[i - 2] = arith[i];
							i++;
						}
						hP[i - 2] = '\0';
						hp = initialProcessor(hP, result);
						i = i + 2;
						int b = 0;
						for (b = 0; arith[b] != '\0'; b++){
							arith[b] = arith[b + i];
						}
					}
				}
				d = f + 1;

				for (i = 0; arith[i] != '\0'; i++){
					if (arith[i] == 'a'&&arith[i + 1] == 'n'&&arith[i + 2] == 's'){
						arith[i] = 'r'; arith[i + 1] = 'e'; arith[i + 2] = 's';
						i = i + 3;
					}
				}
				if (strlen(arith) > 0){
					arith[i] = '+'; arith[i + 1] = '0'; arith[i + 2] = '\0';
				}

				res = arith[0];

				if (res == '+' || res == '-' || res == '/' || res == '*' || res == 'x' || res == '^'){
					for (i = 0; arith[i] != '\0'; i++){
						arith[i] = arith[i + 1];
					}
				}
				for (i = 0; arith[i] != '\0'; i++){
					if (arith[i] == 'x'){
						arith[i] = '*';
					}

				}
				arith[i] = '\0';



				s = 0;
				if (verify == 1){
					synTest = 0;
					manageExpression(arith, result1, verify);
					for (i = 0; expressionF[i] != '\0'; i++){
						arith[i] = expressionF[i];
					}
					arith[i] = '\0';
					synTest = 0;
					verify = dataVerifier(arith, re, 1, verify);
				}
				for (s = 0; arith[s] != '\0'; s++){
					if ((arith[s] == '+' || arith[s] == '-' || arith[s] == '*' || arith[s] == '/' || arith[s] == '^') && (arith[s + 1] == '+' || arith[s + 1] == '-'&&arith[s - 2] != '1'&&arith[s - 1] != '0' || arith[s + 1] == '*' || arith[s + 1] == '/' || arith[s + 1] == '^' || arith[s + 1] == '!')){
						verify = 0;
					}
				}
				if (arith[s - 1] == '+' || arith[s - 1] == '-' || arith[s - 1] == '*' || arith[s - 1] == '/' || arith[s - 1] == '^'){
					verify = 0;
				}

				int kg = 0, kc = 0;
				for (i = 0; arith[i] != '\0'; i++){
					if (arith[i] == '(' || arith[i] == '[' || arith[i] == '{'){
						kg++;
					}
					if (arith[i] == ')' || arith[i] == ']' || arith[i] == '}'){
						kc++;
					}
				}
				if (kg != kc){
					fprintf(fin, "\nError in parentheses. \n ==> The number of left and right parenthesis entered must be equal.\n ==> Enter \"[\" or \"{\" is the same as \"(\" and \"]\" or \"}\" is the same as \")\".\n ==> The expression that you entered has %d left parenthesis and %d right parenthesis.\n\n\n", kg, kc);
					arith[0] = '\0';
				}
				char paTrig[DIM] = "";
				s = 0;
				for (s = 0; arith[s] != '\0'; s++){
					paTrig[s] = arith[s];
				}
				paTrig[s] = '\0';

				s = 0;
				for (s; paTrig[s] != '\0'; s++){
					if ((paTrig[s] == 'e'&&paTrig[s + 1] != 'b' || paTrig[s] == 'i'&&paTrig[s - 1] == 'p'&&paTrig[s + 1] != 'b' || paTrig[s] == '1' || paTrig[s] == '2' || paTrig[s] == '3' || paTrig[s] == '4' || paTrig[s] == '5' || paTrig[s] == '6' || paTrig[s] == '7' || paTrig[s] == '8' || paTrig[s] == '9' || paTrig[s] == '0' || paTrig[s] == '.') && (paTrig[s + 1] == '#' || paTrig[s + 1] == 'w' || paTrig[s + 1] == 'e' || paTrig[s + 1] == 'y' || paTrig[s + 1] == 'u' || paTrig[s + 1] == 'i'&&verifyNumber(paTrig[s]) == 0 || paTrig[s + 1] == 'o' || paTrig[s + 1] == 'p' || paTrig[s + 1] == 'f' || paTrig[s + 1] == 'h' || paTrig[s + 1] == 'j' || paTrig[s + 1] == 'k' || paTrig[s + 1] == 'z' || paTrig[s + 1] == 'x' || paTrig[s + 1] == 'v' || paTrig[s + 1] == 'm' || paTrig[s + 1] == 'Q' || paTrig[s + 1] == 'W' || paTrig[s + 1] == 'R' || paTrig[s + 1] == 'T' || paTrig[s + 1] == 'Y' || paTrig[s + 1] == 'U' || paTrig[s + 1] == 'I' || paTrig[s + 1] == 'S' || paTrig[s + 1] == 'G' || paTrig[s + 1] == 'J' || paTrig[s + 1] == 'K' || paTrig[s + 1] == 'L' || paTrig[s + 1] == 'Z' || paTrig[s + 1] == 'X' || paTrig[s + 1] == 'V' || paTrig[s + 1] == 'N' || paTrig[s + 1] == 'M')){
						s++;
						arith[s] = '*';
						for (s; paTrig[s] != '\0'; s++){
							arith[s + 1] = paTrig[s];
						}
						arith[s + 1] = '\0';
						s = 0;
						for (s = 0; arith[s] != '\0'; s++){
							paTrig[s] = arith[s];
						}
						paTrig[s] = '\0';
						s = 0;
					}
				}
				s = 0;
				for (s; paTrig[s] != '\0'; s++){
					if ((paTrig[s + 1] == 'e'&&paTrig[s] != 'b' || paTrig[s + 1] == 'p'&&paTrig[s + 2] == 'i'&&paTrig[s] != 'b' || paTrig[s + 1] == '1' || paTrig[s + 1] == '2' || paTrig[s + 1] == '3' || paTrig[s + 1] == '4' || paTrig[s + 1] == '5' || paTrig[s + 1] == '6' || paTrig[s + 1] == '7' || paTrig[s + 1] == '8' || paTrig[s + 1] == '9' || paTrig[s + 1] == '0' || paTrig[s + 1] == '.') && (paTrig[s] == 'q' || paTrig[s] == 'w' || paTrig[s] == 't' || paTrig[s] == 'y' || paTrig[s] == 'u' || paTrig[s] == 'o' || paTrig[s] == 'p' || paTrig[s] == 'a' || paTrig[s] == 'f' || paTrig[s] == 'h' || paTrig[s] == 'j' || paTrig[s] == 'k' || paTrig[s] == 'l' || paTrig[s] == 'z' || paTrig[s] == 'c' || paTrig[s] == 'v' || paTrig[s] == 'n' || paTrig[s] == 'm' || paTrig[s] == 'Q' || paTrig[s] == 'W' || paTrig[s] == 'R' || paTrig[s] == 'T' || paTrig[s] == 'Y' || paTrig[s] == 'U' || paTrig[s] == 'I' || paTrig[s] == 'S' || paTrig[s] == 'G' || paTrig[s] == 'J' || paTrig[s] == 'K' || paTrig[s] == 'L' || paTrig[s] == 'Z' || paTrig[s] == 'X' || paTrig[s] == 'V' || paTrig[s] == 'N' || paTrig[s] == 'M')){
						s++;
						arith[s] = '*';
						for (s; paTrig[s] != '\0'; s++){
							arith[s + 1] = paTrig[s];
						}
						arith[s + 1] = '\0';
						s = 0;
						for (s = 0; arith[s] != '\0'; s++){
							paTrig[s] = arith[s];
						}
						paTrig[s] = '\0';
						s = 0;
					}
				}
				if (arith[0] != '\0'){
					result = initialProcessor(arith, result1);
					flushall();
					if (arith[0] != '\0'){
						if (res == '+'){
							sum(result1, result2, resultR, resultI);
						}
						if (res == '-'){
							subtraction(result1, result2, resultR, resultI);
						}
						if (res == '/'){
							division(result1, result2, resultR, resultI);
						}
						if (res == '*' || res == 'x'){
							multiplication(result1, result2, resultR, resultI);
						}
						if (res == '^'){
							exponentiation(result1, result2, resultR, resultI, 1);
						}
					}
					if (verify == 1){
						round_complex();
						result1 = resultR;
						result2 = resultI;
						resultFI = result2;
						if (var == 1){
							variableController(revariable, result);
						}
						char arith[DIM] = "";
						if (dp == -1){
							ans[re1] = result1;
							ansI[re1] = result2;
							fprintf(fin, "\n");
							if (result1 > 0 && result2 > 0){
								fprintf(fin, "#%d=%G+%Gi\n", re1, result1, result2);
							}
							else{
								if (result1 > 0 && result2 < 0){
									fprintf(fin, "#%d=%G%Gi\n", re1, result1, result2);
								}
								else{
									if (result1 < 0 && result2 > 0){
										fprintf(fin, "#%d=%G+%Gi\n", re1, result1, result2);
									}
									else{
										if (result1 < 0 && result2 < 0){
											fprintf(fin, "#%d=%G%Gi\n", re1, result1, result2);
										}
										else{
											if (result1 == 0 && result2 == 0){
												fprintf(fin, "#%d=%G\n", re1, result1);
											}
											else{
												if (result1 == 0 && result2 != 0){
													fprintf(fin, "#%d=%Gi\n", re1, result2);
												}
												else{
													if (result1 != 0 && result2 == 0){
														fprintf(fin, "#%d=%G\n", re1, result1);
													}
													else{
														fprintf(fin, "#%d=%G+%Gi\n", re1, result1, result2);
													}
												}
											}
										}
									}
								}
							}
							re1++;
						}
						if (dp > -1){
							ans[re1] = result;
							ansI[re1] = resultFI;
							fprintf(fin, "\n");
							if (result1 > 0 && result2 > 0){
								sprintf(dP, "#%d=%%.%df+%%.%dfi\n", re1, dp, dp);
								fprintf(fin, dP, result1, result2);
							}
							else{
								if (result1 > 0 && result2 < 0){
									sprintf(dP, "#%d=%%.%df%%.%dfi\n", re1, dp, dp);
									fprintf(fin, dP, result1, result2);
								}
								else{
									if (result1 < 0 && result2 > 0){
										sprintf(dP, "#%d = %%.%df+%%.%dfi\n", re1, dp, dp);
										fprintf(fin, dP, result1, result2);
									}
									else{
										if (result1 < 0 && result2 < 0){
											sprintf(dP, "#%d=%%.%df%%.%dfi\n", re1, dp, dp);
											fprintf(fin, dP, result1, result2);
										}
										else{
											if (result1 == 0 && result2 == 0){
												sprintf(dP, "#%d=%%.%df\n", re1, dp);
												fprintf(fin, dP, result1);
											}
											else{
												if (result1 == 0 && result2 != 0){
													sprintf(dP, "#%d=%%.%dfi\n", re1, dp);
													fprintf(fin, dP, result2);
												}
												else{
													if (result1 != 0 && result2 == 0){
														sprintf(dP, "#%d=%%.%df\n", re1, dp);
														fprintf(fin, dP, result1);
													}
													else{
														sprintf(dP, "#%d=%%.%df+%%.%dfi\n", re1, dp, dp);
														fprintf(fin, dP, result1, result2);
													}
												}
											}
										}
									}
								}
							}
							re1++;
						}
						fclose(fin);
						if ((open = fopen("numSystems.txt", "r")) != NULL || bp != -1 || op != -1 || hp != -1){
							char numSys[DIM] = "";
							int numeriSys = 0;
							if (open != NULL){
								fgets(numSys, 10, open);
								numeriSys = atoi(numSys);
							}
							if (numeriSys == 1 || bp != -1 || op != -1 || hp != -1){
								char syst[DIM] = "";
								sprintf(syst, "%G", result);
								if (syst[0] == '1'&&syst[1] == '.'&&syst[2] == '#'&&syst[3] == 'I'&&syst[4] == 'N'&&syst[5] == 'F'){
									open = fopen(path, "a+");
									fputs("In binary=11111111111111111111111111111111.#INF\n", open);
									fputs("In octal=77777777777777777777777777777777.#INF\n", open);
									fputs("In hexadecimal=FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF.#INF\n", open);
									fclose(open);
								}
								else{
									if (syst[0] == '-'&&syst[1] == '1'&&syst[2] == '.'&&syst[3] == '#'&&syst[4] == 'I'&&syst[5] == 'N'&&syst[6] == 'F'){
										open = fopen(path, "a+");
										fputs("In binary=-11111111111111111111111111111111.#INF\n", open);
										fputs("In octal=-77777777777777777777777777777777.#INF\n", open);
										fputs("In hexadecimal=-FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF.#INF\n", open);
										fclose(open);
									}
									else{
										char Value[DIM] = "";
										sprintf(Value, "%G", result);
										for (int v = 0; Value[v]; v++){
											if (Value[v] == '-') {
												Value[v] = '_';
											}
											if (Value[v] == '+')  {
												Value[v] = '0';
											}
										}
										result1 = initialProcessor(Value, 0);
										sprintf(Value, "%G", result2);
										for (int v = 0; Value[v]; v++){
											if (Value[v] == '-') {
												Value[v] = '_';
											}
											if (Value[v] == '+'){
												Value[v] = '0';
											}
										}
										result2 = initialProcessor(Value, 0);
										if (result1 != 0 || result1 == 0 && result2 == 0){
											open = fopen(path, "a+");
											fputs("\nReal part:\n", open);
											fclose(open);
											decimalToBinary(result1, path, bp);
											decimalToOctal(result1, path, op);
											decimalToHexadecimal(result1, path, hp);
										}
										if (result2 != 0){
											open = fopen(path, "a+");
											fputs("\nImaginary part:\n", open);
											fclose(open);
											decimalToBinary(result2, path, bp);
											decimalToOctal(result2, path, op);
											decimalToHexadecimal(result2, path, hp);
										}
									}
								}
							}
							if (open != NULL){
								fclose(open);
							}
						}

						if ((open = fopen("siPrefixes.txt", "r")) != NULL){
							char siPref[DIM] = "";
							int niPrefix = 0;
							fgets(siPref, 10, open);
							niPrefix = atoi(siPref);
							if (niPrefix == 1){
								if (result1 != 0 || result1 == 0 && result2 == 0){
									open = fopen(path, "a+");
									fprintf(open, "\nReal part");
									fclose(open);
									prefDet(result1, path);
								}
								if (result2 != 0){
									open = fopen(path, "a+");
									fprintf(open, "\nImaginary part");
									fclose(open);
									prefDet(result2, path);
								}
							}
							fclose(open);
						}

					}
					else{
						fprintf(fin, "\nError in syntax.\n");
					}
				}
			}
		}
		if (fin != NULL){
			fclose(fin);
		}
		if (read != NULL){
			fclose(read);
		}
		i = 0;
		while (i < re){
			ans[i] = anstxt[i];
			ansI[i] = anstxtI[i];
			i++;
		}
	}
	int h;
	for (h = 0; path[h] != '\0'; h++){
		expressionF[h] = path[h];
	}
	expressionF[h] = '\0';
	if (fin != NULL){ fclose(fin); }if (fout != NULL){ fclose(fout); }if (open != NULL){ fclose(open); } if (read != NULL){ fclose(read); }
	return 0;
}

void colors(){
	FILE *open;
	char bGround = ' ', cTxt = ' ', express[DIM] = "color 73";
	printf("\n Symbol -> Color corresponding to\n\n 0 -> black\n 1 -> blue\n 2 -> green\n 3 -> aqua\n 4 -> red\n 5 -> purple\n 6 -> yellow\n 7 -> white\n 8 -> gray\n 9 -> light blue\n a -> light green\n b -> light aqua\n c -> light red\n d -> light purple\n e -> light yellow\n f -> bright white\n\n");
	printf("Background color: ");
	scanf("%c", &bGround);
	printf("Text color: ");
	flushall();
	scanf("%c", &cTxt);
	printf("\n");
	express[6] = bGround;
	express[7] = cTxt;
	system(express);
	open = fopen("colors.txt", "w");
	fprintf(open, "%s", express);
	fclose(open);
}

void dimensions(){
	FILE *open;
	double nlins, ncols;
	char lins[DIM] = "", cols[DIM] = "", express[DIM] = "MODE con cols=";
	int i = 0, e = 0, toDo = 2;
	printf("\nNumber of lines: ");
	gets(lins);
	nlins = arithSolver(lins, 0);
	printf("Number of columns: ");
	gets(cols);
	ncols = arithSolver(cols, nlins);
	open = fopen("dimensions.txt", "w");
	fprintf(open, "MODE con cols=%G lines=%G", ncols, nlins);
	fclose(open);
	applySettings(toDo);
}

void window(){
	FILE *open;
	double x, y, width, height;
	char value[DIM] = " ";
	HWND w;
	w = GetConsoleWindow();
	printf("X-axis value: ");
	gets(value);
	x = arithSolver(value, 0);
	printf("Y-axis value: ");
	gets(value);
	y = arithSolver(value, x);
	printf("Width value: ");
	gets(value);
	width = arithSolver(value, y);
	printf("Height value: ");
	gets(value);
	height = arithSolver(value, width);
	printf("\n");
	MoveWindow(w, (int)x, (int)y, (int)width, (int)height, FALSE);
	open = fopen("window.txt", "w");
	fprintf(open, "%G\n%G\n%G\n%G\n", x, y, width, height);
	fclose(open);
}

int applySettings(int toDo){
	FILE *open = NULL;
	char setting[DIM];
	if (toDo == 1){
		if (fopen("colors.txt", "r") == NULL){
			system("color 73");
		}
		else{
			open = fopen("colors.txt", "r");
			fgets(setting, 9, open);
			fclose(open);
			system(setting);
		}
		return 0;
	}
	if (toDo == 2){
		if (fopen("dimensions.txt", "r") == NULL){
			system("MODE con cols=130 lines=57");
		}
		else{
			open = fopen("dimensions.txt", "r");
			fgets(setting, 40, open);
			fclose(open);
			system(setting);
		}
		return 0;
	}
	if (toDo == 3){
		int i = 0, e = 0;
		double x, y, width, height, a = 1;
		char value[DIM];
		if (fopen("window.txt", "r") == NULL){
			HWND a;
			a = GetConsoleWindow();
			MoveWindow(a, 0, 0, 1000, 1000, FALSE);
		}
		else{
			open = fopen("window.txt", "r");
			for (i = 0; (setting[i] = fgetc(open)) != EOF; i++){
				value[e] = setting[i];
				if (setting[i] != '\n'){
					e++;
				}
				if (value[e] == '\n'&&a == 1){
					value[e] = '\0';
					x = arithSolver(value, 0);
					a = 2; e = 0;
				}
				if (value[e] == '\n'&&a == 2){
					value[e] = '\0';
					y = arithSolver(value, x);
					a = 3; e = 0;
				}
				if (value[e] == '\n'&&a == 3){
					value[e] = '\0';
					width = arithSolver(value, y);
					a = 4; e = 0;
				}
				if (value[e] == '\n'&&a == 4){
					value[e] = '\0';
					height = arithSolver(value, width);
					a = 5; e = 0;
				}
			}
			HWND w;
			w = GetConsoleWindow();
			MoveWindow(w, (int)x, (int)y, (int)width, (int)height, FALSE);
		}
		return 0;
	}
	if (toDo == 4){
		int option = 0;
		char opt[DIM] = "";
		open = fopen("mode.txt", "r");
		if (open == NULL){
			option = 2;
		}
		else{
			fgets(opt, 2, open);
			option = atoi(opt);
		}
		return option;
	}
	return 0;
}

void mode(){
	FILE *open;
	char c[DIM] = "";
	int option = 0;
	while (option != 1 && option != 2 && option != 3){
		printf("radian -> 1\ndegree -> 2\ngradian -> 3\n");
		gets(c);
		option = arithSolver(c, 0);
		if (option > 3 || option < 1){
			printf("Error, incorrect choice.\n");
		}
	}
	open = fopen("mode.txt", "w");
	fprintf(open, "%d", option);
	fclose(open);
}

double pot(double base, double exponent, int sig){
	double result = 0;
	if (abs(exponent) >= 1 || exponent == 0){
		double rest = 0, result2 = 0;
		double exponent1, exponent2;
		int k = 0;
		if (sig == 0){
			base = base*-1;
			result = -1 * pot((double)base, (double)exponent, 1);
		}
		else{
			if (sig == 1){
				exponent1 = quo(exponent);
				exponent2 = multi(exponent);
				result2 = base;
				if (exponent < 0){
					exponent1 = exponent1*-1;
				}
				for (k = 1; k < exponent1&&result2 < 1.79769E308; k++){
					result2 = result2*base;
				}
				if (exponent < 0){
					result2 = 1 / result2;
				}
				if (exponent < 0 && exponent2>0){
					exponent2 = exponent2*-1;
				}
				if (exponent1 >= 1){
					result = pow((double)base, (double)exponent2)*result2;
				}
				else{
					if (exponent != 0){
						result = pow((double)base, (double)exponent2);
					}
					else{
						result = 1;
					}
				}
			}
		}
	}
	else{
		result = rt((double)base, 1 / (double)exponent, sig);
	}

	return result;
}

double rt(double radicand, double degree, int sig){
	double result = -1.79769E308, precision = 1.79769E308;
	int i = 0, j = 0;
	if (radicand == 0){
		result = 0;
		return result;
	}
	if (sig == 0){
		radicand = radicand*-1;
		result = -1 * rt((double)radicand, (double)degree, 1);
		sig = 1;
	}
	else{
		if (sig == 1){
			if (degree < 0){
				degree = degree*-1;
				j = 1;
			}
			while (precision >= 1E-309){
				while (radicand > pot(result + precision, degree, 1) && i < 10){
					result = result + precision;
					i++;
				}
				i = 0;
				precision = precision / 10;
			}

			if (j == 1){
				result = 1 / result;
				j = 0;
			}
		}
	}
	return result;
}

double processVariable(char variable[DIM]){
	validVar = 0;
	FILE *open = NULL;
	int i, g, h, y, l = 0, lth = 0, cou = 0;
	double varValue = 0;
	char vari[DIM] = "", va[DIM] = "", value[DIM] = "";
	char *pointer;
	i = 0;
	open = fopen("variables.txt", "a+");
	while (open == NULL&&cou < 10){
		open = fopen("variables.txt", "a+");
		cou++;
	}
	if (cou < 10){
		i = 0;
		for (i = 0; (vari[i] = fgetc(open)) != EOF; i++);
		vari[i] = '\0';
		lth = strlen(vari);
		fclose(open);
		i = 0;
		for (i = 0; vari[i] != '\0'; i++){
			g = 0;
			int j = i;
			while (vari[j] != ' '&&vari[j] != '\0'){
				j++;
			}
			j = j - i;
			if (vari[i] == variable[g] && (i == 0 || vari[i - 1] == '\n')){
				while (vari[i] == variable[g]){
					if (vari[i] == variable[g]){
						va[g] = vari[i];
					}i++; g++;
				}
				if (vari[i] != ' '){
					while (vari[i] != ' '){
						va[g] = vari[i];
						g++; i++;
					}
				}
				va[g] = '\0';
			}
			l = i;
			g = 0;
			for (y = 0; va[y] != '\0'; y++){
				if (va[y] == variable[y]){
					g++;
				}
			}
			vari[lth] = '\0';
			if (g == strlen(va) && strlen(variable) == g&&j == g&&g != 0){
				int space = 0;
				valid = 1; validVar = 1;
				int gh = l;
				while (vari[gh] != '\n'){
					gh++;
				}
				h = gh;
				gh = l + 1;
				y = 0;
				for (gh; gh < h; gh++){
					value[y] = vari[gh];
					if (value[y] == ' '){
						space = 1;
					}
					y++;
				}
				value[y] = '\0';
				if (space == 0){
					resultR = strtod(value, &pointer);
				}
				else{
					char real[DIM] = "", imag[DIM] = "";
					y = 0;
					while (value[y] != ' '){
						real[y] = value[y];
						y++;
					}
					real[y] = '\0';
					y++;
					gh = 0;
					while (value[y] != '\0'){
						imag[gh] = value[y];
						y++; gh++;
					}
					imag[gh] = '\0';
					resultR = strtod(real, &pointer);
					resultI = strtod(imag, &pointer);
					varValue = resultR;
				}
				break;
			}
		}
	}
	return varValue;
}

void variableController(char variable[DIM], double result){
	FILE *open = NULL;
	char va[DIM] = "", vari[DIM] = "";
	int i = 0, f = 0;
	vari[0] = '\0';
	int y = 0, h = 0, k = 0, g = 0;
	if (open != NULL){
		fclose(open);
	}
	open = NULL;
	while (open == NULL&&i < 100){
		open = fopen("variables.txt", "a+");
		i++;
	}
	if (i < 100){
		for (i = 0; (vari[i] = fgetc(open)) != EOF; i++);
		fclose(open);
		vari[i] = '\0';
		if (vari[0] == '\n'){
			for (i = 0; vari[i + 1] != '\0'; i++){
				vari[i] = vari[i + 1];
			}
			vari[i] = '\0';
		}
		for (i = 0; vari[i] != '\0'; i++){
			g = 0;
			h = i; k = h;
			int j = i;
			while (vari[j] != ' '&&vari[j] != '\0'){
				j++;
			}
			j = j - i;
			int p = 0;
			if (vari[i] == variable[g] && (i == 0 || vari[i - 1] == '\n')){
				f = i;
				while (vari[i] == variable[g]){
					if (vari[i] == variable[g]){
						va[g] = vari[i];
					}g++; i++;
				}
				va[g] = '\0';
				p = strlen(variable);
			}
			g = 0;
			for (y = 0; va[y] != '\0'; y++){
				if (va[y] == variable[y]){
					g++;
				}
			}
			if (g == strlen(va) && strlen(variable) == g&&g == j){
				h = f + p;
				while (vari[h] != '\n'){
					h++;
					p++;
				}
				p++;
				for (f; vari[f + p] != '\0'; f++){
					vari[f] = vari[f + p];
				}
				vari[f] = '\0';
				if (vari[0] == '\n'){
					for (i = 0; vari[i + 1] != '\0'; i++){
						vari[i] = vari[i + 1];
					}
					vari[i] = '\0';
				}
				open = NULL;
				while (open == NULL){
					open = fopen("variables.txt", "w");
				}
				fprintf(open, "%s", vari);
				fclose(open);
				break;
			}
		}
		open = NULL;
		while (open == NULL){
			open = fopen("variables.txt", "a+");
		}
		fprintf(open, "%s %G %G\n", variable, resultR, resultI);
		fclose(open);
	}
}

int variableValidator(char variable[DIM]){
	int validate = 0, i = 0, h = -1, abc = 0, j = 0, k = 0, sD = 0;
	char variableT[DIM], varLetters[DIM] = "QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm";
	double arith = 0, func = 0;
	for (k = 0; variable[k] != '\0'; k++){
		for (i = 0; varLetters[i] != '\0'; i++){
			if (variable[k] == varLetters[i]){
				j++;
				break;
			}
		}
	}
	if (j != strlen(variable) || j == 0 && strlen(variable) == 0){
		h = 0;
		return h;
	}
	revariable[0] = '\0';

	FILE *var = NULL, *var1 = NULL;
	i = 0;
	abc = strlen(variable);
	valid = 0;
	for (i = 0; variable[i] != '\0'; i++){
		if (i == 0 && (variable[i] == 's' || variable[i] == 'c' || variable[i] == 't' || variable[i] == 'a' || variable[i] == 'l' || variable[i] == 'r' || variable[i] == 'q' || variable[i] == 'g' || variable[i] == 'd')){
			if (variable[i] == 's'){
				revariable[i] = 'p';
			}
			if (variable[i] == 'c'){
				revariable[i] = 'h';
			}
			if (variable[i] == 't'){
				revariable[i] = 'j';
			}
			if (variable[i] == 'a'){
				revariable[i] = 'k';
			}
			if (variable[i] == 'l'){
				revariable[i] = 'z';
			}
			if (variable[i] == 'r'){
				revariable[i] = 'v';
			}
			if (variable[i] == 'q'){
				revariable[i] = 'n';
			}
			if (variable[i] == 'g'){
				revariable[i] = 'm';
			}
			if (variable[i] == 'd'){
				revariable[i] = 'G';
			}
			h = 1;
		}
		else{
			if (variable[i] == 'i' || variable[i] == 'e' || variable[i] == 'x' || variable[i] == 'b' || variable[i] == 'D'){
				if (variable[i] == 'i'){
					revariable[i] = 'o';
				}
				if (variable[i] == 'e'){
					revariable[i] = 'w';
				}
				if (variable[i] == 'x'){
					revariable[i] = 'y';
				}
				if (variable[i] == 'b'){
					revariable[i] = 'u';
				}
				if (variable[i] == 'D'){
					revariable[i] = 'T';
					sD = 1;
				}
				h = 1;
			}
			else{
				if (i == 0 && (variable[i] == 'B' || variable[i] == 'O' || variable[i] == 'H' || variable[i] == 'P')){
					if (variable[i] == 'B'){
						revariable[i] = 'N';
					}
					if (variable[i] == 'O'){
						revariable[i] = 'M';
					}
					if (variable[i] == 'H'){
						revariable[i] = 'V';
					}
					if (variable[i] == 'P'){
						revariable[i] = 'I';
					}
					h = 1;
				}
				else{
					if (variable[i] == 'A' || variable[i] == 'B' || variable[i] == 'C' || variable[i] == 'E' || variable[i] == 'F' || variable[i] == 'P'){
						if (variable[i] == 'A'){
							revariable[i] = 'Q';
						}
						if (variable[i] == 'B'){
							revariable[i] = 'W';
						}
						if (variable[i] == 'C'){
							revariable[i] = 'R';
						}
						if (variable[i] == 'E'){
							revariable[i] = 'Y';
						}
						if (variable[i] == 'F'){
							revariable[i] = 'U';
						}
						if (variable[i] == 'P'){
							revariable[i] = 'S';
						}
						h = 1;
					}
					else{
						revariable[i] = variable[i];
					}
				}
			}
		}
	}

	revariable[i] = '\0';
	i = 0;

	variable[abc] = '\0';
	processVariable(variable);
	variable[abc] = '\0';
	arith = arithSolver(variable, 0);
	if ((variable[0] == 'E' || variable[0] == 'B' || variable[0] == 'O' || variable[0] == 'H' || variable[0] == 'P' || variable[0] == 'x') && variable[1] == '='){
		arith = 10;
	}
	variable[abc] = '\0';
	for (i = 0; variable[i] != '\0'; i++){
		variableT[i] = variable[i];
	}
	variableT[i] = '?'; variableT[i + 1] = '\0';
	char testPrefix[DIM] = "";
	for (i = 0; variable[i] != '\0'; i++){
		testPrefix[i] = variable[i];
	}
	testPrefix[i] = '\0';
	double prefix = 0;
	if (testPrefix[0] == 'P'){
		testPrefix[0] = '1';
		for (i = 1; testPrefix[i] != '\0'; i++){
			testPrefix[i] = testPrefix[i - 1];
		}
		testPrefix[i] = '\0';
		prefix = arithSolver(testPrefix, 0);
	}
	func = functionProcessor(variableT, 0.3, 1.0, 0);
	variable[abc] = '\0';
	processVariable(variable);
	if (h == 1 && valid == 0 && arith == 0 && func == 0 && prefix == 0 && sD == 0){
		processVariable(revariable);
		if (valid == 0){
			i = 0;
			FILE *var1 = NULL;
			if (var1 != NULL){
				fclose(var1);
			}
			var1 = NULL;
			while (var1 == NULL&&i < 100){
				var1 = fopen("renamedVar.txt", "a+");
				i++;
			}
			if (i < 100){
				fprintf(var1, "%s %s\n", variable, revariable);
				fclose(var1);
				fclose(var1);
			}
			i = 0;
		}
	}
	else{
		if (h == 1 && valid == 0 && (arith != 0 || func != 0 || prefix != 0 || sD != 0)){
			h = 2;
			sD = 0;
		}
	}
	return h;
}

double binaryToDecimal(char binary[DIM]){
	char binary2[DIM] = "", floa[DIM] = "";
	double decimal = 0, negDec = 0, flo = 0;
	int count = 0, j = 0, i = 0, f = 0, g = 0, h = 0, count1 = 0, d = 0, k = 0;
	while (binary[d] != '\0'&&binary[d] != '.'){ d++; }
	d--;
	if (binary[0] == '-'){
		while (binary[k] != '\0'){
			binary[k] = binary[k + 1];
			k++;
		}
		k = 0;
		while (binary[k] == '0'){
			d--;
			k++;
		}
		negDec = pot(2.000, d*1.000, 1);
	}
	while (binary[i] != '\0'&&binary[i] != '.'){
		i++;
	}
	i--;
	count = i;
	h = i;
	while (binary[h] != '\0'){
		floa[g] = binary[h + 2];
		g++;
		h++;
	}
	g--;
	count1 = g;
	while (i >= 0){
		binary2[j] = binary[i];
		i--;
		j++;
	}
	binary2[j] = '\0';
	while (i <= count){
		if (binary2[i] == '1'){
			decimal = decimal + pot(2.000, i, 1);
		}
		i++;
	}
	h = -1;
	g = 0;
	while (g <= count1){
		if (floa[g] == '1'){
			flo = flo + pot(2.000, h, 1);
		}
		g++;
		h--;
	}
	decimal = decimal + flo;
	if (negDec > 0){
		decimal = (decimal - negDec);
		if (flo > 0){
			double f = fl(decimal);
			f = 1 - f;
			decimal = returnDeciPart(decimal) - f;
		}
	}
	return decimal;
}

double octalToDecimal(char octal[DIM]){
	char octal2[DIM], floa[DIM] = "";
	int count = 0, j = 0, i = 0, h = 0, g = 0, count1, d = 0, k = 0;
	double decimal = 0, flo = 0, negDec = 0;
	while (octal[d] != '\0'&&octal[d] != '.'){ d++; }
	d--;
	if (octal[0] == '-'){
		while (octal[k] != '\0'){
			octal[k] = octal[k + 1];
			k++;
		}
		k = 0;
		while (octal[k] == '0'){
			d--;
			k++;
		}
		negDec = pot(8.000, d*1.000, 1);
	}
	while (octal[i] != '\0'&&octal[i] != '.'){
		i++;
	}
	i--;
	count = i;
	h = i;
	while (octal[h] != '\0'){
		floa[g] = octal[h + 2];
		g++;
		h++;
	}
	g--;
	count1 = g;
	while (i >= 0){
		octal2[j] = octal[i];
		i--;
		j++;
	}
	octal2[j] = '\0';
	while (i <= count){
		if (octal2[i] == '1'){
			decimal = decimal + pot(8.000, i, 1);
		}
		if (octal2[i] == '2'){
			decimal = decimal + 2 * pot(8.000, i, 1);
		}
		if (octal2[i] == '3'){
			decimal = decimal + 3 * pot(8.000, i, 1);
		}
		if (octal2[i] == '4'){
			decimal = decimal + 4 * pot(8.000, i, 1);
		}
		if (octal2[i] == '5'){
			decimal = decimal + 5 * pot(8.000, i, 1);
		}
		if (octal2[i] == '6'){
			decimal = decimal + 6 * pot(8.000, i, 1);
		}
		if (octal2[i] == '7'){
			decimal = decimal + 7 * pot(8.000, i, 1);
		}

		i++;
	}
	h = -1;
	g = 0;
	while (g <= count1){
		if (floa[g] == '1'){
			flo = flo + pot(8.000, h, 1);
		}
		if (floa[g] == '2'){
			flo = flo + 2 * pot(8.000, h, 1);
		}
		if (floa[g] == '3'){
			flo = flo + 3 * pot(8.000, h, 1);
		}
		if (floa[g] == '4'){
			flo = flo + 4 * pot(8.000, h, 1);
		}
		if (floa[g] == '5'){
			flo = flo + 5 * pot(8.000, h, 1);
		}
		if (floa[g] == '6'){
			flo = flo + 6 * pot(8.000, h, 1);
		}
		if (floa[g] == '7'){
			flo = flo + 7 * pot(8.000, h, 1);
		}
		g++;
		h--;
	}
	decimal = decimal + flo;
	if (negDec > 0){
		decimal = (decimal - negDec);
		if (flo > 0){
			double f = fl(decimal);
			f = 1 - f;
			decimal = returnDeciPart(decimal) - f;
		}
	}
	return decimal;
}

double hexadecimalToDecimal(char hexadecimal[DIM]){
	char hexadecimal2[DIM], floa[DIM];
	int count = 0, j = 0, i = 0, h = 0, g = 0, count1 = 0, k = 0, d = 0;
	double decimal = 0, flo = 0, negDec = 0;
	while (hexadecimal[d] != '\0'&&hexadecimal[d] != '.'){ d++; }
	d--;
	if (hexadecimal[0] == '-'){
		while (hexadecimal[k] != '\0'){
			hexadecimal[k] = hexadecimal[k + 1];
			k++;
		}
		k = 0;
		while (hexadecimal[k] == '0'){
			d--;
			k++;
		}
		negDec = pot(16.000, d*1.000, 1);
	}
	while (hexadecimal[i] != '\0'&&hexadecimal[i] != '.'){
		if (hexadecimal[i] == 'a'){
			hexadecimal[i] = 'A';
		}
		if (hexadecimal[i] == 'b'){
			hexadecimal[i] = 'B';
		}
		if (hexadecimal[i] == 'c'){
			hexadecimal[i] = 'C';
		}
		if (hexadecimal[i] == 'd'){
			hexadecimal[i] = 'D';
		}
		if (hexadecimal[i] == 'e'){
			hexadecimal[i] = 'E';
		}
		if (hexadecimal[i] == 'f'){
			hexadecimal[i] = 'F';
		}
		i++;

	}
	i--;
	count = i;
	h = i;
	while (hexadecimal[h] != '\0'){
		floa[g] = hexadecimal[h + 2];
		g++;
		h++;
	}
	g--;
	count1 = g;

	while (i >= 0){
		hexadecimal2[j] = hexadecimal[i];
		i--;
		j++;
	}
	hexadecimal2[j] = '\0';
	while (i <= count){
		if (hexadecimal2[i] == '1'){
			decimal = decimal + pot(16.000, i, 1);
		}
		if (hexadecimal2[i] == '2'){
			decimal = decimal + 2 * pot(16.000, i, 1);
		}
		if (hexadecimal2[i] == '3'){
			decimal = decimal + 3 * pot(16.000, i, 1);
		}
		if (hexadecimal2[i] == '4'){
			decimal = decimal + 4 * pot(16.000, i, 1);
		}
		if (hexadecimal2[i] == '5'){
			decimal = decimal + 5 * pot(16.000, i, 1);
		}
		if (hexadecimal2[i] == '6'){
			decimal = decimal + 6 * pot(16.000, i, 1);
		}
		if (hexadecimal2[i] == '7'){
			decimal = decimal + 7 * pot(16.000, i, 1);
		}
		if (hexadecimal2[i] == '8'){
			decimal = decimal + 8 * pot(16.000, i, 1);
		}
		if (hexadecimal2[i] == '9'){
			decimal = decimal + 9 * pot(16.000, i, 1);
		}
		if (hexadecimal2[i] == 'A'){
			decimal = decimal + 10 * pot(16.000, i, 1);
		}
		if (hexadecimal2[i] == 'B'){
			decimal = decimal + 11 * pot(16.000, i, 1);
		}
		if (hexadecimal2[i] == 'C'){
			decimal = decimal + 12 * pot(16.000, i, 1);
		}
		if (hexadecimal2[i] == 'D'){
			decimal = decimal + 13 * pot(16.000, i, 1);
		}
		if (hexadecimal2[i] == 'E'){
			decimal = decimal + 14 * pot(16.000, i, 1);
		}
		if (hexadecimal2[i] == 'F'){
			decimal = decimal + 15 * pot(16.000, i, 1);
		}

		i++;
	}
	h = -1;
	g = 0;
	while (g <= count1){
		if (floa[g] == '1'){
			flo = flo + pot(16.000, h, 1);
		}
		if (floa[g] == '2'){
			flo = flo + 2 * pot(16.000, h, 1);
		}
		if (floa[g] == '3'){
			flo = flo + 3 * pot(16.000, h, 1);
		}
		if (floa[g] == '4'){
			flo = flo + 4 * pot(16.000, h, 1);
		}
		if (floa[g] == '5'){
			flo = flo + 5 * pot(16.000, h, 1);
		}
		if (floa[g] == '6'){
			flo = flo + 6 * pot(16.000, h, 1);
		}
		if (floa[g] == '7'){
			flo = flo + 7 * pot(16.000, h, 1);
		}
		if (floa[g] == '8'){
			flo = flo + 8 * pot(16.000, h, 1);
		}
		if (floa[g] == '9'){
			flo = flo + 9 * pot(16.000, h, 1);
		}
		if (floa[g] == 'A'){
			flo = flo + 10 * pot(16.000, h, 1);
		}
		if (floa[g] == 'B'){
			flo = flo + 11 * pot(16.000, h, 1);
		}
		if (floa[g] == 'C'){
			flo = flo + 12 * pot(16.000, h, 1);
		}
		if (floa[g] == 'D'){
			flo = flo + 13 * pot(16.000, h, 1);
		}
		if (floa[g] == 'E'){
			flo = flo + 14 * pot(16.000, h, 1);
		}
		if (floa[g] == 'F'){
			flo = flo + 15 * pot(16.000, h, 1);
		}
		g++;
		h--;
	}
	decimal = decimal + flo;
	if (negDec > 0){
		decimal = (negDec - decimal)*-1;
		if (flo > 0){
			double f = fl(decimal);
			f = 1 - f;
			decimal = returnDeciPart(decimal) - f;
		}
	}
	return decimal;
}

void decimalToBinary(double decimal, char path[DIM], int bp){
	FILE *open = NULL;
	int i = 0, j = 0, rest = 0, h = 0, res = 0, ct = 0, cou, c = 0;
	double decimal1 = 0, quotient = 2, quotient1 = 2, mult = 0, mul = 0, decimal2 = 0;
	double sN = 0, sN1 = 0, sN2 = 0;
	char binary[DIM] = "", binary2[DIM] = "", binaryexp[DIM] = "";
	if (decimal >= 0){
		sN = log10(decimal) / log10(2.0);
		sN1 = quo(sN);
		sN2 = pow(2.0, multi(sN));
	}
	else{
		if (decimal < 0){
			decimal = decimal*-1;
			sN = log10(decimal) / log10(2.0);
			sN1 = quo(sN);
			sN2 = pow(2.0, multi(sN))*-1;
			decimal = decimal*-1;
		}
	}
	if (sN1 <= 5 && sN1 >= -4 || decimal == 0 || bp != -1){
		decimal1 = decimal;
		if (decimal < 0){
			c = 0;
			decimal1 = decimal1*-1;
			while (quotient1 > 1){
				quotient1 = decimal1 / 2;
				decimal1 = quotient1;
				c++;
			}
			c++;
			while (c % 8 != 0){
				c++;
			}
			decimal1 = pot(2.000, c, 1) + decimal;
		}
		while (quotient > 1){
			quotient = decimal1 / 2;
			rest = re(decimal1, 2);
			binary[i] = rest + '0';
			decimal1 = quotient;
			i++;
		}
		binary[i] = quotient + '0'; i++;
		binary[i] = '\0';
		i--;
		while (i != -1){
			binary2[j] = binary[i];
			i--;
			j++;
		}
		binary2[j] = '\0';
		mult = multi(decimal);
		if (mult < 0 && bp != 0){
			mult = mult*-1;
		}
		if (mult > 0 && bp != 0){
			i = 0;
			cou = 0;
			while (binary2[i] != '\0'){ i++; }
			binary2[i] = '.';
			i++;
			while (res == 0){
				mult = mult * 2;
				res = quo(mult);
				binary2[i] = res + '0';
				mult = multi(mult);
				i++;
			}
			while (cou < 20 && bp == -1 || cou < bp - 1){
				mult = mult * 2;
				res = quo(mult);
				binary2[i] = res + '0';
				mult = multi(mult);
				i++;
				cou++;
			}
			binary2[i] = '\0';
		}
		if (binary2[0] == '0'){
			i = 0;
			while (binary2[i] != '\0'){
				binary2[i] = binary2[i + 1];
				i++;
			}
		}
		while (open == NULL){
			open = fopen(path, "a+");
		}
		if (multi(decimal) == 0 || bp == 0){
			if (decimal >= 0){
				fprintf(open, "In binary=%s\n", binary2);
				if (path[0] == 'h'&&path[1] == 'i'&&path[2] == 's'&&path[3] == 't'&&path[4] == 'o'&&path[5] == 'r'&&path[6] == 'y'&&path[7] == '.'&&path[8] == 't'&&path[9] == 'x'&&path[10] == 't')
					printf("In binary=%s\n", binary2);
			}
			if (decimal < 0){
				fprintf(open, "In binary=-%s\n", binary2);
				if (path[0] == 'h'&&path[1] == 'i'&&path[2] == 's'&&path[3] == 't'&&path[4] == 'o'&&path[5] == 'r'&&path[6] == 'y'&&path[7] == '.'&&path[8] == 't'&&path[9] == 'x'&&path[10] == 't')
					printf("In binary=-%s\n", binary2);
			}
		}
		else{
			for (i = 0; binary2[i] != '\0'; i++){
			}
			i--;
			if (binary2[i] == '0'){
				while (binary2[i] == '0'){
					i--;
				}
				i++;
				binary2[i] = '\0';
			}
			if (decimal >= 0){
				fprintf(open, "In binary=%s\n", binary2);
				if (path[0] == 'h'&&path[1] == 'i'&&path[2] == 's'&&path[3] == 't'&&path[4] == 'o'&&path[5] == 'r'&&path[6] == 'y'&&path[7] == '.'&&path[8] == 't'&&path[9] == 'x'&&path[10] == 't')
					printf("In binary=%s\n", binary2);
			}
			if (decimal < 0){
				fprintf(open, "In binary=-%s\n", binary2);
				if (path[0] == 'h'&&path[1] == 'i'&&path[2] == 's'&&path[3] == 't'&&path[4] == 'o'&&path[5] == 'r'&&path[6] == 'y'&&path[7] == '.'&&path[8] == 't'&&path[9] == 'x'&&path[10] == 't')
					printf("In binary=-%s\n", binary2);
			}
		}
		fclose(open);
	}
	else{
		decimal = sN2;
		decimal1 = decimal;
		if (decimal < 0){
			c = 0;
			decimal1 = decimal1*-1;
			while (quotient1 > 1){
				quotient1 = decimal1 / 2;
				decimal1 = quotient1;
				c++;
			}
			c++;
			while (c % 8 != 0){
				c++;
			}
			decimal1 = pot(2.000, c, 1) + decimal;
		}
		while (quotient > 1){
			quotient = decimal1 / 2;
			rest = re(decimal1, 2);
			binary[i] = rest + '0';
			decimal1 = quotient;
			i++;
		}
		binary[i] = quotient + '0'; i++;
		binary[i] = '\0';
		i--;
		while (i != -1){
			binary2[j] = binary[i];
			i--;
			j++;
		}
		binary2[j] = '\0';
		mult = multi(decimal);
		if (mult < 0){
			mult = mult*-1;
		}
		if (mult != 0){
			i = 0;
			cou = 0;
			while (binary2[i] != '\0'){ i++; }
			binary2[i] = '.';
			i++;
			while (res == 0){
				mult = mult * 2;
				res = quo(mult);
				binary2[i] = res + '0';
				mult = multi(mult);
				i++;
			}
			while (cou < 20){
				mult = mult * 2;
				res = quo(mult);
				binary2[i] = res + '0';
				mult = multi(mult);
				i++;
				cou++;
			}
			binary2[i] = '\0';
		}
		if (binary2[0] == '0'){
			i = 0;
			while (binary2[i] != '\0'){
				binary2[i] = binary2[i + 1];
				i++;
			}
		}
		i = 0; j = 0; rest = 0; h = 0; res = 0; ct = 0; cou; c = 0;
		decimal1 = 0; quotient = 2; quotient1 = 2; mult = 0; mul = 0;
		binary[0] = '\0';
		decimal2 = sN1;
		decimal1 = decimal2;
		if (decimal2 < 0){
			c = 0;
			decimal1 = decimal1*-1;
			while (quotient1 > 1){
				quotient1 = decimal1 / 2;
				decimal1 = quotient1;
				c++;
			}
			c++;
			while (c % 8 != 0){
				c++;
			}
			decimal1 = pot(2.000, c, 1) + decimal2;
		}
		while (quotient > 1){
			quotient = decimal1 / 2;
			rest = re(decimal1, 2);
			binary[i] = rest + '0';
			decimal1 = quotient;
			i++;
		}
		binary[i] = quotient + '0'; i++;
		binary[i] = '\0';
		i--;
		while (i != -1){
			binaryexp[j] = binary[i];
			i--;
			j++;
		}
		binaryexp[j] = '\0';
		mult = multi(decimal2);
		if (mult < 0){
			mult = mult*-1;
		}
		if (mult > 0){
			i = 0;
			cou = 0;
			while (binaryexp[i] != '\0'){ i++; }
			binaryexp[i] = '.';
			i++;
			while (res == 0){
				mult = mult * 2;
				res = quo(mult);
				binaryexp[i] = res + '0';
				mult = multi(mult);
				i++;
			}
			while (cou < 20){
				mult = mult * 2;
				res = quo(mult);
				binaryexp[i] = res + '0';
				mult = multi(mult);
				i++;
				cou++;
			}
			binaryexp[i] = '\0';
		}
		if (binaryexp[0] == '0'){
			i = 0;
			while (binaryexp[i] != '\0'){
				binaryexp[i] = binaryexp[i + 1];
				i++;
			}
		}

		while (open == NULL){
			open = fopen(path, "a+");
		}
		if (multi(decimal) == 0){
			if (decimal >= 0 && decimal2 >= 0){
				fprintf(open, "In binary=%sx10^%s\n", binary2, binaryexp);
				if (path[0] == 'h'&&path[1] == 'i'&&path[2] == 's'&&path[3] == 't'&&path[4] == 'o'&&path[5] == 'r'&&path[6] == 'y'&&path[7] == '.'&&path[8] == 't'&&path[9] == 'x'&&path[10] == 't')
					printf("In binary=%sx10^%s\n", binary2, binaryexp);
			}
			if (decimal < 0 && decimal2 < 0){
				fprintf(open, "In binary=-%sx10^-%s\n", binary2, binaryexp);
				if (path[0] == 'h'&&path[1] == 'i'&&path[2] == 's'&&path[3] == 't'&&path[4] == 'o'&&path[5] == 'r'&&path[6] == 'y'&&path[7] == '.'&&path[8] == 't'&&path[9] == 'x'&&path[10] == 't')
					printf("In binary=-%sx10^-%s\n", binary2, binaryexp);
			}
			if (decimal >= 0 && decimal2 < 0){
				fprintf(open, "In binary=%sx10^-%s\n", binary2, binaryexp);
				if (path[0] == 'h'&&path[1] == 'i'&&path[2] == 's'&&path[3] == 't'&&path[4] == 'o'&&path[5] == 'r'&&path[6] == 'y'&&path[7] == '.'&&path[8] == 't'&&path[9] == 'x'&&path[10] == 't')
					printf("In binary=%sx10^-%s\n", binary2, binaryexp);
			}
			if (decimal < 0 && decimal2 >= 0){
				fprintf(open, "In binary=-%sx10^%s\n", binary2, binaryexp);
				if (path[0] == 'h'&&path[1] == 'i'&&path[2] == 's'&&path[3] == 't'&&path[4] == 'o'&&path[5] == 'r'&&path[6] == 'y'&&path[7] == '.'&&path[8] == 't'&&path[9] == 'x'&&path[10] == 't')
					printf("In binary=-%sx10^%s\n", binary2, binaryexp);
			}
		}
		else{
			for (i = 0; binary2[i] != '\0'; i++){
			}
			i--;
			if (binary2[i] == '0'){
				while (binary2[i] == '0'){
					i--;
				}
				i++;
				binary2[i] = '\0';
			}
			if (decimal >= 0 && decimal2 >= 0){
				fprintf(open, "In binary=%sx10^%s\n", binary2, binaryexp);
				if (path[0] == 'h'&&path[1] == 'i'&&path[2] == 's'&&path[3] == 't'&&path[4] == 'o'&&path[5] == 'r'&&path[6] == 'y'&&path[7] == '.'&&path[8] == 't'&&path[9] == 'x'&&path[10] == 't')
					printf("In binary=%sx10^%s\n", binary2, binaryexp);
			}
			if (decimal < 0 && decimal2 < 0){
				fprintf(open, "In binary=-%sx10^-%s\n", binary2, binaryexp);
				if (path[0] == 'h'&&path[1] == 'i'&&path[2] == 's'&&path[3] == 't'&&path[4] == 'o'&&path[5] == 'r'&&path[6] == 'y'&&path[7] == '.'&&path[8] == 't'&&path[9] == 'x'&&path[10] == 't')
					printf("In binary=-%sx10^-%s\n", binary2, binaryexp);
			}
			if (decimal >= 0 && decimal2 < 0){
				fprintf(open, "In binary=%sx10^-%s\n", binary2, binaryexp);
				if (path[0] == 'h'&&path[1] == 'i'&&path[2] == 's'&&path[3] == 't'&&path[4] == 'o'&&path[5] == 'r'&&path[6] == 'y'&&path[7] == '.'&&path[8] == 't'&&path[9] == 'x'&&path[10] == 't')
					printf("In binary=%sx10^-%s\n", binary2, binaryexp);
			}
			if (decimal < 0 && decimal2 >= 0){
				fprintf(open, "In binary=-%sx10^%s\n", binary2, binaryexp);
				if (path[0] == 'h'&&path[1] == 'i'&&path[2] == 's'&&path[3] == 't'&&path[4] == 'o'&&path[5] == 'r'&&path[6] == 'y'&&path[7] == '.'&&path[8] == 't'&&path[9] == 'x'&&path[10] == 't')
					printf("In binary=-%sx10^%s\n", binary2, binaryexp);
			}
		}
		fclose(open);
	}
}

void decimalToOctal(double decimal, char path[DIM], int op){
	FILE *open = NULL;
	char octal[DIM] = "", octal2[DIM] = "", octalexp[DIM] = "";
	double quotient, quotient1, decimal1, decimal2 = 0, mult, sN = 0, sN1 = 0, sN2 = 0;
	int c, j, i, rest, cou, res = 0;
	decimal1 = decimal; i = 0; j = 0; quotient = 8; quotient1 = 8;
	if (decimal >= 0){
		sN = log10(decimal) / log10(8.0);
		sN1 = quo(sN);
		sN2 = pow(8.0, multi(sN));
	}
	else{
		if (decimal < 0){
			decimal = decimal*-1;
			sN = log10(decimal) / log10(8.0);
			sN1 = quo(sN);
			sN2 = pow(8.0, multi(sN))*-1;
			decimal = decimal*-1;
		}
	}
	if (sN1 <= 5 && sN1 >= -4 || decimal == 0 || op != -1){
		if (decimal < 0){
			c = 0;
			decimal1 = decimal1*-1;
			while (quotient1 > 7){
				quotient1 = decimal1 / 8;
				decimal1 = quotient1;
				c++;
			}
			c++;
			while (c % 8 != 0){
				c++;
			}
			decimal1 = pot(8.000, c, 1) + decimal;
		}
		while (quotient > 7){
			quotient = decimal1 / 8;
			rest = re(decimal1, 8);
			octal[i] = rest + '0';
			decimal1 = quotient;
			i++;
		}
		octal[i] = quotient + '0'; i++;
		octal[i] = '\0';
		i--;
		while (i != -1){
			octal2[j] = octal[i];
			i--;
			j++;
		}
		octal2[j] = '\0';
		mult = multi(decimal);
		if (mult < 0 && op != 0){
			mult = mult*-1;
		}
		if (mult > 0 && op != 0){
			i = 0;
			cou = 0;
			while (octal2[i] != '\0'){ i++; }
			octal2[i] = '.';
			i++;
			while (res == 0){
				mult = mult * 8;
				res = quo(mult);
				octal2[i] = res + '0';
				mult = multi(mult);
				i++;
			}
			while (cou < 20 && op == -1 || cou < op - 1){
				mult = mult * 8;
				res = quo(mult);
				octal2[i] = res + '0';
				mult = multi(mult);
				i++;
				cou++;
			}
			octal2[i] = '\0';
		}
		if (octal2[0] == '0'){
			i = 0;
			while (octal2[i] != '\0'){
				octal2[i] = octal2[i + 1];
				i++;
			}
		}
		while (open == NULL){
			open = fopen(path, "a+");
		}
		if (multi(decimal) == 0 || op == 0){
			if (decimal >= 0){
				fprintf(open, "In octal=%s\n", octal2);
				if (path[0] == 'h'&&path[1] == 'i'&&path[2] == 's'&&path[3] == 't'&&path[4] == 'o'&&path[5] == 'r'&&path[6] == 'y'&&path[7] == '.'&&path[8] == 't'&&path[9] == 'x'&&path[10] == 't')
					printf("In octal=%s\n", octal2);
			}
			if (decimal < 0){
				fprintf(open, "In octal=-%s\n", octal2);
				if (path[0] == 'h'&&path[1] == 'i'&&path[2] == 's'&&path[3] == 't'&&path[4] == 'o'&&path[5] == 'r'&&path[6] == 'y'&&path[7] == '.'&&path[8] == 't'&&path[9] == 'x'&&path[10] == 't')
					printf("In octal=-%s\n", octal2);
			}
		}
		else{
			for (i = 0; octal2[i] != '\0'; i++){
			}
			i--;
			if (octal2[i] == '0'){
				while (octal2[i] == '0'){
					i--;
				}
				i++;
				octal2[i] = '\0';
			}
			if (decimal >= 0){
				fprintf(open, "In octal=%s\n", octal2);
				if (path[0] == 'h'&&path[1] == 'i'&&path[2] == 's'&&path[3] == 't'&&path[4] == 'o'&&path[5] == 'r'&&path[6] == 'y'&&path[7] == '.'&&path[8] == 't'&&path[9] == 'x'&&path[10] == 't')
					printf("In octal=%s\n", octal2);
			}
			if (decimal < 0){
				fprintf(open, "In octal=-%s\n", octal2);
				if (path[0] == 'h'&&path[1] == 'i'&&path[2] == 's'&&path[3] == 't'&&path[4] == 'o'&&path[5] == 'r'&&path[6] == 'y'&&path[7] == '.'&&path[8] == 't'&&path[9] == 'x'&&path[10] == 't')
					printf("In octal=-%s\n", octal2);
			}
		}
		fclose(open);
	}
	else{
		decimal = sN2;
		decimal1 = decimal;
		if (decimal < 0){
			c = 0;
			decimal1 = decimal1*-1;
			while (quotient1 > 7){
				quotient1 = decimal1 / 8;
				decimal1 = quotient1;
				c++;
			}
			c++;
			while (c % 8 != 0){
				c++;
			}
			decimal1 = pot(8.000, c, 1) + decimal;
		}
		while (quotient > 7){
			quotient = decimal1 / 8;
			rest = re(decimal1, 8);
			octal[i] = rest + '0';
			decimal1 = quotient;
			i++;
		}
		octal[i] = quotient + '0'; i++;
		octal[i] = '\0';
		i--;
		while (i != -1){
			octal2[j] = octal[i];
			i--;
			j++;
		}
		octal2[j] = '\0';
		mult = multi(decimal);
		if (mult < 0){
			mult = mult*-1;
		}
		if (mult > 0){
			i = 0;
			cou = 0;
			while (octal2[i] != '\0'){ i++; }
			octal2[i] = '.';
			i++;
			while (res == 0){
				mult = mult * 8;
				res = quo(mult);
				octal2[i] = res + '0';
				mult = multi(mult);
				i++;
			}
			while (cou < 20){
				mult = mult * 8;
				res = quo(mult);
				octal2[i] = res + '0';
				mult = multi(mult);
				i++;
				cou++;
			}
			octal2[i] = '\0';
		}
		if (octal2[0] == '0'){
			i = 0;
			while (octal2[i] != '\0'){
				octal2[i] = octal2[i + 1];
				i++;
			}
		}
		octal[0] = '\0';
		quotient = 8; quotient1 = 8; mult = 0;
		c = 0; j = 0; i = 0; rest = 0; cou = 15; res = 0;

		decimal2 = sN1;
		decimal1 = decimal2;
		if (decimal2 < 0){
			c = 0;
			decimal1 = decimal1*-1;
			while (quotient1 > 7){
				quotient1 = decimal1 / 8;
				decimal1 = quotient1;
				c++;
			}
			c++;
			while (c % 8 != 0){
				c++;
			}
			decimal1 = pot(8.000, c, 1) + decimal2;
		}
		while (quotient > 7){
			quotient = decimal1 / 8;
			rest = re(decimal1, 8);
			octal[i] = rest + '0';
			decimal1 = quotient;
			i++;
		}
		octal[i] = quotient + '0'; i++;
		octal[i] = '\0';
		i--;
		while (i != -1){
			octalexp[j] = octal[i];
			i--;
			j++;
		}
		octalexp[j] = '\0';

		mult = multi(decimal2);
		if (mult < 0){
			mult = mult*-1;
		}
		if (mult > 0){
			i = 0;
			cou = 0;
			while (octalexp[i] != '\0'){ i++; }
			octalexp[i] = '.';
			i++;
			while (res == 0){
				mult = mult * 8;
				res = quo(mult);
				octalexp[i] = res + '0';
				mult = multi(mult);
				i++;
			}
			while (cou < 20){
				mult = mult * 8;
				res = quo(mult);
				octalexp[i] = res + '0';
				mult = multi(mult);
				i++;
				cou++;
			}
			octalexp[i] = '\0';
		}
		if (octalexp[0] == '0'){
			i = 0;
			while (octalexp[i] != '\0'){
				octalexp[i] = octalexp[i + 1];
				i++;
			}
		}
		while (open == NULL){
			open = fopen(path, "a+");
		}
		if (multi(decimal) == 0){
			if (decimal >= 0 && decimal2 >= 0){
				fprintf(open, "In octal=%sx10^%s\n", octal2, octalexp);
				if (path[0] == 'h'&&path[1] == 'i'&&path[2] == 's'&&path[3] == 't'&&path[4] == 'o'&&path[5] == 'r'&&path[6] == 'y'&&path[7] == '.'&&path[8] == 't'&&path[9] == 'x'&&path[10] == 't')
					printf("In octal=%sx10^%s\n", octal2, octalexp);
			}
			if (decimal < 0 && decimal2 < 0){
				fprintf(open, "In octal=-%sx10^-%s\n", octal2, octalexp);
				if (path[0] == 'h'&&path[1] == 'i'&&path[2] == 's'&&path[3] == 't'&&path[4] == 'o'&&path[5] == 'r'&&path[6] == 'y'&&path[7] == '.'&&path[8] == 't'&&path[9] == 'x'&&path[10] == 't')
					printf("In octal=-%sx10^-%s\n", octal2, octalexp);
			}
			if (decimal >= 0 && decimal2 < 0){
				fprintf(open, "In octal=%sx10^-%s\n", octal2, octalexp);
				if (path[0] == 'h'&&path[1] == 'i'&&path[2] == 's'&&path[3] == 't'&&path[4] == 'o'&&path[5] == 'r'&&path[6] == 'y'&&path[7] == '.'&&path[8] == 't'&&path[9] == 'x'&&path[10] == 't')
					printf("In octal=%sx10^-%s\n", octal2, octalexp);
			}
			if (decimal < 0 && decimal2 >= 0){
				fprintf(open, "In octal=-%sx10^%s\n", octal2, octalexp);
				if (path[0] == 'h'&&path[1] == 'i'&&path[2] == 's'&&path[3] == 't'&&path[4] == 'o'&&path[5] == 'r'&&path[6] == 'y'&&path[7] == '.'&&path[8] == 't'&&path[9] == 'x'&&path[10] == 't')
					printf("In octal=-%sx10^%s\n", octal2, octalexp);
			}
		}
		else{
			for (i = 0; octal2[i] != '\0'; i++){
			}
			i--;
			if (octal2[i] == '0'){
				while (octal2[i] == '0'){
					i--;
				}
				i++;
				octal2[i] = '\0';
			}
			if (decimal >= 0 && decimal2 >= 0){
				fprintf(open, "In octal=%sx10^%s\n", octal2, octalexp);
				if (path[0] == 'h'&&path[1] == 'i'&&path[2] == 's'&&path[3] == 't'&&path[4] == 'o'&&path[5] == 'r'&&path[6] == 'y'&&path[7] == '.'&&path[8] == 't'&&path[9] == 'x'&&path[10] == 't')
					printf("In octal=%sx10^%s\n", octal2, octalexp);
			}
			if (decimal < 0 && decimal2 < 0){
				fprintf(open, "In octal=-%sx10^-%s\n", octal2, octalexp);
				if (path[0] == 'h'&&path[1] == 'i'&&path[2] == 's'&&path[3] == 't'&&path[4] == 'o'&&path[5] == 'r'&&path[6] == 'y'&&path[7] == '.'&&path[8] == 't'&&path[9] == 'x'&&path[10] == 't')
					printf("In octal=-%sx10^-%s\n", octal2, octalexp);
			}
			if (decimal >= 0 && decimal2 < 0){
				fprintf(open, "In octal=%sx10^-%s\n", octal2, octalexp);
				if (path[0] == 'h'&&path[1] == 'i'&&path[2] == 's'&&path[3] == 't'&&path[4] == 'o'&&path[5] == 'r'&&path[6] == 'y'&&path[7] == '.'&&path[8] == 't'&&path[9] == 'x'&&path[10] == 't')
					printf("In octal=%sx10^-%s\n", octal2, octalexp);
			}
			if (decimal < 0 && decimal2 >= 0){
				fprintf(open, "In octal=-%sx10^%s\n", octal2, octalexp);
				if (path[0] == 'h'&&path[1] == 'i'&&path[2] == 's'&&path[3] == 't'&&path[4] == 'o'&&path[5] == 'r'&&path[6] == 'y'&&path[7] == '.'&&path[8] == 't'&&path[9] == 'x'&&path[10] == 't')
					printf("In octal=-%sx10^%s\n", octal2, octalexp);
			}
		}
		fclose(open);
	}
}

void decimalToHexadecimal(double decimal, char path[DIM], int hp){
	FILE *open = NULL;
	char hexadecimal[DIM] = "", hexadecimal2[DIM] = "", hexadecimalexp[DIM] = "";
	double decimal1 = decimal, decimal2 = 0, quotient = 16, quotient1 = 16, mult, sN = 0, sN1 = 0, sN2 = 0;
	int res = 0, cou = 0, c = 0, rest = 0, i = 0, j = 0;
	if (decimal >= 0){
		sN = log10(decimal) / log10(16.0);
		sN1 = quo(sN);
		sN2 = pow(16.0, multi(sN));
	}
	else{
		if (decimal < 0){
			decimal = decimal*-1;
			sN = log10(decimal) / log10(16.0);
			sN1 = quo(sN);
			sN2 = pow(16.0, multi(sN))*-1;
			decimal = decimal*-1;
		}
	}
	if (sN1 <= 5 && sN1 >= -4 || decimal == 0 || hp != -1){
		if (decimal < 0){
			c = 0;
			decimal1 = decimal1*-1;
			while (quotient1 > 15){
				quotient1 = decimal1 / 16;
				decimal1 = quotient1;
				c++;
			}
			c++;
			while (c % 8 != 0){
				c++;
			}
			decimal1 = pow(16.000, c) + decimal;
		}
		while (quotient > 15){
			quotient = decimal1 / 16;
			rest = re(decimal1, 16);
			if (rest < 10){
				hexadecimal[i] = rest + '0';
			}
			if (rest >= 10){
				if (rest == 10){
					hexadecimal[i] = 'A';
				}
				if (rest == 11){
					hexadecimal[i] = 'B';
				}
				if (rest == 12){
					hexadecimal[i] = 'C';
				}
				if (rest == 13){
					hexadecimal[i] = 'D';
				}
				if (rest == 14){
					hexadecimal[i] = 'E';
				}
				if (rest == 15){
					hexadecimal[i] = 'F';
				}
			}
			if (decimal < 1E10){
				quotient = quo(quotient);
			}
			decimal1 = quotient;
			i++;
		}
		if (quotient < 10){
			hexadecimal[i] = quotient + '0';
		}
		if (quotient == 10){
			hexadecimal[i] = 'A';
		}
		if (quotient == 11){
			hexadecimal[i] = 'B';
		}
		if (quotient == 12){
			hexadecimal[i] = 'C';
		}
		if (quotient == 13){
			hexadecimal[i] = 'D';
		}
		if (quotient == 14){
			hexadecimal[i] = 'E';
		}
		if (quotient == 15){
			hexadecimal[i] = 'F';
		}
		i++;
		hexadecimal[i] = '\0';
		i--;
		while (i != -1){
			hexadecimal2[j] = hexadecimal[i];
			i--;
			j++;
		}
		hexadecimal2[j] = '\0';

		mult = multi(decimal);
		if (mult < 0 && hp != 0){
			mult = mult*-1;
		}
		if (mult > 0 && hp != 0){
			i = 0;
			cou = 0;
			while (hexadecimal2[i] != '\0'){ i++; }
			hexadecimal2[i] = '.';
			i++;
			while (res == 0){
				mult = mult * 16;
				res = quo(mult);
				if (res < 10){
					hexadecimal2[i] = res + '0';
				}
				if (res >= 10){
					if (res == 10){
						hexadecimal2[i] = 'A';
					}
					if (res == 11){
						hexadecimal2[i] = 'B';
					}
					if (res == 12){
						hexadecimal2[i] = 'C';
					}
					if (res == 13){
						hexadecimal2[i] = 'D';
					}
					if (res == 14){
						hexadecimal2[i] = 'E';
					}
					if (res == 15){
						hexadecimal2[i] = 'F';
					}
				}
				mult = multi(mult);
				i++;
			}
			while (cou < 20 && hp == -1 || cou < hp - 1){
				mult = mult * 16;
				res = quo(mult);
				if (res < 10){
					hexadecimal2[i] = res + '0';
				}
				if (res >= 10){
					if (res == 10){
						hexadecimal2[i] = 'A';
					}
					if (res == 11){
						hexadecimal2[i] = 'B';
					}
					if (res == 12){
						hexadecimal2[i] = 'C';
					}
					if (res == 13){
						hexadecimal2[i] = 'D';
					}
					if (res == 14){
						hexadecimal2[i] = 'E';
					}
					if (res == 15){
						hexadecimal2[i] = 'F';
					}
				}
				mult = multi(mult);
				i++;
				cou++;
			}
			hexadecimal2[i] = '\0';
		}
		if (hexadecimal2[0] == '0'){
			i = 0;
			while (hexadecimal2[i] != '\0'){
				hexadecimal2[i] = hexadecimal2[i + 1];
				i++;
			}
		}
		open = fopen(path, "a+");
		if (multi(decimal) == 0 || hp == 0){
			if (decimal >= 0){
				fprintf(open, "In hexadecimal=%s\n", hexadecimal2);
				if (path[0] == 'h'&&path[1] == 'i'&&path[2] == 's'&&path[3] == 't'&&path[4] == 'o'&&path[5] == 'r'&&path[6] == 'y'&&path[7] == '.'&&path[8] == 't'&&path[9] == 'x'&&path[10] == 't')
					printf("In hexadecimal=%s\n", hexadecimal2);
			}
			if (decimal < 0){
				fprintf(open, "In hexadecimal=-%s\n", hexadecimal2);
				if (path[0] == 'h'&&path[1] == 'i'&&path[2] == 's'&&path[3] == 't'&&path[4] == 'o'&&path[5] == 'r'&&path[6] == 'y'&&path[7] == '.'&&path[8] == 't'&&path[9] == 'x'&&path[10] == 't')
					printf("In hexadecimal=-%s\n", hexadecimal2);
			}
		}
		else{
			for (i = 0; hexadecimal2[i] != '\0'; i++){
			}
			i--;
			if (hexadecimal2[i] == '0'){
				while (hexadecimal2[i] == '0'){
					i--;
				}
				i++;
				hexadecimal2[i] = '\0';
			}
			if (decimal >= 0){
				fprintf(open, "In hexadecimal=%s\n", hexadecimal2);
				if (path[0] == 'h'&&path[1] == 'i'&&path[2] == 's'&&path[3] == 't'&&path[4] == 'o'&&path[5] == 'r'&&path[6] == 'y'&&path[7] == '.'&&path[8] == 't'&&path[9] == 'x'&&path[10] == 't')
					printf("In hexadecimal=%s\n", hexadecimal2);
			}
			if (decimal < 0){
				fprintf(open, "In hexadecimal=-%s\n", hexadecimal2);
				if (path[0] == 'h'&&path[1] == 'i'&&path[2] == 's'&&path[3] == 't'&&path[4] == 'o'&&path[5] == 'r'&&path[6] == 'y'&&path[7] == '.'&&path[8] == 't'&&path[9] == 'x'&&path[10] == 't')
					printf("In hexadecimal=-%s\n", hexadecimal2);
			}
		}
		fclose(open);
	}
	else{
		decimal = sN2;
		decimal1 = decimal;
		if (decimal < 0){
			c = 0;
			decimal1 = decimal1*-1;
			while (quotient1 > 15){
				quotient1 = decimal1 / 16;
				decimal1 = quotient1;
				c++;
			}
			c++;
			while (c % 8 != 0){
				c++;
			}
			decimal1 = pow(16.000, c) + decimal;
		}
		while (quotient > 15){
			quotient = decimal1 / 16;
			rest = re(decimal1, 16);
			if (rest < 10){
				hexadecimal[i] = rest + '0';
			}
			if (rest >= 10){
				if (rest == 10){
					hexadecimal[i] = 'A';
				}
				if (rest == 11){
					hexadecimal[i] = 'B';
				}
				if (rest == 12){
					hexadecimal[i] = 'C';
				}
				if (rest == 13){
					hexadecimal[i] = 'D';
				}
				if (rest == 14){
					hexadecimal[i] = 'E';
				}
				if (rest == 15){
					hexadecimal[i] = 'F';
				}
			}
			if (decimal < 1E10){
				quotient = quo(quotient);
			}
			decimal1 = quotient;
			i++;
		}
		if (quotient < 10){
			hexadecimal[i] = quotient + '0';
		}
		if (quotient == 10){
			hexadecimal[i] = 'A';
		}
		if (quotient == 11){
			hexadecimal[i] = 'B';
		}
		if (quotient == 12){
			hexadecimal[i] = 'C';
		}
		if (quotient == 13){
			hexadecimal[i] = 'D';
		}
		if (quotient == 14){
			hexadecimal[i] = 'E';
		}
		if (quotient == 15){
			hexadecimal[i] = 'F';
		}
		i++;
		hexadecimal[i] = '\0';
		i--;
		while (i != -1){
			hexadecimal2[j] = hexadecimal[i];
			i--;
			j++;
		}
		hexadecimal2[j] = '\0';

		mult = multi(decimal);
		if (mult < 0){
			mult = mult*-1;
		}
		if (mult > 0){
			i = 0;
			cou = 0;
			while (hexadecimal2[i] != '\0'){ i++; }
			hexadecimal2[i] = '.';
			i++;
			while (res == 0){
				mult = mult * 16;
				res = quo(mult);
				if (res < 10){
					hexadecimal2[i] = res + '0';
				}
				if (res >= 10){
					if (res == 10){
						hexadecimal2[i] = 'A';
					}
					if (res == 11){
						hexadecimal2[i] = 'B';
					}
					if (res == 12){
						hexadecimal2[i] = 'C';
					}
					if (res == 13){
						hexadecimal2[i] = 'D';
					}
					if (res == 14){
						hexadecimal2[i] = 'E';
					}
					if (res == 15){
						hexadecimal2[i] = 'F';
					}
				}
				mult = multi(mult);
				i++;
			}
			while (cou < 20){
				mult = mult * 16;
				res = quo(mult);
				if (res < 10){
					hexadecimal2[i] = res + '0';
				}
				if (res >= 10){
					if (res == 10){
						hexadecimal2[i] = 'A';
					}
					if (res == 11){
						hexadecimal2[i] = 'B';
					}
					if (res == 12){
						hexadecimal2[i] = 'C';
					}
					if (res == 13){
						hexadecimal2[i] = 'D';
					}
					if (res == 14){
						hexadecimal2[i] = 'E';
					}
					if (res == 15){
						hexadecimal2[i] = 'F';
					}
				}
				mult = multi(mult);
				i++;
				cou++;
			}
			hexadecimal2[i] = '\0';
		}
		if (hexadecimal2[0] == '0'){
			i = 0;
			while (hexadecimal2[i] != '\0'){
				hexadecimal2[i] = hexadecimal2[i + 1];
				i++;
			}
		}
		hexadecimal[0] = '\0';
		quotient = 16; quotient1 = 16; mult = 0;
		res = 0; cou = 0; c = 0; rest = 0; i = 0; j = 0;
		decimal2 = sN1;
		decimal1 = decimal2;

		if (decimal2 < 0){
			c = 0;
			decimal1 = decimal1*-1;
			while (quotient1 > 15){
				quotient1 = decimal1 / 16;
				decimal1 = quotient1;
				c++;
			}
			c++;
			while (c % 8 != 0){
				c++;
			}
			decimal1 = pow(16.000, c) + decimal2;
		}
		while (quotient > 15){
			quotient = decimal1 / 16;
			rest = re(decimal1, 16);
			if (rest < 10){
				hexadecimal[i] = rest + '0';
			}
			if (rest >= 10){
				if (rest == 10){
					hexadecimal[i] = 'A';
				}
				if (rest == 11){
					hexadecimal[i] = 'B';
				}
				if (rest == 12){
					hexadecimal[i] = 'C';
				}
				if (rest == 13){
					hexadecimal[i] = 'D';
				}
				if (rest == 14){
					hexadecimal[i] = 'E';
				}
				if (rest == 15){
					hexadecimal[i] = 'F';
				}
			}
			if (decimal < 1E10){
				quotient = quo(quotient);
			}
			decimal1 = quotient;
			i++;
		}
		if (quotient < 10){
			hexadecimal[i] = quotient + '0';
		}
		if (quotient == 10){
			hexadecimal[i] = 'A';
		}
		if (quotient == 11){
			hexadecimal[i] = 'B';
		}
		if (quotient == 12){
			hexadecimal[i] = 'C';
		}
		if (quotient == 13){
			hexadecimal[i] = 'D';
		}
		if (quotient == 14){
			hexadecimal[i] = 'E';
		}
		if (quotient == 15){
			hexadecimal[i] = 'F';
		}
		i++;
		hexadecimal[i] = '\0';
		i--;
		while (i != -1){
			hexadecimalexp[j] = hexadecimal[i];
			i--;
			j++;
		}
		hexadecimalexp[j] = '\0';

		mult = multi(decimal2);
		if (mult < 0){
			mult = mult*-1;
		}
		if (mult > 0){
			i = 0;
			cou = 0;
			while (hexadecimalexp[i] != '\0'){ i++; }
			hexadecimalexp[i] = '.';
			i++;
			while (res == 0){
				mult = mult * 16;
				res = quo(mult);
				if (res < 10){
					hexadecimalexp[i] = res + '0';
				}
				if (res >= 10){
					if (res == 10){
						hexadecimalexp[i] = 'A';
					}
					if (res == 11){
						hexadecimalexp[i] = 'B';
					}
					if (res == 12){
						hexadecimalexp[i] = 'C';
					}
					if (res == 13){
						hexadecimalexp[i] = 'D';
					}
					if (res == 14){
						hexadecimalexp[i] = 'E';
					}
					if (res == 15){
						hexadecimalexp[i] = 'F';
					}
				}
				mult = multi(mult);
				i++;
			}
			while (cou < 20){
				mult = mult * 16;
				res = quo(mult);
				if (res < 10){
					hexadecimalexp[i] = res + '0';
				}
				if (res >= 10){
					if (res == 10){
						hexadecimalexp[i] = 'A';
					}
					if (res == 11){
						hexadecimalexp[i] = 'B';
					}
					if (res == 12){
						hexadecimalexp[i] = 'C';
					}
					if (res == 13){
						hexadecimalexp[i] = 'D';
					}
					if (res == 14){
						hexadecimalexp[i] = 'E';
					}
					if (res == 15){
						hexadecimalexp[i] = 'F';
					}
				}
				mult = multi(mult);
				i++;
				cou++;
			}
			hexadecimalexp[i] = '\0';
		}
		if (hexadecimalexp[0] == '0'){
			i = 0;
			while (hexadecimalexp[i] != '\0'){
				hexadecimalexp[i] = hexadecimalexp[i + 1];
				i++;
			}
		}
		while (open == NULL){
			open = fopen(path, "a+");
		}
		if (multi(decimal) == 0){
			if (decimal >= 0 && decimal2 >= 0){
				fprintf(open, "In hexadecimal=%sx10^%s\n", hexadecimal2, hexadecimalexp);
				if (path[0] == 'h'&&path[1] == 'i'&&path[2] == 's'&&path[3] == 't'&&path[4] == 'o'&&path[5] == 'r'&&path[6] == 'y'&&path[7] == '.'&&path[8] == 't'&&path[9] == 'x'&&path[10] == 't')
					printf("In hexadecimal=%sx10^%s\n", hexadecimal2, hexadecimalexp);
			}
			if (decimal < 0 && decimal2 < 0){
				fprintf(open, "In hexadecimal=-%sx10^-%s\n", hexadecimal2, hexadecimalexp);
				if (path[0] == 'h'&&path[1] == 'i'&&path[2] == 's'&&path[3] == 't'&&path[4] == 'o'&&path[5] == 'r'&&path[6] == 'y'&&path[7] == '.'&&path[8] == 't'&&path[9] == 'x'&&path[10] == 't')
					printf("In hexadecimal=-%sx10^-%s\n", hexadecimal2, hexadecimalexp);
			}
			if (decimal >= 0 && decimal2 < 0){
				fprintf(open, "In hexadecimal=-%sx10^-%s\n", hexadecimal2, hexadecimalexp);
				if (path[0] == 'h'&&path[1] == 'i'&&path[2] == 's'&&path[3] == 't'&&path[4] == 'o'&&path[5] == 'r'&&path[6] == 'y'&&path[7] == '.'&&path[8] == 't'&&path[9] == 'x'&&path[10] == 't')
					printf("In hexadecimal=%sx10^-%s\n", hexadecimal2, hexadecimalexp);
			}
			if (decimal < 0 && decimal2 >= 0){
				fprintf(open, "In hexadecimal=-%sx10^%s\n", hexadecimal2, hexadecimalexp);
				if (path[0] == 'h'&&path[1] == 'i'&&path[2] == 's'&&path[3] == 't'&&path[4] == 'o'&&path[5] == 'r'&&path[6] == 'y'&&path[7] == '.'&&path[8] == 't'&&path[9] == 'x'&&path[10] == 't')
					printf("In hexadecimal=-%sx10^%s\n", hexadecimal2, hexadecimalexp);
			}
		}
		else{
			for (i = 0; hexadecimal2[i] != '\0'; i++){
			}
			i--;
			if (hexadecimal2[i] == '0'){
				while (hexadecimal2[i] == '0'){
					i--;
				}
				i++;
				hexadecimal2[i] = '\0';
			}
			if (decimal >= 0 && decimal2 >= 0){
				fprintf(open, "In hexadecimal=%sx10^%s\n", hexadecimal2, hexadecimalexp);
				if (path[0] == 'h'&&path[1] == 'i'&&path[2] == 's'&&path[3] == 't'&&path[4] == 'o'&&path[5] == 'r'&&path[6] == 'y'&&path[7] == '.'&&path[8] == 't'&&path[9] == 'x'&&path[10] == 't')
					printf("In hexadecimal=%sx10^%s\n", hexadecimal2, hexadecimalexp);
			}
			if (decimal < 0 && decimal2 < 0){
				fprintf(open, "In hexadecimal=-%sx10^-%s\n", hexadecimal2, hexadecimalexp);
				if (path[0] == 'h'&&path[1] == 'i'&&path[2] == 's'&&path[3] == 't'&&path[4] == 'o'&&path[5] == 'r'&&path[6] == 'y'&&path[7] == '.'&&path[8] == 't'&&path[9] == 'x'&&path[10] == 't')
					printf("In hexadecimal=-%sx10^-%s\n", hexadecimal2, hexadecimalexp);
			}
			if (decimal >= 0 && decimal2 < 0){
				fprintf(open, "In hexadecimal=%sx10^-%s\n", hexadecimal2, hexadecimalexp);
				if (path[0] == 'h'&&path[1] == 'i'&&path[2] == 's'&&path[3] == 't'&&path[4] == 'o'&&path[5] == 'r'&&path[6] == 'y'&&path[7] == '.'&&path[8] == 't'&&path[9] == 'x'&&path[10] == 't')
					printf("In hexadecimal=%sx10^-%s\n", hexadecimal2, hexadecimalexp);
			}
			if (decimal < 0 && decimal2 >= 0){
				fprintf(open, "In hexadecimal=-%sx10^%s\n", hexadecimal2, hexadecimalexp);
				if (path[0] == 'h'&&path[1] == 'i'&&path[2] == 's'&&path[3] == 't'&&path[4] == 'o'&&path[5] == 'r'&&path[6] == 'y'&&path[7] == '.'&&path[8] == 't'&&path[9] == 'x'&&path[10] == 't')
					printf("In hexadecimal=-%sx10^%s\n", hexadecimal2, hexadecimalexp);
			}
		}
		fclose(open);
	}
}

double returnDeciPart(double number){
	double qu;
	char quot[DIM] = "", quo[DIM] = "";
	char *pointer;
	int i = 0;
	sprintf(quot, "%.100f", number);
	while (quot[i] != '.'){
		quo[i] = quot[i];
		i++;
	}
	quo[i] = '\0';
	qu = strtod(quo, &pointer);
	return qu;
}

double fl(double number){
	double qu, res = 0;
	char quot[DIM] = "", quo[DIM] = "0.";
	char *pointer;
	int i = 0, j = 2;
	sprintf(quot, "%f", number);
	while (quot[i] != '.'){
		i++;
	}
	i++;
	while (quot[i] != '\0'){
		quo[j] = quot[i];
		j++; i++;
	}
	quo[j] = '\0';
	qu = strtod(quo, &pointer);
	return qu;
}

double multi(double multip){
	double mu;
	char mult[DIM] = "", mul[DIM] = "";
	char *pointer;
	int i = 0, j = 0;
	sprintf(mult, "%.500f", multip);
	mul[0] = '0'; i++;
	while (mult[j] != '.'){ j++; }
	while (mult[j] != '\0'){
		mul[i] = mult[j];
		i++;
		j++;
	}
	mul[i] = '\0';
	mu = strtod(mul, &pointer);
	if (multip < 0 && mu >= 0){
		mu = mu*-1;
	}
	return mu;

}

double quo(double quotient){
	double qu, quoti;
	char quot[DIM] = "", quo[DIM] = "";
	char *pointer;
	int i = 0;
	sprintf(quot, "%.500f", quotient);
	while (quot[i] != '.'){
		quo[i] = quot[i];
		i++;
	}
	quo[i] = '\0';
	qu = strtod(quo, &pointer);
	quoti = quotient - (quotient - qu);
	return quoti;
}

double qu(double dividend, double divider){
	double quotient, qu, rest = 0;
	char quot[DIM] = "", quo[DIM] = "";
	char *pointer;
	int i = 0;
	quotient = dividend / divider;
	sprintf(quot, "%f", quotient);
	while (quot[i] != '.'){
		quo[i] = quot[i];
		i++;
	}
	quo[i] = '\0';
	qu = strtod(quo, &pointer);
	return qu;
}

void qu_complex(double dividend, double dividendI, double divider, double dividerI){
	double  rest = 0;
	char quot[DIM] = "", quotI[DIM] = "", quo[DIM] = "", quoI[DIM] = "";
	char *pointer;
	int i = 0;
	division(dividend, dividendI, divider, dividerI);

	sprintf(quot, "%f", resultR);
	while (quot[i] != '.'){
		quo[i] = quot[i];
		i++;
	}
	quo[i] = '\0';
	resultR = strtod(quo, &pointer);
	i = 0;
	sprintf(quotI, "%f", resultI);
	while (quotI[i] != '.'){
		quoI[i] = quotI[i];
		i++;
	}
	quoI[i] = '\0';
	resultI = strtod(quoI, &pointer);
	round_complex();
}

double re(double dividend, double divider){
	double quotient, qui = 0, res, rest = 0;
	char quot[DIM] = "", quo[DIM] = "";
	char *pointer;
	int i = 0;
	quotient = dividend / divider;
	sprintf(quot, "%.300f", quotient);
	while (quot[i] != '.'){
		quo[i] = quot[i];
		i++;
	}
	quo[i] = '\0';
	qui = strtod(quo, &pointer);
	res = quotient - qui;
	rest = qu(res*divider, 1);
	return rest;
}

void re_complex(double dividend, double dividendI, double divider, double dividerI){
	double  qui = 0, rest = 0;
	qu_complex(dividend, dividendI, divider, dividerI);
	multiplication(resultR, resultI, divider, dividerI);
	subtraction(dividend, dividendI, resultR, resultI);
	round_complex();
}

double numericalSystems(char numSystem[DIM]){
	double result = 0;
	char system = ' ';
	int i, j = 0;
	system = numSystem[0];
	if (numSystem[1] == '_'){
		numSystem[1] = '-';
	}
	for (i = 1; numSystem[i] != '\0'; i++){
		numSystem[i - 1] = numSystem[i];
		if (numSystem[i - 1] == '.'){
			j++;
			if (j == 2){
				numSystem[i - 1] = '\0';
			}
		}
	}
	numSystem[i - 1] = '\0';

	if (system == 'B'){
		result = binaryToDecimal(numSystem);
	}
	if (system == 'O'){
		result = octalToDecimal(numSystem);
	}
	if (system == 'H'){
		result = hexadecimalToDecimal(numSystem);
	}
	return result;
}

void numSystemsController(){
	FILE *open;
	int state = -1;
	char c[DIM] = "";
	while (state != 1 && state != 0){
		printf("Enable -> 1\nDisable -> 0\n");
		gets(c);
		state = arithSolver(c, 0);
		if (state != 1 && state != 0){
			printf("Error, incorrect choice.\n");
		}
	}
	open = fopen("numSystems.txt", "w");
	fprintf(open, "%d", state);
	fclose(open);
}

double arcfact(double f){
	int i = 1;
	if (f >= 0){
		while (fact(i) < f){
			i++;
		}
	}
	else{
		i = 0;
	}
	return i;
}

double fact(double d){
	double result = d;
	if (re(d, 1.0) == 0){
		if (d > 0){
			d--;
			while (d >= 1){
				result = result*d;
				d--;
			}
		}
		else{
			if (d == 0){
				result = 1;
			}
			else{
				result = 0;
			}
		}
	}
	else{
		result = 0;
	}
	return result;
}

void siPrefixController(){
	FILE *open;
	int state = -1;
	char c[DIM] = "";
	while (state != 1 && state != 0){
		printf("Enable -> 1\nDisable -> 0\n");
		gets(c);
		state = arithSolver(c, 0);
		if (state != 1 && state != 0){
			printf("Error, incorrect choice.\n");
		}
	}
	open = fopen("siPrefixes.txt", "w");
	fprintf(open, "%d", state);
	fclose(open);
}

void actualTimeController(){
	FILE *open;
	int state = -1;
	char c[DIM] = "";
	while (state != 1 && state != 0){
		printf("Enable -> 1\nDisable -> 0\n");
		gets(c);
		state = arithSolver(c, 0);
		if (state != 1 && state != 0){
			printf("Error, incorrect choice.\n");
		}
	}
	open = fopen("actualTime.txt", "w");
	fprintf(open, "%d", state);
	fclose(open);
}

int prefDet(double n, char path[DIM]){
	int y = 0;
	if (n < 0){
		n = n*-1;
		y = 1;
	}
	int a = 0;
	double result = 0;
	FILE *open;
	open = fopen(path, "a+");
	if (path[0] == 'h'&&path[1] == 'i'&&path[2] == 's'&&path[3] == 't'&&path[4] == 'o'&&path[5] == 'r'&&path[6] == 'y'&&path[7] == '.'&&path[8] == 't'&&path[9] == 'x'&&path[10] == 't'){
		a = 1;
	}

	if (n < 1E-21){
		result = n / 1E-24;
		if (y == 1){
			result = result*-1;
		}
		fprintf(open, "=%Gy (yocto-)\n", result);
		if (a == 1){
			printf("=%Gy (yocto-)\n", result);
		}
		fclose(open);
		return 0;
	}
	if (n < 1E-18){
		result = n / 1E-21;
		if (y == 1){
			result = result*-1;
		}
		fprintf(open, "=%Gz (zepto-)\n", result);
		if (a == 1){
			printf("=%Gz (zepto-)\n", result);
		}
		fclose(open);
		return 0;
	}
	if (n < 1E-15){
		result = n / 1E-18;
		if (y == 1){
			result = result*-1;
		}
		fprintf(open, "=%Ga (atto-)\n", result);
		if (a == 1){
			printf("=%Ga (atto-)\n", result);
		}
		fclose(open);
		return 0;
	}
	if (n < 1E-12){
		result = n / 1E-15;
		if (y == 1){
			result = result*-1;
		}
		fprintf(open, "=%Gf (femto-)\n", result);
		if (a == 1){
			printf("=%Gf (femto-)\n", result);
		}
		fclose(open);
		return 0;
	}
	if (n < 1E-9){
		result = n / 1E-12;
		if (y == 1){
			result = result*-1;
		}
		fprintf(open, "=%Gp (pico-)\n", result);
		if (a == 1){
			printf("=%Gp (pico-)\n", result);
		}
		fclose(open);
		return 0;
	}
	if (n < 1E-6){
		result = n / 1E-9;
		if (y == 1){
			result = result*-1;
		}
		fprintf(open, "=%Gn (nano-)\n", result);
		if (a == 1){
			printf("=%Gn (nano-)\n", result);
		}
		fclose(open);
		return 0;
	}
	if (n < 1E-3){
		result = n / 1E-6;
		if (y == 1){
			result = result*-1;
		}
		fprintf(open, "=%Gµ (micro-)\n", result);
		if (a == 1){
			printf("=%G%c (micro-)\n", result, 230);
		}
		fclose(open);
		return 0;
	}
	if (n < 1E-2){
		result = n / 1E-3;
		if (y == 1){
			result = result*-1;
		}
		fprintf(open, "=%Gm (milli-)\n", result);
		if (a == 1){
			printf("=%Gm (milli-)\n", result);
		}
		fclose(open);
		return 0;
	}
	if (n < 1E-1){
		result = n / 1E-2;
		if (y == 1){
			result = result*-1;
		}
		fprintf(open, "=%Gc (centi-)\n", result);
		if (a == 1){
			printf("=%Gc (centi-)\n", result);
		}
		fclose(open);
		return 0;
	}

	if (n < 1E1){
		result = n / 1E-1;
		if (y == 1){
			result = result*-1;
		}
		fprintf(open, "=%Gd (deci-)\n", result);
		if (a == 1){
			printf("=%Gd (deci-)\n", result);
		}
		fclose(open);
		return 0;
	}
	if (n < 1E2){
		result = n / 1E1;
		if (y == 1){
			result = result*-1;
		}
		fprintf(open, "=%Gda (deca-)\n", result);
		if (a == 1){
			printf("=%Gda (deca-)\n", result);
		}
		fclose(open);
		return 0;
	}
	if (n < 1E3){
		result = n / 1E2;
		if (y == 1){
			result = result*-1;
		}
		fprintf(open, "=%Gh (hecto-)\n", result);
		if (a == 1){
			printf("=%Gh (hecto-)\n", result);
		}
		fclose(open);
		return 0;
	}
	if (n < 1E6){
		result = n / 1E3;
		if (y == 1){
			result = result*-1;
		}
		fprintf(open, "=%Gk (kilo-)\n", result);
		if (a == 1){
			printf("=%Gk (kilo-)\n", result);
		}
		fclose(open);
		return 0;
	}
	if (n < 1E9){
		result = n / 1E6;
		if (y == 1){
			result = result*-1;
		}
		fprintf(open, "=%GM (mega-)\n", result);
		if (a == 1){
			printf("=%GM (mega-)\n", result);
		}
		fclose(open);
		return 0;
	}
	if (n < 1E12){
		result = n / 1E9;
		if (y == 1){
			result = result*-1;
		}
		fprintf(open, "=%GG (giga-)\n", result);
		if (a == 1){
			printf("=%GG (giga-)\n", result);
		}
		fclose(open);
		return 0;
	}
	if (n < 1E15){
		result = n / 1E12;
		if (y == 1){
			result = result*-1;
		}
		fprintf(open, "=%GT (tera-)\n", result);
		if (a == 1){
			printf("=%GT (tera-)\n", result);
		}
		fclose(open);
		return 0;
	}
	if (n < 1E18){
		result = n / 1E15;
		if (y == 1){
			result = result*-1;
		}
		fprintf(open, "=%GP (peta-)\n", result);
		if (a == 1){
			printf("=%GP (peta-)\n", result);
		}
		fclose(open);
		return 0;
	}
	if (n < 1E21){
		result = n / 1E18;
		if (y == 1){
			result = result*-1;
		}
		fprintf(open, "=%GE (exa-)\n", result);
		if (a == 1){
			printf("=%GE (exa-)\n", result);
		}
		fclose(open);
		return 0;
	}
	if (n < 1E24){
		result = n / 1E21;
		if (y == 1){
			result = result*-1;
		}
		fprintf(open, "=%GZ (zetta-)\n", result);
		if (a == 1){
			printf("=%GZ (zetta-)\n", result);
		}
		fclose(open);
		return 0;
	}
	if (n >= 1E24){
		result = n / 1E24;
		if (y == 1){
			result = result*-1;
		}
		fprintf(open, "=%GY (yotta-)\n", result);
		if (a == 1){
			printf("=%GY (yotta-)\n", result);
		}
		fclose(open);
		return 0;
	}
}

double convertToNumber(char number[DIM]){
	int i = 0, j = 0, num = 0, k = 0, l = 0, sig = 1, h = 0, m = 0, f = 0;
	char nu[DIM] = "";
	double result = 0, exp = 0;
	for (h = 0; number[h] != '\0'; h++){
		if (number[h] == 'E'){
			m = h;
			h++;
			f = 0;
			if (number[h] == '-'){
				sig = -1;
				h++;
			}
			while (number[h] != '\0'){
				nu[f] = number[h];
				f++; h++;
			}
			nu[f] = '\0';
			exp = convertToNumber(nu);
			number[m] = '.';
			number[m + 1] = '0';
			number[m + 2] = '\0';
		}
	}

	i = 0;
	while (number[i] != '.'&&number[i] != '\0'){
		i++;
	}
	i--;
	j = i;
	k = i;
	i++;
	while (number[i] != '\0'){
		i++;
	}
	l = strlen(number) - j - 4;
	for (i = 0; j >= 0; i++){
		nu[0] = number[i];
		nu[1] = '.';
		nu[2] = '0';
		nu[3] = '\0';
		num = atoi(nu);
		result = result + num*pot(10.0, j, 1);
		j--;
	}
	k = k + 2;
	i = 1;
	for (k; i <= l; k++){
		nu[0] = number[k];
		nu[1] = '.';
		nu[2] = '0';
		nu[3] = '\0';
		num = atoi(nu);
		result = result + num*pot(10.0, i*-1, 1);
		i++;
	}

	result = result*pot(10.0, exp*sig, 1);
	return result;
}

void Calendar(char yearCalendar[DIM], int year){
	FILE *open;
	int w = 0;
	char m30[DIM] = "  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30", m31[DIM] = "  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31", m29[DIM] = "  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29", m28[DIM] = "  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28", weekdays[DIM] = " Mo Tu We Th Fr Sa Su Mo Tu We Th Fr Sa Su Mo Tu We Th Fr Sa Su Mo Tu We Th Fr Sa Su Mo Tu We Th Fr Sa Su Mo Tu";
	open = fopen(yearCalendar, "w");
	fprintf(open, "____________________________________________________________________________________________________________________________\n\n                                                            %d\n____________________________________________________________________________________________________________________________\n", year);
	fprintf(open, "           |\n           |%s\n___________|________________________________________________________________________________________________________________\n           |\n", weekdays);
	fprintf(open, " January   |");
	fclose(open);
	DayofWeek(1, 1, year, yearCalendar);
	open = fopen(yearCalendar, "a+");
	fprintf(open, "%s\n", m31);
	fprintf(open, " February  |");
	fclose(open);
	DayofWeek(1, 2, year, yearCalendar);
	open = fopen(yearCalendar, "a+");
	if (year % 4 == 0){
		if (year % 100 == 0 && year % 400 != 0){
			fprintf(open, "%s\n", m28);
			fclose(open);
		}
		else{
			fprintf(open, "%s\n", m29);
			fclose(open);
		}
	}
	else{
		fprintf(open, "%s\n", m28);
		fclose(open);
	}
	open = fopen(yearCalendar, "a+");
	fprintf(open, " March     |");
	fclose(open);
	DayofWeek(1, 3, year, yearCalendar);
	open = fopen(yearCalendar, "a+");
	fprintf(open, "%s\n", m31);
	fprintf(open, " April     |");
	fclose(open);
	DayofWeek(1, 4, year, yearCalendar);
	open = fopen(yearCalendar, "a+");
	fprintf(open, "%s\n", m30);
	fprintf(open, " May       |");
	fclose(open);
	DayofWeek(1, 5, year, yearCalendar);
	open = fopen(yearCalendar, "a+");
	fprintf(open, "%s\n", m31);
	fprintf(open, " June      |");
	fclose(open);
	DayofWeek(1, 6, year, yearCalendar);
	open = fopen(yearCalendar, "a+");
	fprintf(open, "%s\n", m30);
	fprintf(open, " July      |");
	fclose(open);
	DayofWeek(1, 7, year, yearCalendar);
	open = fopen(yearCalendar, "a+");
	fprintf(open, "%s\n", m31);
	fprintf(open, " August    |");
	fclose(open);
	DayofWeek(1, 8, year, yearCalendar);
	open = fopen(yearCalendar, "a+");
	fprintf(open, "%s\n", m31);
	fprintf(open, " September |");
	fclose(open);
	DayofWeek(1, 9, year, yearCalendar);
	open = fopen(yearCalendar, "a+");
	fprintf(open, "%s\n", m30);
	fprintf(open, " October   |");
	fclose(open);
	DayofWeek(1, 10, year, yearCalendar);
	open = fopen(yearCalendar, "a+");
	fprintf(open, "%s\n", m31);
	fprintf(open, " November  |");
	fclose(open);
	DayofWeek(1, 11, year, yearCalendar);
	open = fopen(yearCalendar, "a+");
	fprintf(open, "%s\n", m30);
	fprintf(open, " December  |");
	fclose(open);
	DayofWeek(1, 12, year, yearCalendar);
	open = fopen(yearCalendar, "a+");
	fprintf(open, "%s\n", m31);
	fprintf(open, "___________|________________________________________________________________________________________________________________");
	fclose(open);
}

void DayofWeek(int d, int m, int y, char calendar[DIM]){
	FILE *open;
	open = fopen(calendar, "a+");
	int h;
	h = ((int)(d + floor((((m + 1) * 26) / 10)*1.000) + y + floor((y / 4)*1.0000) + 6 * floor((y / 100)*1.0000) + floor((y / 400)*1.0000)) % 7);
	if (m < 3){
		if (m == 1){
			m = 13;
		}
		if (m == 2){
			m = 14;
		}
		y--;
		h = ((int)(d + floor((((m + 1) * 26) / 10)*1.000) + (y)+floor(((y) / 4)*1.0000) + 6 * floor(((y) / 100)*1.0000) + floor(((y) / 400)*1.0000)) % 7);
	}
	if (h == 3){
		printf("   ");
		fprintf(open, "   ");
	}
	if (h == 4){
		printf("      ");
		fprintf(open, "      ");
	}
	if (h == 5){
		printf("         ");
		fprintf(open, "         ");
	}
	if (h == 6){
		printf("            ");
		fprintf(open, "            ");
	}
	if (h == 0){
		printf("               ");
		fprintf(open, "               ");
	}
	if (h == 1){
		printf("                  ");
		fprintf(open, "                  ");
	}
	fclose(open);
}

double solvint(double result){
	Mode = 1;
	int i = 0, j = 0, n = 60000, varLen = 0, var = 0, k = 0, l = 0, m = 0, g = 1;
	double per = 0, result1 = 0, lowlimit, highlimit, deltax;
	char limit[DIM], function[DIM], function1[DIM], finalfunction[DIM], variable[DIM], value[DIM];
	while (integral[i] != '$'){
		limit[i] = integral[i];
		i++;
	}
	limit[i] = '\0';
	i++;
	lowlimit = initialProcessor(limit, result);
	j = 0;
	while (integral[i] != '|'){
		limit[j] = integral[i];
		j++; i++;
	}
	limit[j] = '\0';
	i++;
	highlimit = initialProcessor(limit, result);
	deltax = ((highlimit - lowlimit) / n);
	j = 0;
	while (integral[i] != '|'){
		function[j] = integral[i];
		function1[j] = integral[i];
		j++; i++;
	}
	function[j] = '\0';
	function1[j] = '\0';
	j = 0;
	while (function[j] != '\0'){
		finalfunction[j] = function[j];
		j++;
	}
	finalfunction[j] = '\0';
	i++;
	if (integral[i] == 'd'){ i++; }
	j = 0;
	while (integral[i] != '\0'){
		variable[j] = integral[i];
		j++; i++;
	}
	variable[j] = '\0';
	varLen = j;


	for (i = 1; i <= n; i++){
		for (k = 0; function1[k] != '\0'; k++){
			function[k] = function1[k];
		}
		function[k] = '\0';
		sprintf(value, "%d*%G", i, deltax);
		m = 0;
		while (m == 0){
			var = 0;
			for (j = 0; var != varLen&&function[j] != '\0'; j++){
				if (function[j] == variable[var]){
					var++;
				}
			}
			if (var == varLen){
				m = 0;
				j = j - var;
				l = j + var;

				k = 0;
				while (value[k] != '\0'){
					finalfunction[j] = value[k];
					j++; k++;
				}
				while (function[l] != '\0'){
					finalfunction[j] = function[l];
					l++; j++;
				}
				finalfunction[j] = '\0';
				k = 0;
				while (finalfunction[k] != '\0'){
					function[k] = finalfunction[k];
					k++;
				}
				function[k] = '\0';
			}
			else{
				m = 1;
			}
		}
		result1 = result1 + (initialProcessor(finalfunction, result)*deltax);
		value[0] = '\0';
	}
	Mode = 0;
	return result1;
}

int dataVerifier(char data[DIM], double result, int comment, int verify){
	int i = 0;

	int decision = 1, j = 0, k = 0, l = 0, kr = 0, kl = 0, v = 0, cChars = 0, rf = 0, fr = 0, nDot = 0, g = 0, d = 0, w = 0, y = 0, t = 0, space = 0;
	char function[DIM] = "", variable[DIM] = "", expression[DIM] = "", text[DIM] = "", value[DIM] = "", saveVar[DIM] = "";
	char validChars[DIM] = "qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM123456789.0/*-+\\!#()[]{} ^_";
	char numsysData[DIM] = "";

	if (synTest == 0){
		decision = 1;
		synTest = 1;
		for (w = 0; data[w] != '\0'; w++){
			if ((data[w] == 'B' || data[w] == 'O' || data[w] == 'H' || data[w] == 'P') && (w == 0 || data[w - 1] == '+' || data[w - 1] == '-' || data[w - 1] == '*' || data[w - 1] == '/' || data[w - 1] == '^' || data[w - 1] == '(')){
				w++;

				if (data[w - 1] == 'B'){
					if (data[w] == '_' || data[w] == '-'){
						w++;
					}
					y = 0;
					while (data[w] != '+'&&data[w] != '-'&&data[w] != '*'&&data[w] != '/'&&data[w] != '^'&&data[w] != ')'&&data[w - 1] != 'b'&&data[w] != '('&&data[w - 1] != 'D'&&data[w] != '('&&data[w] != '\0'){
						numsysData[y] = data[w];
						w++; y++;
					}
					numsysData[y] = '\0';
					t = 0;
					for (y = 0; numsysData[y] != '\0'; y++){
						if (numsysData[y] == '1' || numsysData[y] == '0' || numsysData[y] == '.'){
							t++;
						}
					}

					if (t != strlen(numsysData))	{
						decision = 0;
						if (comment == 1){
							puts("\nBinary number entered with errors.\n");
						}
						return decision;
					}


				}

				if (data[w - 1] == 'O'){
					if (data[w] == '_' || data[w] == '-'){
						w++;
					}
					y = 0;
					while (data[w] != '+'&&data[w] != '-'&&data[w] != '*'&&data[w] != '/'&&data[w] != '^'&&data[w] != ')'&&data[w - 1] != 'b'&&data[w] != '('&&data[w - 1] != 'D'&&data[w] != '('&&data[w] != '\0'){
						numsysData[y] = data[w];
						w++; y++;
					}
					numsysData[y] = '\0';
					t = 0;
					for (y = 0; numsysData[y] != '\0'; y++){
						if (numsysData[y] == '0' || numsysData[y] == '1' || numsysData[y] == '2' || numsysData[y] == '3' || numsysData[y] == '4' || numsysData[y] == '5' || numsysData[y] == '6' || numsysData[y] == '7' || numsysData[y] == '.'){
							t++;
						}
					}
					if (t != strlen(numsysData))	{
						decision = 0;
						if (comment == 1){
							puts("\nOctal number entered with errors.\n");
						}
						return decision;
					}

				}


				if (data[w - 1] == 'H'){
					if (data[w] == '_' || data[w] == '-'){
						w++;
					}
					y = 0;
					while (data[w] != '+'&&data[w] != '-'&&data[w] != '*'&&data[w] != '/'&&data[w] != '^'&&data[w] != ')'&&data[w - 1] != 'b'&&data[w] != '('&&data[w] != '('&&data[w] != '\0'){
						numsysData[y] = data[w];
						w++; y++;
					}
					numsysData[y] = '\0';
					t = 0;
					for (y = 0; numsysData[y] != '\0'; y++){
						if (numsysData[y] == '0' || numsysData[y] == '1' || numsysData[y] == '2' || numsysData[y] == '3' || numsysData[y] == '4' || numsysData[y] == '5' || numsysData[y] == '6' || numsysData[y] == '7' || numsysData[y] == '8' || numsysData[y] == '9' || numsysData[y] == 'A' || numsysData[y] == 'B' || numsysData[y] == 'C' || numsysData[y] == 'D' || numsysData[y] == 'E' || numsysData[y] == 'F' || numsysData[y] == '.'){
							t++;
						}
					}
					if (t != strlen(numsysData))	{
						decision = 0;
						if (comment == 1){
							puts("\nHexadecimal number entered with errors.\n");
						}
						return decision;
					}

				}

				if (data[w - 1] == 'P'){
					y = 0;
					while (data[w] != '+'&&data[w] != '-'&&data[w] != '*'&&data[w] != '/'&&data[w] != '^'&&data[w] != ')'&&data[w - 1] != 'b'&&data[w] != '('&&data[w - 1] != 'D'&&data[w] != '('&&data[w] != '\0'){
						numsysData[y] = data[w];
						w++; y++;
					}
					numsysData[y] = '\0';
					decision = verifyPrefix(numsysData);
					if (decision == 0){
						if (comment == 1){
							puts("\nSI prefix entered with errors.\n");
						}
						return decision;
					}
				}


			}

		}

	}
	int u = 0, p = 0;
	u = 0;
	for (u; data[u] != '\0'; u++){
		p = 0;
		char varValidator[DIM] = "";
		if (verifyLetter(data[u]) == 1){
			if (data[u] == 'B' || data[u] == 'O' || data[u] == 'H' || data[u] == 'P'){
				varValidator[p] = data[u];
				u++; p++;
				if (data[u] == '-' || data[u] == '_'){
					varValidator[p] = data[u];
					u++; p++;
				}
				while (data[u] != ')'&&data[u] != '('&&data[u] != '+'&&data[u] != '-'&&data[u] != '*'&&data[u] != '/'&&data[u] != '^'&&data[u] != '\0'&&firstLetterFunction(data[u]) == 0){
					varValidator[p] = data[u];
					u++; p++;
				}
			}

			while (verifyLetter(data[u]) == 1 && (data[u] == 'b'&&data[u - 1] == 'g') == false && (data[u] == 'D'&&data[u - 1] == 't') == false && data[u] != '\0'){
				varValidator[p] = data[u];
				u++; p++;
			}
			if (data[u - 1] == 't'&&data[u] == 'D' || data[u - 1] == 'g'&&data[u] == 'b'){
				varValidator[p] = data[u];
				u++; p++;
				while ((data[u] == 'b'&&data[u + 1] == '(') == false && (data[u] == 'D'&&data[u + 1] == '(') == false && data[u] != '\0'){
					varValidator[p] = data[u];
					u++; p++;
				}
				varValidator[p] = data[u];
				u++; p++;
			}
			varValidator[p] = '\0';
			p = 0;
			for (p = 0; varValidator[p] != '\0'; p++){
				saveVar[p] = varValidator[p];
			}
			saveVar[p] = '\0';

			if (strlen(varValidator) > 0)	{
				processVariable(varValidator);

				int df = p;
				varValidator[p] = '\0';
				if (varValidator[0] == 'r'&&varValidator[1] == 't'&&varValidator[2] == 'D'){
					p = 3;
					while (varValidator[p] != '\0'){
						if (varValidator[p] == 'D'){
							varValidator[3] = 'D'; varValidator[4] = '?'; varValidator[5] = '\0';
						}
						p++;
					}
				}
				if (varValidator[0] == 'l'&&varValidator[1] == 'o'&&varValidator[2] == 'g'&&varValidator[3] == 'b'){
					p = 4;
					while (varValidator[p] != '\0'){
						if (varValidator[p] == 'b'){
							varValidator[4] = 'b'; varValidator[5] = '?'; varValidator[6] = '\0';
						}
						p++;
					}
				}
				if (df == p){
					varValidator[p] = '?'; varValidator[p + 1] = '\0';
				}
				double funcF = functionProcessor(varValidator, 2, 7, 12);
				if (funcF != 0.5){
					if (validVar == 0){
						if (varValidator[0] == 'E' || varValidator[0] == 'B' || varValidator[0] == 'O' || varValidator[0] == 'H' || varValidator[0] == 'P' || varValidator[0] == 'e' || varValidator[0] == 'p'&&varValidator[1] == 'i'){
							if (varValidator[0] == 'E' || varValidator[0] == 'B' || varValidator[0] == 'O' || varValidator[0] == 'H' || initialProcessor(varValidator, 0) != 0){
								decision = 1;
							}
							else{
								decision = 0;
								if (comment == 1){
									printf("\nThe variable \"%s\" is not created yet.\n", saveVar);
								}
								return decision;
							}
						}
						else{
							decision = 0;
							if (comment == 1){
								printf("\nThe variable \"%s\" is not created yet.\n", saveVar);
							}
							return decision;
						}
					}
				}
			}
		}
	}



	for (d = 0; data[d] != '\0'; d++){
		g = 0; nDot = 0;
		while (data[d] == '.' || data[d] == '0' || data[d] == '1' || data[d] == '2' || data[d] == '3' || data[d] == '4' || data[d] == '5' || data[d] == '6' || data[d] == '7' || data[d] == '8' || data[d] == '9' || data[d] == 'A' || data[d] == 'B' || data[d] == 'C' || data[d] == 'D' || data[d] == 'E' || data[d] == 'F') {
			value[g] = data[d];
			d++; g++;
		}
		value[g] = '\0';
		for (g = 0; value[g] != '\0'; g++){
			if (value[g] == '.'){
				nDot++;
			}
		}
		if (nDot > 1){
			decision = 0;
			if (comment == 1){
				puts("\nYou entered more than one dot on the entered value.\n");
			}
			return decision;
		}
	}
	for (rf = 0; data[rf] != '\0'; rf++){
		if (data[rf] == '_'&&data[rf - 1] == '_'){
			decision = 0;
			if (comment == 1){
				puts("\nYou don't need to enter \"__\", please use only a symbol \"_\" to represent negative values.\n");
			}
			return decision;
		}
		for (fr = 0; validChars[fr] != '\0'; fr++){
			if (data[rf] == validChars[fr]){
				cChars++;
			}
		}
	}
	if (cChars != rf){
		decision = 0;
		if (comment == 1){
			puts("\nYou entered invalid characters.\n");
		}
		return decision;
	}
	if ((data[0] == '+' || data[0] == '-' || data[0] == '*' || data[0] == 'x' || data[0] == '/' || data[0] == '^') && (data[1] == '0'&&data[2] == '\0')){
		decision = 0;
		if (comment == 1){
			puts("\nYou are trying relate the previous expression with zero (0).\n");
		}
		return decision;
	}
	for (i = 0; data[i] != '\0'; i++){
		if ((data[i - 1] == 'O' || data[i - 1] == 'H' || data[i - 1] == 'B') && data[i] == '_'){
			data[i] = '-';
		}

		if (data[i] == 'A' || data[i] == 'B' || data[i] == 'C' || (data[i] == 'D' && (data[i - 1] == 't' || data[i + 1] == '(')) || data[i] == 'E' || data[i] == 'F' || data[i] == 'O' || data[i] == 'H' || data[i] == '1' || data[i] == '2' || data[i] == '3' || data[i] == '4' || data[i] == '5' || data[i] == '6' || data[i] == '7' || data[i] == '8' || data[i] == '9' || data[i] == '0' || data[i] == '.' || data[i] == '_' || data[i] == '!'){
			v = 1;
			break;
		}
	}
	if (v == 1){
		v = 0;
		i = 0;
		while (data[i] != '\0'){
			if (firstLetterVariable(data[i]) == 1 && (letterVariables(data[i - 1]) == 0 || i == 0)){
				while (letterVariables(data[i]) == 1 && data[i] != '\0'){
					text[v] = ' ';
					v++;
					i++;
				}
			}
			if ((data[i - 1] == 'O' || data[i - 1] == 'H' || data[i - 1] == 'B') && data[i] == '_'){
				data[i] = '-';
			}
			if (data[i] != '1'&&data[i] != '2'&&data[i] != '3'&&data[i] != '4'&&data[i] != '5'&&data[i] != '6'&&data[i] != '7'&&data[i] != '8'&&data[i] != '9'&&data[i] != '0'&&data[i] != '.'&&data[i] != '_'&&data[i] != '!'&&data[i] != 'A'&&data[i] != 'B'&&data[i] != 'C' && data[i] != 'D' && (data[i - 1] == 't' && data[i + 1] == '(') && data[i] != 'E'&&data[i] != 'F'&&data[i] != 'O'&&data[i] != 'H'){
				text[v] = data[i];
				v++;
				i++;
			}
			else{
				text[v] = ' ';
				v++;
				i++;
			}



		}
		text[v] = '\0';
		decision = dataVerifier(text, result, comment, verify);
		if (decision == 0){
			if (comment == 1){
				puts("\nYou entered invalid values.\n");
			}
			return decision;
		}
	}

	for (i = 0; data[i] != '\0'; i++){
		if (data[i] == '"' || data[i] == '%' || data[i] == '&' || data[i] == '"' || data[i] == '=' || data[i] == '?' || data[i] == '@' || data[i] == '£' || data[i] == '§' || data[i] == '\'' || data[i] == '€' || data[i] == '¨' || data[i] == '´' || data[i] == '`' || data[i] == 'ª' || data[i] == 'º' || data[i] == '~' || data[i] == ',' || data[i] == ';' || data[i] == ':' || data[i] == '«' || data[i] == '»'){
			decision = 0;
			if (comment == 1){
				puts("\nYou entered invalid characters.\n");
			}
			return decision;
		}

		if (data[i] == '[' || data[i] == '{'){
			data[i] = '(';
		}
		if (data[i] == ']' || data[i] == '}'){
			data[i] = ')';
		}
		if (data[i] == '('){
			kl++;
			if (data[i + 1] == '+' || data[i + 1] == '-' || data[i + 1] == '*' || data[i + 1] == 'x' || data[i + 1] == '/' || data[i + 1] == '^' || data[i + 1] == '!'){
				decision = 0;
				if (comment == 1){
					puts("\nYou entered an arithmetic symbol next to \"(\".\n");
				}
				return decision;
			}
		}
		if (data[i] == ')'){
			kr++;
			if (data[i - 1] == '+' || data[i - 1] == '-' || data[i - 1] == '*' || data[i - 1] == 'x' || data[i - 1] == '/' || data[i - 1] == '^'){
				decision = 0;
				if (comment == 1){
					puts("\nYou entered an arithmetic symbol previous to \")\".\n");
				}
				return decision;
			}
		}
	}
	if (kr != kl){
		decision = 0;
		return decision;
	}
	for (i = 0; data[i] != '\0'; i++){
		j = 0;
		if (data[i] == 'r'&&data[i + 1] == 'e'&&data[i + 2] == 's'&&data[i + 3] != 't'){
			decision = 1;
			i = i + 3;
		}
		if (data[i] == '0' || data[i] == '1' || data[i] == '2' || data[i] == '3' || data[i] == '4' || data[i] == '5' || data[i] == '6' || data[i] == '7' || data[i] == '8' || data[i] == '9' || data[i] == '.' || data[i] == '_' || data[i] == '!' || data[i] == '+' || data[i] == '-' || data[i] == '/' || data[i] == '*' || data[i] == 'x' || data[i] == '^' || data[i] == 'e' || data[i] == 'p'&&data[i + 1] == 'i' || data[i - 1] == 'p'&&data[i] == 'i'){
			j = 0;
			while (data[i] == '0' || data[i] == '1' || data[i] == '2' || data[i] == '3' || data[i] == '4' || data[i] == '5' || data[i] == '6' || data[i] == '7' || data[i] == '8' || data[i] == '9' || data[i] == '.' || data[i] == '_' || data[i] == '!' || data[i] == '+' || data[i] == '-' || data[i] == '/' || data[i] == '*' || data[i] == 'x' || data[i] == '^' || data[i] == 'e' || data[i] == 'p'&&data[i + 1] == 'i' || data[i - 1] == 'p'&&data[i] == 'i'){
				i++;
				decision = 1;
				j++;
			}
		}
		if (data[i] == 'r'&&data[i + 1] == 'e'&&data[i + 2] == 's'&&data[i + 3] != 't'){
			decision = 1;
			i = i + 3;
		}

		if (data[i] == 'a' || data[i] == 's'&&data[i - 1] != 'e'&&data[i - 2] != 'r' || data[i] == 'c' || data[i] == 't' || data[i] == 'g' || data[i] == 'd' || data[i] == 'l' || data[i] == 'q' || data[i] == 'r'){
			decision = 1;
			j = 0;
			while (data[i] != '('&&data[i] != '\0'){
				k = 0;
				if (data[i] == 'b'&&data[i - 1] != 'c'){
					function[j] = data[i];
					j++; i++;
					k++;
					l = 0;
					while ((data[i] == 'b'&&data[i + 1] == '(') == false && data[i] != '\0'){
						function[j] = data[i];
						expression[l] = function[j];
						j++; i++; l++;
					}
					expression[l] = '\0';

					int p = 0;
					manageExpression(expression, result, verify);
					for (p = 0; expressionF[p] != '\0'; p++){
						expression[p] = expressionF[p];
					}
					expression[p] = '\0';
					decision = dataVerifier(expression, result, comment, verify);
					if (decision == 0){
						return decision;
					}
					if (data[i] == 'b'){
						k++;
					}
					if (k != 2){
						decision = 0;
						if (comment == 1){
							puts("\nNumber of \"bs\" for advanced logarithmic function can't be different of 2.\n");
						}

						return decision;
					}
				}
				k = 0;
				if (data[i] == 'D'){
					function[j] = data[i];
					j++; i++;
					k++;
					l = 0;
					while ((data[i] == 'D'&&data[i + 1] == '(') == false && data[i] != '\0'){
						function[j] = data[i];
						expression[l] = function[j];
						j++; i++; l++;
						if ((data[i] == 'D'&&data[i + 1] == '(') == false && data[i + 1] != '('){
							function[j] = data[i];
							expression[l] = function[j];
							if (data[i] == 'D'&&data[i + 1] == '('){
								i--;
							}
							j++; i++; l++;
						}
					}
					expression[l] = '\0';
					decision = dataVerifier(expression, result, comment, verify);
					if (decision == 0){
						return decision;
					}
					if (data[i] == 'D'){
						k++;
					}
					if (k != 2){
						decision = 0;
						if (comment == 1){
							puts("\nNumber of \"Ds\" for advanced root function can't be different of 2.\n");
						}
						return decision;
					}
				}
				function[j] = data[i];
				j++; i++;
			}
			function[j] = '\0';
			j = 0;
			while (function[j] == 'c' || function[j] == 'o' || function[j] == 's' || function[j] == 'a' || function[j] == 'd' || function[j] == 'i' || function[j] == 'n' || function[j] == 't' || function[j] == 'e' || function[j] == 'l' || function[j] == 'g' || function[j] == 'b' || function[j] == 'r' || function[j] == 'q' || function[j] == 'u' || function[j] == 'D' || function[j] == 'f' || function[j] == 'h' || function[j] == 'v'){
				if (function[j] == 'b'&&function[j - 1] != 'c'){
					j++;
					while ((function[j] == 'b'&&function[j + 1] == '\0') == false && function[j] != '\0'){
						j++;
					}
					if (function[j + 1] != '\0'){
						decision = 0;
						return decision;
					}
				}
				if (function[j] == 'D'){
					j++;
					while ((function[j] == 'D'&&function[j + 1] == '\0') == false && function[j] != '\0'){
						j++;
					}
					if (function[j + 1] != '\0'){
						decision = 0;
						return decision;
					}
				}
				j++;
			}
			if (j != strlen(function)){
				decision = 0;
				return decision;
			}
			resultI = 0.5;
			int ko = strlen(function);
			function[ko] = '?'; function[ko + 1] = '\0';
			if (functionProcessor(function, 0.2, 1.0, result) != 0 || function[0] == 'r'&&function[1] == 'e'&&function[2] == 's'&&function[3] == 't'&&function[4] == '\0' || function[0] == 'q'&&function[1] == 'u'&&function[2] == 'o'&&function[3] == 't'&&function[4] == 'i'&&function[5] == 'e'&&function[6] == 'n'&&function[7] == 't'&&function[8] == '\0' || function[0] == 'a'&&function[1] == 'c'&&function[2] == 'o'&&function[3] == 's'&&function[4] == 'h'&&function[5] == '\0' || function[0] == 'a'&&function[1] == 'c'&&function[2] == 'o'&&function[3] == 't'&&function[4] == 'a'&&function[5] == 'n'&&function[6] == 'h'&&function[7] == '\0'){
				decision = 1;
			}
			else{
				if (strlen(function) > 0){
					if (comment == 1){
						puts("\nInvalid function entered.\n");
					}
					decision = 0;
				}
				return decision;
			}
		}
		if (data[i] == '0' || data[i] == '1' || data[i] == '2' || data[i] == '3' || data[i] == '4' || data[i] == '5' || data[i] == '6' || data[i] == '7' || data[i] == '8' || data[i] == '9' || data[i] == '.' || data[i] == '_' || data[i] == '!' || data[i] == '+' || data[i] == '-' || data[i] == '/' || data[i] == '*' || data[i] == 'x' || data[i] == '^' || data[i] == 'e' || data[i] == 'p'&&data[i + 1] == 'i' || data[i - 1] == 'p'&&data[i] == 'i'){
			j = 0;
			while (data[i] == '0' || data[i] == '1' || data[i] == '2' || data[i] == '3' || data[i] == '4' || data[i] == '5' || data[i] == '6' || data[i] == '7' || data[i] == '8' || data[i] == '9' || data[i] == '.' || data[i] == '_' || data[i] == '!' || data[i] == '+' || data[i] == '-' || data[i] == '/' || data[i] == '*' || data[i] == 'x' || data[i] == '^' || data[i] == 'e' || data[i] == 'p'&&data[i + 1] == 'i' || data[i - 1] == 'p'&&data[i] == 'i'){
				i++;
				decision = 1;
				j++;
			}
		}
		j = 0;
		if (data[i] == 'r'&&data[i + 1] == 'e'&&data[i + 2] == 's'&&data[i + 3] != 't'){
			decision = 1;
			i = i + 3;
		}
		if (data[i] == 'B' || data[i] == 'O' || data[i] == 'H' || data[i] == 'Q' || data[i] == 'W' || data[i] == 'R' || data[i] == 'T' || data[i] == 'Y' || data[i] == 'U' || data[i] == 'I' || data[i] == 'P' || data[i] == 'A' || data[i] == 'S' || data[i] == 'D' || data[i] == 'F' || data[i] == 'G' || data[i] == 'J' || data[i] == 'K' || data[i] == 'L' || data[i] == 'Z' || data[i] == 'X' || data[i] == 'C' || data[i] == 'V' || data[i] == 'N' || data[i] == 'M' || data[i] == 'm' || data[i] == 'n' || data[i] == 'b' || data[i] == 'v' || data[i] == 'z' || data[i] == 'k' || data[i] == 'j' || data[i] == 'h' || data[i] == 'f' || data[i] == 'a' || data[i] == 'p' || data[i] == 'o' || data[i] == 'u' || data[i] == 'y' || data[i] == 'w'){
			j = 0;
			while (data[i] != '+'&&data[i] != '-'&&data[i] != '*'&&data[i] != '/'&&data[i] != '^'&&data[i] != ')'&&data[i] != '(' && data[i] != '\0'){
				variable[j] = data[i];
				j++;
				i++;
			}
			variable[j] = '\0';
			if (initialProcessor(variable, result) != 0){
				decision = 1;
				variable[j] = '\0';
			}
			else{
				variable[j] = '\0';
				int w = 0;
				while (letterVariables(variable[w]) == 1 && variable[w] != '\0'){
					w++;
				}
				variable[w] = '\0';
				processVariable(variable);
				if (validVar == 1){
					decision = 1;
				}
			}
		}
	}
	return decision;
}

void variableRenamer(char variable[DIM]){
	varRename[0] = '\0';

	char vari[DIM] = "";
	int i = 0, j = 0;
	FILE *open = NULL;
	while (open == NULL&&i < 50){
		open = fopen("renamedVar.txt", "a+");
		i++;
	}
	if (open != NULL){
		for (i = 0; (vari[i] = fgetc(open)) != EOF; i++);
		vari[i] = '\0';
		fclose(open);
		for (i = 0; vari[i] != '\0'; i++){
			j = 0;
			if (variable[j] == vari[i] && (i == 0 || vari[i - 1] == '\n')){
				while (variable[j] == vari[i] && vari[i] != '\0'){
					j++; i++;
				}
				if (strlen(variable) == j){
					if (variable[j] == '\0'&&vari[i] == ' '){
						valRenamedVar = 1;
						i++;
						j = 0;
						while (vari[i] != '\n'&&vari[i] != '\0'){
							varRename[j] = vari[i];
							j++; i++;
						}
						varRename[j] = '\0';
					}
				}
			}
		}
	}
}

double prefToNumber(char prefix){
	double result = 0;
	if (prefix == 'Y'){
		result = pow(10.0, 24.0);
		return result;
	}
	if (prefix == 'Z'){
		result = pow(10.0, 21.0);
		return result;
	}
	if (prefix == 'E'){
		result = pow(10.0, 18.0);
		return result;
	}
	if (prefix == 'P'){
		result = pow(10.0, 15.0);
		return result;
	}
	if (prefix == 'T'){
		result = pow(10.0, 12.0);
		return result;
	}
	if (prefix == 'G'){
		result = pow(10.0, 9.0);
		return result;
	}
	if (prefix == 'M'){
		result = pow(10.0, 6.0);
		return result;
	}
	if (prefix == 'k'){
		result = pow(10.0, 3.0);
		return result;
	}
	if (prefix == 'h'){
		result = pow(10.0, 2.0);
		return result;
	}
	if (prefix == 'D'){
		result = pow(10.0, 1.0);
		return result;
	}
	if (prefix == 'd'){
		result = pow(10.0, -1.0);
		return result;
	}
	if (prefix == 'c'){
		result = pow(10.0, -2.0);
		return result;
	}
	if (prefix == 'm'){
		result = pow(10.0, -3.0);
		return result;
	}
	if (prefix == 'u'){
		result = pow(10.0, -6.0);
		return result;
	}
	if (prefix == 'n'){
		result = pow(10.0, -9.0);
		return result;
	}
	if (prefix == 'p'){
		result = pow(10.0, -12.0);
		return result;
	}
	if (prefix == 'f'){
		result = pow(10.0, -15.0);
		return result;
	}
	if (prefix == 'a'){
		result = pow(10.0, -18.0);
		return result;
	}
	if (prefix == 'z'){
		result = pow(10.0, -21.0);
		return result;
	}
	if (prefix == 'y'){
		result = pow(10.0, -24.0);
		return result;
	}
	return result;
}

void pathNameController(char pathName[DIM], char path[DIM]){
	FILE *save = NULL;
	while (save == NULL){
		save = fopen("pathName.txt", "a+");
	}
	char data[DIM] = "", paName[DIM] = "";
	int i = 0, j = 0, k = 0, y = 0, w = 0, l = 0;
	for (i = 0; (data[i] = fgetc(save)) != EOF; i++);
	for (i = 0; data[i] != '\0'; i++){
		if (data[i] == pathName[j] && (data[i - 1] == '\n' || i == 0)){
			y = i;
			while (data[i] == pathName[j]){
				j++;
				i++;
			}
			if (j == strlen(pathName) && data[i] == ' '){
				i++;
				while (data[i] != '\n'){
					paName[k] = data[i];
					k++; i++;
				}
				paName[k] = '\0';
				w = strlen(pathName) + strlen(paName) + 3;
				for (l = y; data[l + w] != '\0'; l++){
					data[l] = data[l + w];

				}
				data[l] = '\0';
				fclose(save);
				save = fopen("pathName.txt", "w");
				fputs(data, save);
				fclose(save);
			}

		}
		else{
			j = 0;
		}
	}
	save = fopen("pathName.txt", "a+");
	fprintf(save, "%s %s\n", pathName, path);
	fclose(save);
}

void pathNameToPath(char pathName[DIM]){
	FILE *open = NULL;
	int i = 0, j = 0, k = 0;
	char data[DIM] = "";
	pathNAme[0] = '\0';
	open = fopen("pathName.txt", "r");
	if (open == NULL){
		puts("\n==> No path abbreviation created! <==\n");
	}
	else{
		for (i = 0; (data[i] = fgetc(open)) != EOF; i++);
		fclose(open);
		for (i = 0; data[i] != '\0'; i++){
			if (data[i] == pathName[j] && (data[i - 1] == '\n' || i == 0)){
				while (data[i] == pathName[j]){
					j++;
					i++;
				}
				if (j == strlen(pathName) && data[i] == ' '){
					i++;
					while (data[i] != '\n'){
						pathNAme[k] = data[i];
						k++; i++;
					}
					pathNAme[k] = '\0';

				}

			}
			else{
				j = 0;
			}
		}
		if (strlen(pathNAme) == 0){
			puts("\n==> This path abbreviation not exist! <==\n");
		}
	}
}

void matrixToValues(char matrix[DIM], double result){
	int i = 0, j = 0, k = 0, l = 0;
	for (i = 0; matrix[i] != '\0'; i++){
		if (matrix[i] == ';'){
			count++;
		}
	}
	for (i = 0; i < count - 1; i++){
		for (j = 0; j < count; j++){
			char value[DIM] = "";	  char valueF[DIM] = "";
			values[i][j] = 0;
			valuesI[i][j] = 0;
			l = 0;

			while (matrix[k] != '\0'&&matrix[k] != ';'&&matrix[k] != '\\'){
				value[l] = matrix[k];
				k++; l++;
			}
			value[l] = '\0';
			k++;
			initialProcessor(value, result);
			values[i][j] = resultR;
			valuesS[i][j] = values[i][j];
			valuesI[i][j] = resultI;
			valuesSI[i][j] = valuesI[i][j];

		}
	}

}

void solveSystem(){
	int i = 0, j = 0, jC = 0, iC = 0, iS = 0, jS = 0, g = 0, countVal = 0;
	double divider = 0, dividerI = 0, valuesToiC[DIM], dividedi[DIM], real = 0, imag = 0;
	while (i < count - 1){
		valuesToiC[i] = 100;
		i++;
	}
	while (jC < count - 1 || countVal != 1 && jC != count - 1){
		while (i < count - 1){
			dividedi[i] = 100;
			i++;
		}
		j = jC;
		for (i = iC; i < count - 1; i++){
			j = jC;
			if ((values[i][j] != 0 || valuesI[i][j] != 0) && valuesToiC[i] != 200){
				divider = values[i][j];
				dividerI = valuesI[i][j];
				dividedi[i] = 200;
				for (j = 0; j < count; j++){
					division(values[i][j], valuesI[i][j], divider, dividerI);
					values[i][j] = resultR;
					valuesI[i][j] = resultI;
				}
				countVal = 0;
				for (g = 0; g < count - 1; g++){
					if (values[i][g] != 0 || valuesI[i][g] != 0){
						countVal++;
					}
				}
			}



		}
		if (countVal != 1){
			i = 0;
			while (i < count - 1) {
				if (values[i][jC] == 1 && valuesI[i][jC] == 0){
					iC = i;
					valuesToiC[iC] = 200;
					break;
				}
				i++;
			}
			for (i = (iC + 1) % (count - 1); i < count - 1; i++){
				for (j = 0; j < count; j++){
					if (valuesToiC[i] != 200 && dividedi[i] == 200 && dividedi[iC] == 200){
						subtraction(values[iC][j], valuesI[iC][j], values[i][j], valuesI[i][j]);
						values[i][j] = resultR;
						valuesI[i][j] = resultI;
					}
				}
			}
			for (i = 0; i < count - 1; i++){
				if (values[i][jC] == 0 && valuesI[i][jC] == 0){
					iC = i;
					break;
				}
			}
		}
		jC++;


	}
}

void rearrangeValues(){
	int i = 0, j = 0;
	while (i < count - 1){
		if (values[i][i] != 0 || valuesI[i][i] != 0){
			j++;
		}
		i++;
	}
	if (j != count - 1){
		int s = 0, d = 0;
		i = 0; j = 0;
		while (s < count - 1){
			i = 0;
			while (values[i][d] == 0 && valuesI[i][d] == 0 && i < count - 1){
				i++;
			}
			for (j = 0; j < count; j++){
				valuesF[s][j] = values[i][j];
				valuesFI[s][j] = valuesI[i][j];
			}
			s++;
			d++;
		}
		for (i = 0; i < count - 1; i++){
			for (j = 0; j < count; j++){
				values[i][j] = valuesF[i][j];
				valuesI[i][j] = valuesFI[i][j];
			}
		}
	}
}

void getSolutions(){
	int j = 0, i = 0, jS = 0, iS = 0;
	j = count - 1;
	i = count - 2;
	jS = j;
	iS = i;
	i--;
	while (j - 1 >= 1){
		while (i >= 0){
			resultR = 0; resultI = 0;
			multiplication(values[i][j - 1], valuesI[i][j - 1], values[iS][jS], valuesI[iS][jS]);
			subtraction(values[i][count - 1], valuesI[i][count - 1], resultR, resultI);
			values[i][count - 1] = resultR;
			valuesI[i][count - 1] = resultI;
			values[i][j - 1] = 0; valuesI[i][j - 1] = 0;
			i--;
		}
		j--;
		iS--;
		i = iS - 1;
	}
}

void sum(double numR, double numI, double denR, double denI){
	resultR = numR + denR;
	resultI = numI + denI;
}

void subtraction(double numR, double numI, double denR, double denI){
	resultR = numR - denR;
	resultI = numI - denI;
}

void multiplication(double numR, double numI, double denR, double denI){
	if (numI == 0 && denI == 0){
		resultR = numR * denR;
		resultI = 0;
	}
	else{
		resultR = numR*denR + (numI*denI)*-1;
		resultI = numR*denI + numI*denR;
	}
}

void division(double numR, double numI, double denR, double denI){
	if (numI == 0 && denI == 0){
		resultR = numR / denR;
		resultI = 0;
	}
	else{
		multiplication(numR, numI, denR, denI*-1);
		double nuMR = resultR, nuMI = resultI;
		multiplication(denR, denI, denR, denI*-1);
		double deNR = resultR, deNI = resultI;
		resultR = nuMR / deNR;
		resultI = nuMI / deNR;
	}
}

void printTimer(int hours, int minutes, int seconds){
	cls();
	puts("\n");
	char tiIn[DIM] = "";
	int i = 0, j = 0;
	sprintf(tiIn, "%02d:%02d:%02d\n", hours, minutes, seconds);
	printf(" %c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c\n", 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176);
	printf(" %c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c\n", 176, 176, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 176, 176);
	printf(" %c%c%c%c                                                         %c%c%c%c\n", 176, 176, 219, 219, 219, 219, 176, 176);

	while (j < 5){
		printf(" %c%c%c%c  ", 176, 176, 219, 219);
		for (i = 0; tiIn[i] != '\0'; i++){
			if (tiIn[i] == '\n'){
				printf(" %c%c%c%c \n", 219, 219, 176, 176);
			}

			if (tiIn[i] == ':'){
				if (j == 0 || j == 4 || j == 2){
					printf("   ");
				}
				if (j == 1 || j == 3){
					printf("%c%c ", 219, 219);
				}
			}

			if (tiIn[i] == '0'){
				if (j == 0 || j == 4){
					printf("%c%c%c%c%c%c%c ", 219, 219, 219, 219, 219, 219, 219);
				}
				if (j == 1 || j == 3){
					printf("%c%c   %c%c ", 219, 219, 219, 219);
				}
				if (j == 2){
					printf("%c%c%c%c%c%c%c ", 219, 219, 176, 176, 176, 219, 219);

				}
			}
			if (tiIn[i] == '1'){
				if (j == 0 || j == 2 || j == 4){
					printf("%c%c%c%c%c%c%c ", 176, 176, 176, 176, 176, 219, 219);
				}
				else{
					printf("%c%c   %c%c ", 176, 176, 219, 219);
				}

			}
			if (tiIn[i] == '2'){
				if (j == 0 || j == 2 || j == 4){
					printf("%c%c%c%c%c%c%c ", 219, 219, 219, 219, 219, 219, 219);
				}
				if (j == 1){
					printf("%c%c   %c%c ", 176, 176, 219, 219);
				}
				if (j == 3){
					printf("%c%c   %c%c ", 219, 219, 176, 176);
				}

			}
			if (tiIn[i] == '3'){
				if (j == 0 || j == 4 || j == 2){
					printf("%c%c%c%c%c%c%c ", 219, 219, 219, 219, 219, 219, 219);
				}
				if (j == 1 || j == 3){
					printf("%c%c   %c%c ", 176, 176, 219, 219);
				}

			}
			if (tiIn[i] == '4'){
				if (j == 0){
					printf("%c%c%c%c%c%c%c ", 219, 219, 176, 176, 176, 219, 219);
				}
				if (j == 1){
					printf("%c%c   %c%c ", 219, 219, 219, 219);
				}
				if (j == 2){
					printf("%c%c%c%c%c%c%c ", 219, 219, 219, 219, 219, 219, 219);
				}
				if (j == 3){
					printf("%c%c   %c%c ", 176, 176, 219, 219);
				}
				if (j == 4){
					printf("%c%c%c%c%c%c%c ", 176, 176, 176, 176, 176, 219, 219);
				}

			}
			if (tiIn[i] == '5'){
				if (j == 0 || j == 2 || j == 4){
					printf("%c%c%c%c%c%c%c ", 219, 219, 219, 219, 219, 219, 219);
				}
				if (j == 1){
					printf("%c%c   %c%c ", 219, 219, 176, 176);
				}
				if (j == 3){
					printf("%c%c   %c%c ", 176, 176, 219, 219);
				}

			}
			if (tiIn[i] == '6'){
				if (j == 0 || j == 2 || j == 4){
					printf("%c%c%c%c%c%c%c ", 219, 219, 219, 219, 219, 219, 219);
				}
				if (j == 1){
					printf("%c%c   %c%c ", 219, 219, 176, 176);
				}

				if (j == 3){
					printf("%c%c   %c%c ", 219, 219, 219, 219);
				}

			}
			if (tiIn[i] == '7'){
				if (j == 0){
					printf("%c%c%c%c%c%c%c ", 219, 219, 219, 219, 219, 219, 219);
				}
				if (j == 2){
					printf("%c%c%c%c%c%c%c ", 176, 176, 176, 176, 176, 219, 219);
				}
				if (j == 1 || j == 3){
					printf("%c%c   %c%c ", 176, 176, 219, 219);
				}
				if (j == 4){
					printf("%c%c%c%c%c%c%c ", 176, 176, 176, 176, 176, 219, 219);
				}


			}
			if (tiIn[i] == '8'){
				if (j == 0 || j == 4 || j == 2){
					printf("%c%c%c%c%c%c%c ", 219, 219, 219, 219, 219, 219, 219);
				}
				if (j == 1 || j == 3){
					printf("%c%c   %c%c ", 219, 219, 219, 219);
				}


			}
			if (tiIn[i] == '9'){
				if (j == 0 || j == 2 || j == 4){
					printf("%c%c%c%c%c%c%c ", 219, 219, 219, 219, 219, 219, 219);
				}
				if (j == 1){
					printf("%c%c   %c%c ", 219, 219, 219, 219);
				}
				if (j == 3){
					printf("%c%c   %c%c ", 176, 176, 219, 219);
				}

			}

		}
		j++;
	}
	printf(" %c%c%c%c                                                         %c%c%c%c\n", 176, 176, 219, 219, 219, 219, 176, 176);
	printf(" %c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c\n", 176, 176, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 176, 176);
	printf(" %c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c\n", 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176);
	puts(" ");
}

int firstLetterVariable(char letter){
	char letters[100] = "QWRTYUISGJKLZXVNMwyuofhjkzvnmp";
	int i = 0;
	for (i = 0; i < strlen(letters); i++){
		if (letter == letters[i]){
			return 1;
		}
	}
	return 0;
}

int letterVariables(char letter){
	char letters[100] = "QWRTYUIOSGHJKLZXVNMqwrtyuopasdfghjklzcvnm";
	int i = 0;
	for (i = 0; i < strlen(letters); i++){
		if (letter == letters[i]){
			return 1;
		}
	}
	return 0;
}

int verifyLetter(char letter){
	char letters[DIM] = "QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm";
	int i = 0;
	for (i = 0; i < strlen(letters); i++){
		if (letter == letters[i]){
			return 1;
		}
	}
	return 0;
}

bool IsPreviousToWindowsVista()
{
	bool previousToVista = false;

	OSVERSIONINFOEX osversion;
	ZeroMemory(&osversion, sizeof(OSVERSIONINFOEX));
	osversion.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
	if (GetVersionEx((OSVERSIONINFO*)&osversion))
	{
		const DWORD VistaVersion = 6;
		if ((osversion.dwPlatformId == VER_PLATFORM_WIN32_NT) && (osversion.dwMajorVersion < VistaVersion))
		{
			previousToVista = true;
		}
	}

	return previousToVista;
}

void exponentiation(double a, double b, double c, double d, int sig){
	if (sig == 0){
		a = a*-1; b = b*-1;
		exponentiation(a, b, c, d, 1);
		resultR = resultR*-1;
		resultI = resultI*-1;
	}
	else{
		if (sig == 1){
			if (b != 0 || d != 0 || a < 0){
				double r = sqrt(pow(a, 2.0) + pow(b, 2.0));
				double arg_ab = atan2(b, a);
				double part1 = pow(r, c)*pow(M_E, -d*arg_ab);
				double part2 = cos(d*log(r) + c*arg_ab);
				double part3 = sin(d*log(r) + c*arg_ab);
				resultR = part1*part2;
				resultI = part1*part3;
			}
			else{
				resultR = pot(a, c, sig);
				resultI = 0;
			}
		}
	}
	if (a == 0 && b == 0){
		resultR = 0;
		resultI = 0;
	}
}

double arg(double a, double b){
	double arg_ab = 0;
	if (a > 0){
		arg_ab = atan(b / a);
	}
	else{
		if (a < 0 && b >0){
			arg_ab = M_PI + atan(b / a);
		}
		else{
			if (a < 0 && b < 0){
				arg_ab = -M_PI + atan(b / a);
			}
			else{
				if (a < 0 && b == 0){
					arg_ab = M_PI;
				}
				else{
					if (a == 0 && b < 0){
						arg_ab = -M_PI / 2;
					}
					else{
						if (a == 0 && b > 0){
							arg_ab = M_PI / 2;
						}
						else{
							arg_ab = 0;
						}
					}
				}
			}
		}
	}
	return arg_ab;
}

int verifyNumber(char number){
	char numbers[DIM] = "0123456789";
	int i = 0;
	for (i = 0; i < strlen(numbers); i++){
		if (number == numbers[i]){
			return 1;
		}
	}
	return 0;
}

void complex_log(double a, double b){
	if (b == 0 && a > 0){
		resultR = ln(a);
		resultI = 0;
	}
	else{
		resultR = 0; resultI = 0;
		resultR = ln(pot(pot(a, 2.0, 1) + pot(b, 2.0, 1), 0.5, 1));
		resultI = atan2(b, a);
	}
}

void complex_cos(double x, double y){
	resultR = 0; resultI = 0;
	exponentiation(M_E, 0.0, -1 * y, x, 1);
	double napR = resultR, napI = resultI;
	exponentiation(M_E, 0.0, y, -1 * x, 1);
	double nap2R = resultR, nap2I = resultI;
	sum(napR, napI, nap2R, nap2I);
	double sumR = resultR, sumI = resultI;
	division(sumR, sumI, 2.0, 0.0);
	round_complex();
}

void complex_sin(double x, double y){
	resultR = 0; resultI = 0;
	exponentiation(M_E, 0.0, -1 * y, x, 1);
	double napR = resultR, napI = resultI;
	exponentiation(M_E, 0.0, y, -1 * x, 1);
	double nap2R = resultR, nap2I = resultI;
	subtraction(napR, napI, nap2R, nap2I);
	double sumR = resultR, sumI = resultI;
	division(sumR, sumI, 0.0, 2.0);
	round_complex();
}

void complex_tan(double x, double y){
	resultR = 0; resultI = 0;
	complex_sin(x, y);
	double numR = resultR, numI = resultI;
	complex_cos(x, y);
	double denR = resultR, denI = resultI;
	division(numR, numI, denR, denI);
	char response[DIM] = "";
	round_complex();
}

void complex_cosh(double x, double y){
	resultR = 0; resultI = 0;
	exponentiation(M_E, 0.0, x, y, 1);
	double napR = resultR, napI = resultI;
	exponentiation(M_E, 0.0, -1 * x, -1 * y, 1);
	double nap2R = resultR, nap2I = resultI;
	sum(napR, napI, nap2R, nap2I);
	double sumR = resultR, sumI = resultI;
	division(sumR, sumI, 2.0, 0.0);
	round_complex();
}

void complex_sinh(double x, double y){
	resultR = 0; resultI = 0;
	exponentiation(M_E, 0.0, x, y, 1);
	double napR = resultR, napI = resultI;
	exponentiation(M_E, 0.0, -1 * x, -1 * y, 1);
	double nap2R = resultR, nap2I = resultI;
	subtraction(napR, napI, nap2R, nap2I);
	double sumR = resultR, sumI = resultI;
	division(sumR, sumI, 2.0, 0.0);
	round_complex();
}

void complex_tanh(double x, double y){
	resultR = 0; resultI = 0;
	complex_sinh(x, y);
	double numR = resultR, numI = resultI;
	complex_cosh(x, y);
	double denR = resultR, denI = resultI;
	division(numR, numI, denR, denI);
	round_complex();
}

void complex_asin(double x, double y){
	resultR = 0; resultI = 0;
	double radicandR = 1 - pot(x, 2.0, 1) + pot(y, 2.0, 1);
	double radicandI = -1 * 2 * x*y;
	exponentiation(radicandR, radicandI, 1 / 2.0, 0.0, 1);
	double logpR = resultR, logpI = resultI;
	sum(logpR, logpI, -1 * y, x);
	double logFR = resultR, logFI = resultI;
	complex_log(logFR, logFI);
	multiplication(resultR, resultI, 0.0, -1);
	round_complex();
}

void complex_acos(double x, double y){
	resultR = 0; resultI = 0;
	double radicandR = -1 * pot(x, 2.0, 1) + pot(y, 2.0, 1) + 1;
	double radicandI = -2 * x*y;
	exponentiation(radicandR, radicandI, 1 / 2.0, 0.0, 1);
	multiplication(resultR, resultI, 0.0, -1.0);
	double logpR = resultR, logpI = resultI;
	sum(logpR, logpI, x, y);
	double logFR = resultR, logFI = resultI;
	complex_log(logFR, logFI);
	multiplication(resultR, resultI, 0.0, 1);
	round_complex();
}

void complex_atan(double x, double y){
	resultR = 0; resultI = 0;
	double numR = 1 + y, numI = -1 * x;
	double denR = 1 - y, denI = x;
	division(numR, numI, denR, denI);
	complex_log(resultR, resultI);
	multiplication(0.0, 1 / 2.0, resultR, resultI);
	round_complex();
}

void round_complex(){
	if (resultR >= -DBL_MAX&&resultR <= DBL_MAX&&resultI >= -DBL_MAX&&resultI <= DBL_MAX){
		FILE *open;
		open = fopen("numSystems.txt", "r");
		char numSys[DIM] = "";
		int numeriSys = 0;
		if (open != NULL){
			fgets(numSys, 10, open);
			numeriSys = atoi(numSys);
			fclose(open);
		}

		double norm = sqrt(pow(resultR, 2.0) + pow(resultI, 2.0));
		char response[DIM] = "";
		char *ty;

		if (numeriSys == 1){
			sprintf(response, "%G", norm);
			norm = strtod(response, &ty);
			sprintf(response, "%G", resultI);
			resultI = strtod(response, &ty);
			sprintf(response, "%G", resultR);
			resultR = strtod(response, &ty);
			if (norm == abs(resultI)){
				sprintf(response, "0", resultR);
			}
			else{
				sprintf(response, "%G", resultR);
			}
			resultR = strtod(response, &ty);
			if (norm == abs(resultR)){
				sprintf(response, "0", resultI);
			}
			else{
				sprintf(response, "%G", resultI);
			}
		}
		else{
			sprintf(response, "%.400f", norm);
			norm = strtod(response, &ty);
			sprintf(response, "%.400f", resultI);
			resultI = strtod(response, &ty);
			sprintf(response, "%.400f", resultR);
			resultR = strtod(response, &ty);
			if (norm == abs(resultI)){
				sprintf(response, "0", resultR);
			}
			else{
				sprintf(response, "%.400f", resultR);
			}
			resultR = strtod(response, &ty);
			if (norm == abs(resultR)){
				sprintf(response, "0", resultI);
			}
			else{
				sprintf(response, "%.400f", resultI);
			}
		}
		resultI = strtod(response, &ty);
	}
}


void renamer(char expression[DIM]){
	char varLetters[DIM] = "QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm", varToRename[DIM] = "";
	int j = 0, k = 0, sd = 0, i = 0;
	for (k = 0; expression[k] != '\0'; k++){
		for (i = 0; varLetters[i] != '\0'; i++){
			if (expression[k] == varLetters[i]){
				varToRename[j] = expression[k];
				j++;
				break;
			}
		}
		if (j > 0 && expression[k] != varLetters[i] && expression[k] != '\0'){
			varToRename[j] = '\0';
			varRename[0] = '\0';
			variableRenamer(varToRename);
			varToRename[0] = '\0';
			sd = k - j;
			j = 0;
			while (varRename[j] != '\0'){
				expression[sd] = varRename[j];
				j++; sd++;
			}
			j = 0;
		}

	}
	for (i = 0; expression[i] != '\0'; i++){
		expressionF[i] = expression[i];
	}
	expressionF[i] = '\0';
}

void variableToMultiply(char expression[DIM]){
	int i = 0, j = 0, k = 0, v = -7, u = 0, d = 0;
	char variable[DIM] = "", saveVariable[DIM] = "";
	while (expression[i] != '\0'){
		v = -7;
		if (verifyLetter(expression[i]) == 1 && (verifyLetter(expression[i - 1]) == 0 || i == 0)){
			j = 0;
			u = i;
			validVar = 0;
			while (verifyLetter(expression[i]) == 1){
				variable[j] = expression[i];
				variable[j + 1] = '\0';
				for (d = 0; variable[d] != '\0'; d++){
					saveVariable[d] = variable[d];
				}
				saveVariable[d] = '\0';
				processVariable(variable);
				if (validVar == 0){
					variableRenamer(variable);
					for (k = 0; varRename[k] != '\0'; k++){
						variable[k] = varRename[k];
					}
					variable[k] = '\0';

					processVariable(variable);
				}
				for (d = 0; saveVariable[d] != '\0'; d++){
					variable[d] = saveVariable[d];
				}
				variable[d] = '\0';
				if (validVar == 1){
					v = i;
				}
				j++; i++;
			}
			if (v != -7){
				for (k = strlen(expression); k - 1 > v; k--){
					expression[k] = expression[k - 1];
				}
				if (verifyNumber(expression[k + 1]) == 1 || verifyLetter(expression[k + 1]) == 1){
					expression[k] = '*';
				}
				else{
					for (k; expression[k + 1] != '\0'; k++){
						expression[k] = expression[k + 1];
					}
					expression[k] = '\0';
				}
				i = v;
			}



		}
		i++;
	}
	for (i = 0; expression[i] != '\0'; i++){
		expressionF[i] = expression[i];
	}
	expressionF[i] = '\0';
}

void toMultiply(char expression[DIM], double result){
	int i = 0, verify = 0, verifys = 0, j = 0;
	char value[DIM] = "";
	while (expression[i] != '\0'){
		if (expression[i] == '+'&&expression[i + 1] == '0'&&expression[i + 2] == '\0'){
			value[j] = expression[i];
			value[j + 1] = '0'; value[j + 2] = '\0';
			j++; i = i + 2;
		}
		else{
			if (verifyNumber(expression[i]) == 1){
				while (verifyNumber(expression[i]) == 1 && expression[i] != '\0' || expression[i] == 'i'&&expression[i - 1] == '1'){
					value[j] = expression[i];
					value[j + 1] = '+'; value[j + 2] = '0'; value[j + 3] = '\0';
					j++; i++;
				}
			}

			else{
				if (verifyLetter(expression[i - 1]) == 0 && firstLetterVariable(expression[i]) == 1){
					while (verifyLetter(expression[i]) == 1 && expression[i] != '\0'){
						value[j] = expression[i];
						j++; i++;
					}
					value[j + 1] = '+'; value[j + 2] = '0'; value[j + 3] = '\0';
					synTest = 0;
					verify = dataVerifier(value, result, 0, verify);

				}
				else{
					if (verifyLetter(expression[i - 1]) == 0 && firstLetterFunction(expression[i]) == 1){
						value[j] = expression[i];
						value[j + 1] = '+'; value[j + 2] = '0'; value[j + 3] = '\0';
						j++; i++;
						synTest = 0;
						verify = dataVerifier(value, result, 0, verify);

						while (verify == 0 && expression[i] != '\0'){
							if (expression[i] == 'b'){
								value[j] = expression[i];
								j++; i++;
								while ((expression[i] == 'b'&&expression[i + 1] == '(') == false && expression[i] != '\0'){
									value[j] = expression[i];
									j++; i++;
								}
							}
							else{
								if (expression[i] == 'D'){
									value[j] = expression[i];
									j++; i++;
									while ((expression[i] == 'D'&&expression[i + 1] == '(') == false && expression[i] != '\0'){
										value[j] = expression[i];
										j++; i++;
									}
								}
								else{
									value[j] = expression[i];
									value[j + 1] = '+'; value[j + 2] = '0'; value[j + 3] = '\0';
									synTest = 0;
									verify = dataVerifier(value, result, 0, verify);
									j++; i++;
								}
							}
						}
					}
					else{
						if (verifyLetter(expression[i]) == 0 && verifyNumber(expression[i]) == 0){
							while (verifyLetter(expression[i]) == 0 && verifyNumber(expression[i]) == 0 && expression[i] != '\0'){
								value[j] = expression[i];
								value[j + 1] = '+'; value[j + 2] = '0'; value[j + 3] = '\0';
								j++; i++;
								if (expression[i] == 'i'){
									value[j] = expression[i];
									value[j + 1] = '+'; value[j + 2] = '0'; value[j + 3] = '\0';
									j++; i++;
								}
							}
						}
						else{
							if (expression[i] == 'i'){
								value[j] = expression[i];
								j++; i++;
								value[j] = expression[i];
								value[j + 1] = '\0'; j++;
							}
							else{
								value[j] = expression[i];
								value[j + 1] = '\0';
							}
							synTest = 0;
							verify = dataVerifier(value, result, 0, verify);

							if (verify == 1 && firstLetterFunction(value[j]) == 0 && verifyLetter(value[j]) == 1 && value[j] != 'i'){
								j++; i++;
								while (verify == 1 && expression[i] != '\0'){
									value[j] = expression[i];
									value[j + 1] = '+'; value[j + 2] = '0'; value[j + 3] = '\0';
									synTest = 0;
									verify = dataVerifier(value, result, 0, verify);
									j++; i++;
								}
								if (expression[i] != '+'&&expression[i] != '-'&&expression[i] != '*'&&expression[i] != '/'&&expression[i] != '^'&&expression[i] != '\0'){
									j--;
									if (expression[i - 2] != '+'&&expression[i - 2] != '-'&&expression[i - 2] != '*'&&expression[i - 2] != '/'&&expression[i - 2] != '^'){
										value[j] = '*';
										value[j + 1] = '+'; value[j + 2] = '0'; value[j + 3] = '\0';
										j++;
									}
									i--;
								}

							}
							else{
								value[j] = expression[i];
								value[j + 1] = '+'; value[j + 2] = '0'; value[j + 3] = '\0';
								synTest = 0;
								verify = dataVerifier(value, result, 0, verify);

								if (verify == 0){
									j++; i++;
									while (verify == 0 && expression[i] != '\0'){
										value[j] = expression[i];
										value[j + 1] = '+'; value[j + 2] = '0'; value[j + 3] = '\0';
										synTest = 0;
										verify = dataVerifier(value, result, 0, verify);
										j++; i++;
									}
									if (expression[i] != '+'&&expression[i] != '-'&&expression[i] != '*'&&expression[i] != '/'&&expression[i] != '^'&&expression[i] != '\0'){
										value[j] = '*';
										value[j + 1] = '+'; value[j + 2] = '0'; value[j + 3] = '\0';
										j++;
									}

								}
								else{
									i++;
								}
							}
						}
					}
				}
			}
		}
	}

	for (i = 0; value[i] != '\0'; i++){
		expressionF[i] = value[i];
	}
	expressionF[i] = '\0';
}

int verifyPrefix(char prefix[DIM]){
	char prefixes[DIM] = "Y,Z,E,P,T,G,M,k,h,da,d,c,m,u,n,p,f,a,z,y,";
	int i = 0, j = 0, valid = 1;
	for (i = 0; prefix[i] != '\0'; i++){
		for (j = 0; prefixes[j] != '\0'; j++){
			if (prefix[i] == prefixes[j] && i == 0){
				while (prefix[i] == prefixes[j]){
					i++; j++;
				}
				if (prefix[i] == '\0'&&prefixes[j] == ','){
					return valid;
				}
			}
		}
	}
	return 0;
}

int firstLetterFunction(char letter){
	char letters[100] = "castlrqgd";
	int i = 0;
	for (i = 0; i < strlen(letters); i++){
		if (letter == letters[i]){
			return 1;
		}
	}
	return 0;
}

void manageExpression(char arithTrig[DIM], double result1, int verify){
	int i = 0, j = 0, s = 0;
	variableToMultiply(arithTrig);
	for (i = 0; expressionF[i] != '\0'; i++){
		arithTrig[i] = expressionF[i];
	}
	arithTrig[i] = '\0';

	renamer(arithTrig);
	for (i = 0; expressionF[i] != '\0'; i++){
		arithTrig[i] = expressionF[i];
	}
	arithTrig[i] = '\0';



	renamer(arithTrig);
	for (i = 0; expressionF[i] != '\0'; i++){
		arithTrig[i] = expressionF[i];
	}
	arithTrig[i] = '\0';
	int needOne = 1;
	while (needOne == 1){
		needOne = 0;
		for (i = 0; arithTrig[i] != '\0'; i++){
			if (verifyLetter(arithTrig[i - 1]) == 1 && arithTrig[i - 1] != '1'&& arithTrig[i - 1] != 'i'&&arithTrig[i - 1] != 'p'&& arithTrig[i] == 'i'&& verifyLetter(arithTrig[i + 1]) == 0 && verifyNumber(arithTrig[i + 1]) == 0){
				j = i;
				i = strlen(arithTrig) + 1;
				while (i > j){
					arithTrig[i] = arithTrig[i - 2];
					i--;
				}
				arithTrig[i] = '*'; arithTrig[i + 1] = '1';

				i = strlen(arithTrig);

			}
		}
		for (i = 0; arithTrig[i] != '\0'; i++){
			if (verifyLetter(arithTrig[i - 1]) == 1 && arithTrig[i - 1] != '1'&& arithTrig[i - 1] != 'i'&&arithTrig[i - 1] != 'p'&& arithTrig[i] == 'i'&& verifyLetter(arithTrig[i + 1]) == 0 && verifyNumber(arithTrig[i + 1]) == 0){
				needOne = 1;
			}
		}
	}
	renamer(arithTrig);
	for (i = 0; expressionF[i] != '\0'; i++){
		arithTrig[i] = expressionF[i];
	}
	arithTrig[i] = '\0';
	int needAst = 1;

	needAst = 1;
	while (needAst == 1){
		needAst = 0;
		for (i = 0; arithTrig[i] != '\0'; i++){
			if (verifyLetter(arithTrig[i - 1]) == 0 && arithTrig[i] == 'e'&&verifyLetter(arithTrig[i + 1]) == 1){
				j = i + 1;
				i = strlen(arithTrig);
				while (i > j){
					arithTrig[i] = arithTrig[i - 1];
					i--;
				}
				arithTrig[i] = '*';
			}
		}

		for (i = 0; arithTrig[i] != '\0'; i++){
			if (verifyLetter(arithTrig[i - 1]) == 0 && arithTrig[i] == 'e'&&verifyLetter(arithTrig[i + 1]) == 1){
				needAst = 1;
			}
		}
	}
	needAst = 1;
	while (needAst == 1){
		needAst = 0;
		for (i = 0; arithTrig[i] != '\0'; i++){
			if (verifyLetter(arithTrig[i - 1]) == 0 && arithTrig[i] == 'p'&& arithTrig[i + 1] == 'i'&&verifyLetter(arithTrig[i + 2]) == 1){
				j = i + 2;
				i = strlen(arithTrig);
				while (i > j){
					arithTrig[i] = arithTrig[i - 1];
					i--;
				}
				arithTrig[i] = '*';
			}
		}

		for (i = 0; arithTrig[i] != '\0'; i++){
			if (verifyLetter(arithTrig[i - 1]) == 0 && arithTrig[i] == 'p'&& arithTrig[i + 1] == 'i'&&verifyLetter(arithTrig[i + 2]) == 1){
				needAst = 1;
			}
		}
	}
	needAst = 1;
	while (needAst == 1){
		needAst = 0;
		for (i = 0; arithTrig[i] != '\0'; i++){
			if (verifyLetter(arithTrig[i - 1]) == 1 && arithTrig[i - 1] != 'b'&&arithTrig[i - 1] != 'D'&&arithTrig[i - 2] != 't'&&arithTrig[i - 3] != 'r' && arithTrig[i] == 'p'&& arithTrig[i + 1] == 'i'&&verifyLetter(arithTrig[i + 2]) == 0){
				j = i;
				i = strlen(arithTrig);
				while (i > j){
					arithTrig[i] = arithTrig[i - 1];
					i--;
				}
				arithTrig[i] = '*';
				i = strlen(arithTrig);

			}
		}

		for (i = 0; arithTrig[i] != '\0'; i++){
			if (verifyLetter(arithTrig[i - 1]) == 1 && arithTrig[i - 1] != 'b'&&arithTrig[i - 1] != 'D'&&arithTrig[i - 2] != 't'&&arithTrig[i - 3] != 'r' && arithTrig[i] == 'p'&& arithTrig[i + 1] == 'i'&&verifyLetter(arithTrig[i + 2]) == 0){
				needAst = 1;
			}
		}
	}
	needAst = 1;
	while (needAst == 1){
		needAst = 0;
		for (i = 0; arithTrig[i] != '\0'; i++){
			if (verifyLetter(arithTrig[i - 1]) == 1 && arithTrig[i] == 'e'&&verifyLetter(arithTrig[i + 1]) == 0){
				j = i;
				i = strlen(arithTrig);
				while (i > j){
					arithTrig[i] = arithTrig[i - 1];
					i--;
				}
				arithTrig[i] = '*';
				i = strlen(arithTrig);

			}
		}

		for (i = 0; arithTrig[i] != '\0'; i++){
			if (verifyLetter(arithTrig[i - 1]) == 1 && arithTrig[i] == 'e'&&verifyLetter(arithTrig[i + 1]) == 0){
				needAst = 1;
			}
		}
	}


	renamer(arithTrig);
	for (i = 0; expressionF[i] != '\0'; i++){
		arithTrig[i] = expressionF[i];
	}
	arithTrig[i] = '\0';
	needAst = 1;
	while (needAst == 1){
		needAst = 0;
		for (i = 0; arithTrig[i] != '\0'; i++){
			if (verifyLetter(arithTrig[i - 1]) == 1 && arithTrig[i] == 'p'&& arithTrig[i + 1] == 'i'&&verifyLetter(arithTrig[i + 2]) == 1){
				if (arithTrig[i - 1] == 'D' || arithTrig[i - 1] == 'b'){
					while (verifyLetter(arithTrig[i]) == 1){
						i--;
					}
					i++;
					int lo = 0;
					char func[DIM] = "";
					while (verifyLetter(arithTrig[i]) == 1 && arithTrig[i] != 'b'&&arithTrig[i] != 'D'){
						func[lo] = arithTrig[i];
						lo++; i++;
					}
					func[lo] = arithTrig[i]; lo++;
					func[lo] = arithTrig[i]; lo++;
					func[lo] = '?'; lo++;
					func[lo] = '\0';
					if (functionProcessor(func, 0, 0, 0) == 0.5){
						i = i + 2;
					}
				}
			}
			if (verifyLetter(arithTrig[i - 1]) == 1 && arithTrig[i] == 'p'&& arithTrig[i + 1] == 'i'&&verifyLetter(arithTrig[i + 2]) == 1){


				j = i;
				i = strlen(arithTrig);
				while (i > j){
					arithTrig[i] = arithTrig[i - 1];
					i--;
				}
				arithTrig[i] = '*';
				j = j + 3;
				i = strlen(arithTrig);
				while (i > j){
					arithTrig[i] = arithTrig[i - 1];
					i--;
				}
				arithTrig[i] = '*';

			}
		}
		for (i = 0; arithTrig[i] != '\0'; i++){
			if (verifyLetter(arithTrig[i - 1]) == 1 && arithTrig[i] == 'p'&& arithTrig[i + 1] == 'i'&&verifyLetter(arithTrig[i + 2]) == 1){
				if (arithTrig[i - 1] == 'D' || arithTrig[i - 1] == 'b'){
					while (verifyLetter(arithTrig[i]) == 1){
						i--;
					}
					i++;
					int lo = 0;
					char func[DIM] = "";
					while (verifyLetter(arithTrig[i]) == 1 && arithTrig[i] != 'b'&&arithTrig[i] != 'D'){
						func[lo] = arithTrig[i];
						lo++; i++;
					}
					func[lo] = arithTrig[i]; lo++;
					func[lo] = arithTrig[i]; lo++;
					func[lo] = '?'; lo++;
					func[lo] = '\0';
					if (functionProcessor(func, 0, 0, 0) == 0.5){
						i = i + 2;
					}
				}
			}

			if (verifyLetter(arithTrig[i - 1]) == 1 && arithTrig[i] == 'p'&& arithTrig[i + 1] == 'i'&&verifyLetter(arithTrig[i + 2]) == 1){
				needAst = 1;
			}
		}
	}

	renamer(arithTrig);
	for (i = 0; expressionF[i] != '\0'; i++){
		arithTrig[i] = expressionF[i];
	}
	arithTrig[i] = '\0';

	needOne = 1;
	while (needOne == 1){
		needOne = 0;
		for (i = 0; arithTrig[i] != '\0'; i++){
			if (verifyLetter(arithTrig[i - 1]) == 0 && arithTrig[i] == 'i'&& verifyLetter(arithTrig[i + 1]) == 1 && arithTrig[i + 1] != 'D'&&arithTrig[i + 1] != 'b'){
				j = i + 1;
				i = strlen(arithTrig);
				while (i > j){
					arithTrig[i] = arithTrig[i - 1];
					i--;
				}
				arithTrig[i] = '*';
				i = strlen(arithTrig);

			}
		}
		for (i = 0; arithTrig[i] != '\0'; i++){
			if (verifyLetter(arithTrig[i - 1]) == 0 && arithTrig[i] == 'i'&& verifyLetter(arithTrig[i + 1]) == 1 && arithTrig[i + 1] != 'D'&&arithTrig[i + 1] != 'b'){
				needOne = 1;
			}
		}
	}
	needOne = 1;
	while (needOne == 1){
		needOne = 0;
		for (i = 0; arithTrig[i] != '\0'; i++){
			if (verifyLetter(arithTrig[i - 1]) == 1 && arithTrig[i - 1] != '1'&&arithTrig[i - 1] != 'p'&& arithTrig[i] == 'i'&& verifyLetter(arithTrig[i + 1]) == 0 && verifyNumber(arithTrig[i + 1]) == 0){
				j = i;
				i = strlen(arithTrig);
				while (i > j){
					arithTrig[i] = arithTrig[i - 1];
					i--;
				}
				arithTrig[i] = '1';
				i = strlen(arithTrig);

			}
		}
		for (i = 0; arithTrig[i] != '\0'; i++){
			if (verifyLetter(arithTrig[i - 1]) == 1 && arithTrig[i - 1] != '1'&&arithTrig[i - 1] != 'p'&& arithTrig[i] == 'i'&& verifyLetter(arithTrig[i + 1]) == 0 && verifyNumber(arithTrig[i + 1]) == 0){
				needOne = 1;
			}
		}
	}
	needAst = 1;
	int mark = 0, mark1 = 0, napier = 0, n = 0, m = 0;
	float isFunc = 0;
	char functionP[DIM] = "";
	while (needAst == 1){
		valRenamedVar = 0;
		for (i = mark1; arithTrig[i] != '\0'; i++){
			if (verifyLetter(arithTrig[i - 1]) == 1 && arithTrig[i] == 'e'&& verifyLetter(arithTrig[i + 1]) == 1 && needAst == 1){
				if (arithTrig[i - 1] == 'D' || arithTrig[i - 1] == 'b'){
					while (verifyLetter(arithTrig[i]) == 1){
						i--;
					}
					i++;
					int lo = 0;
					char func[DIM] = "";
					while (verifyLetter(arithTrig[i]) == 1 && arithTrig[i] != 'b'&&arithTrig[i] != 'D'){
						func[lo] = arithTrig[i];
						lo++; i++;
					}
					func[lo] = arithTrig[i]; lo++;
					func[lo] = arithTrig[i]; lo++;
					func[lo] = '?'; lo++;
					func[lo] = '\0';
					if (functionProcessor(func, 0, 0, 0) == 0.5){
						i = i + 2;
					}
				}
			}
			if (verifyLetter(arithTrig[i - 1]) == 1 && arithTrig[i] == 'e'&& verifyLetter(arithTrig[i + 1]) == 1 && needAst == 1){
				mark1 = i + 1;
				j = i;
				i = strlen(arithTrig);
				int p = j;
				while (verifyLetter(arithTrig[p]) == 1){
					p--;
				}
				if (j != p){
					p++;

					char function[DIM] = "";

					int y = 0;
					while (verifyLetter(arithTrig[p]) == 1){
						function[y] = arithTrig[p];
						p++; y++;

					}
					function[y] = '?'; function[y + 1] = '\0';
					isFunc = functionProcessor(function, 0, 0, 0);
					if (isFunc == 0.5){
						break;
					}
					else{
						function[y] = '\0';
						valRenamedVar = 0;

						n = 0, m = 0;
						m = 0;
						for (n = 0; function[n] != '\0'; n++){
							while (function[n] != 'e'&&function[n] != '\0'){
								functionP[m] = function[n];
								n++; m++;
							}

							functionP[m] = '\0';
							valRenamedVar = 0;
							variableRenamer(functionP);
							if (valRenamedVar == 1){
								isFunc = 0;
								break;
							}
							else{
								functionP[m] = function[n];
								napier = 1;
								m++;
							}
						}
						if (valRenamedVar == 1){
							isFunc = 0;
						}

					}

				}
				if (isFunc == 0 && napier == 0){
					while (i > j){
						arithTrig[i] = arithTrig[i - 1];
						i--;
					}
					arithTrig[i] = '*';
					j = j + 2;
					i = strlen(arithTrig);
					while (i > j){
						arithTrig[i] = arithTrig[i - 1];
						i--;
					}
					arithTrig[i] = '*';

				}
				if (napier == 1){
					n = 0; m = 0;
					for (n = 0; arithTrig[n] != '\0'; n++){

						if (arithTrig[n] == functionP[m]){
							m = 0;
							while (arithTrig[n] == functionP[m]){
								n++; m++;
							}
							int z = strlen(arithTrig), nj = n, nc = 0;
							nc = z;
							if (arithTrig[nj + 1] != '('){
								while (nj < nc){
									arithTrig[nc] = arithTrig[nc - 1];
									nc--;
								}

								arithTrig[nj] = '*';
								z = strlen(arithTrig);
								nj = n + 2;
								if (arithTrig[nj - 1] != '('){
									while (nj < z){
										arithTrig[z] = arithTrig[z - 1];
										z--;
									}
									if (arithTrig[z] != '\0'){
										arithTrig[z] = '*';

									}
								}
							}

						}
					}
				}
			}
		}
		for (i = mark; arithTrig[i] != '\0'; i++){
			needAst = 0;
			if (verifyLetter(arithTrig[i - 1]) == 1 && arithTrig[i] == 'e'&& verifyLetter(arithTrig[i + 1]) == 1){
				if (arithTrig[i - 1] == 'D' || arithTrig[i - 1] == 'b'){
					while (verifyLetter(arithTrig[i]) == 1){
						i--;
					}
					i++;
					int lo = 0;
					char func[DIM] = "";
					while (verifyLetter(arithTrig[i]) == 1 && arithTrig[i] != 'b'&&arithTrig[i] != 'D'){
						func[lo] = arithTrig[i];
						lo++; i++;
					}
					func[lo] = arithTrig[i]; lo++;
					func[lo] = arithTrig[i]; lo++;
					func[lo] = '?'; lo++;
					func[lo] = '\0';
					if (functionProcessor(func, 0, 0, 0) == 0.5){
						i = i + 2;
					}
				}
			}
			if (verifyLetter(arithTrig[i - 1]) == 1 && arithTrig[i] == 'e'&&verifyLetter(arithTrig[i + 1]) == 1){
				mark = i + 1;
				needAst = 1;
			}
		}
	}

	renamer(arithTrig);
	for (i = 0; expressionF[i] != '\0'; i++){
		arithTrig[i] = expressionF[i];
	}
	arithTrig[i] = '\0';

	char paTrig[DIM] = "";
	int u = 0;
	for (u = 0; arithTrig[u] != '\0'; u++){
		paTrig[u] = arithTrig[u];
	}
	paTrig[u] = '\0';
	u = 0;
	for (u; paTrig[u] != '\0'; u++){
		if (verifyLetter(paTrig[u]) == 0){
			while (verifyLetter(paTrig[u]) == 0 && paTrig[u] != '\0'){
				u++;
			}
		}
		if (verifyLetter(paTrig[u]) == 1 && firstLetterVariable(paTrig[u]) == 0){
			while (verifyLetter(paTrig[u]) == 1){
				u++;
			}
		}
		if (firstLetterVariable(paTrig[u]) == 1 && firstLetterVariable(paTrig[u - 1]) == 0 && paTrig[u + 1] != 'i'){
			u++;
			while (verifyLetter(paTrig[u]) == 1){
				u++;
			}
			if (paTrig[u] != '*'&&paTrig[u] != '+'&&paTrig[u] != '-'&&paTrig[u] != '/'&&paTrig[u] != '^'&&paTrig[u] != '!'&&paTrig[u] != ')'){
				arithTrig[u] = '*';
				for (u; paTrig[u] != '\0'; u++){
					arithTrig[u + 1] = paTrig[u];
				}
				arithTrig[u + 1] = '\0';
				u = 0;
				for (u = 0; arithTrig[u] != '\0'; u++){
					paTrig[u] = arithTrig[u];
				}
				paTrig[u] = '\0';
				u = 0;
			}
		}


	}
	needAst = 1;
	while (needAst == 1){
		needAst = 0;
		for (i = 0; arithTrig[i] != '\0'; i++){
			if (verifyLetter(arithTrig[i - 1]) == 0 && arithTrig[i - 1] != '(' && arithTrig[i] == 'i'&&verifyLetter(arithTrig[i + 1]) == 1 && arithTrig[i + 1] != 'D'&& arithTrig[i + 1] != 'b'){
				j = i + 1;
				i = strlen(arithTrig);
				int comp = 0;
				if (verifyNumber(arithTrig[j - 2]) == 0){
					i++;
					comp = 1;
				}
				if (comp == 0){
					while (i > j){
						arithTrig[i] = arithTrig[i - 1];
						i--;
					}
					arithTrig[i] = '*';
				}
				else{
					while (i > j){
						arithTrig[i] = arithTrig[i - 2];
						i--;
					}
					arithTrig[i] = '1'; arithTrig[i + 1] = '*';
				}
			}
		}
		for (i = 0; arithTrig[i] != '\0'; i++){
			if (verifyLetter(arithTrig[i - 1]) == 0 && arithTrig[i - 1] != '('&&arithTrig[i] == 'i'&&verifyLetter(arithTrig[i + 1]) == 1 && arithTrig[i + 1] != 'D'&& arithTrig[i + 1] != 'b'){
				needAst = 1;
			}
		}
	}
	needAst = 1;
	while (needAst == 1){
		needAst = 0;
		for (i = 0; arithTrig[i] != '\0'; i++){
			if ((verifyLetter(arithTrig[i - 1]) == 1 || verifyNumber(arithTrig[i - 1]) == 1) && arithTrig[i - 1] != 'p' && arithTrig[i - 1] != 'D'&& arithTrig[i - 1] != 'b'&& arithTrig[i] == 'i'&&arithTrig[i - 1] != '1'&&arithTrig[i - 1] != '('&&verifyLetter(arithTrig[i + 1]) == 0){

				j = i;
				i = strlen(arithTrig) + 1;
				while (i > j){
					arithTrig[i] = arithTrig[i - 2];
					i--;
				}
				arithTrig[i] = '*'; arithTrig[i + 1] = '1';
				i = strlen(arithTrig);

			}
		}

		for (i = 0; arithTrig[i] != '\0'; i++){
			if ((verifyLetter(arithTrig[i - 1]) == 1 || verifyNumber(arithTrig[i - 1]) == 1) && arithTrig[i - 1] != 'p' && arithTrig[i - 1] != 'D'&& arithTrig[i - 1] != 'b'&& arithTrig[i] == 'i'&&arithTrig[i - 1] != '1'&&arithTrig[i - 1] != '('&&verifyLetter(arithTrig[i + 1]) == 0){
				needAst = 1;
			}
		}
	}
	needAst = 1;
	while (needAst == 1){
		needAst = 0;
		for (i = 0; arithTrig[i] != '\0'; i++){
			if (arithTrig[i - 1] == ')' && arithTrig[i] == 'i'&&verifyLetter(arithTrig[i + 1]) == 0){
				j = i;
				i = strlen(arithTrig) + 1;
				while (i > j){
					arithTrig[i] = arithTrig[i - 2];
					i--;
				}
				arithTrig[i] = '*'; arithTrig[i + 1] = '1';
				i = strlen(arithTrig);

			}
		}

		for (i = 0; arithTrig[i] != '\0'; i++){
			if (arithTrig[i - 1] == ')' && arithTrig[i] == 'i'&&verifyLetter(arithTrig[i + 1]) == 0){
				needAst = 1;
			}
		}
	}

	needAst = 1;
	while (needAst == 1){
		needAst = 0;
		for (i = 0; arithTrig[i] != '\0'; i++){
			if (verifyLetter(arithTrig[i - 1]) == 0 && arithTrig[i] == 'i'&&arithTrig[i + 1] == '('){
				j = i + 1;
				i = strlen(arithTrig);
				int comp = 0;
				if (verifyNumber(arithTrig[j - 2]) == 0){
					i++;
					comp = 1;
				}
				if (comp == 0){
					while (i > j){
						arithTrig[i] = arithTrig[i - 1];
						i--;
					}
					arithTrig[i] = '*';
				}
				else{
					while (i > j){
						arithTrig[i] = arithTrig[i - 2];
						i--;
					}
					arithTrig[i] = '1'; arithTrig[i + 1] = '*';
				}
			}
		}

		for (i = 0; arithTrig[i] != '\0'; i++){
			if (verifyLetter(arithTrig[i - 1]) == 0 && arithTrig[i] == 'i'&&arithTrig[i + 1] == '('){
				needAst = 1;
			}
		}
	}




	renamer(arithTrig);
	for (i = 0; expressionF[i] != '\0'; i++){
		arithTrig[i] = expressionF[i];
	}
	arithTrig[i] = '\0';
	needAst = 1;
	while (needAst == 1){
		needAst = 0;
		for (i = 0; arithTrig[i] != '\0'; i++){
			if (verifyLetter(arithTrig[i - 1]) == 0 && verifyNumber(arithTrig[i - 1]) == 0 && arithTrig[i] == 'i'&& arithTrig[i + 1] != '1' && (verifyLetter(arithTrig[i + 1]) == 1 || verifyNumber(arithTrig[i + 1]) == 1)){
				j = i + 1;
				i = strlen(arithTrig) + 1;
				while (i > j){
					arithTrig[i] = arithTrig[i - 2];
					i--;
				}
				arithTrig[i] = '1'; arithTrig[i + 1] = '*';
			}

		}
		needAst = 0;
		for (i = 0; arithTrig[i] != '\0'; i++){
			if (verifyLetter(arithTrig[i - 1]) == 0 && verifyNumber(arithTrig[i - 1]) == 0 && arithTrig[i] == 'i'&& arithTrig[i + 1] != '1' && (verifyLetter(arithTrig[i + 1]) == 1 || verifyNumber(arithTrig[i + 1]) == 1)){
				needAst = 1;
			}

		}
	}
	needOne = 1;
	while (needOne == 1){
		needOne = 0;
		for (i = 0; arithTrig[i] != '\0'; i++){
			if ((verifyLetter(arithTrig[i - 1]) == 0 || arithTrig[i - 1] == 'D' || arithTrig[i - 1] == 'b') && verifyNumber(arithTrig[i - 1]) == 0 && arithTrig[i] == 'i'&& verifyNumber(arithTrig[i + 1]) == 0 && (verifyLetter(arithTrig[i + 1]) == 0 || arithTrig[i + 1] == 'D' || arithTrig[i + 1] == 'b')){
				j = i;
				i = strlen(arithTrig);
				while (i > j){
					arithTrig[i] = arithTrig[i - 1];
					i--;
				}
				arithTrig[i] = '1';
				i = strlen(arithTrig);

			}
		}
		for (i = 0; arithTrig[i] != '\0'; i++){
			if ((verifyLetter(arithTrig[i - 1]) == 0 || arithTrig[i - 1] == 'D' || arithTrig[i - 1] == 'b') && verifyNumber(arithTrig[i - 1]) == 0 && arithTrig[i] == 'i'&& verifyNumber(arithTrig[i + 1]) == 0 && (verifyLetter(arithTrig[i + 1]) == 0 || arithTrig[i + 1] == 'D' || arithTrig[i + 1] == 'b')){
				needOne = 1;
			}
		}
	}
	needAst = 1;
	while (needAst == 1){
		needAst = 0;
		for (i = 0; arithTrig[i] != '\0'; i++){
			if (arithTrig[i - 1] == '1' && arithTrig[i] == 'i' && (verifyLetter(arithTrig[i + 1]) == 1 && arithTrig[i + 1] != 'D'&&arithTrig[i + 1] != 'b' || verifyNumber(arithTrig[i + 1]) == 1)){
				j = i + 1;
				i = strlen(arithTrig);
				while (i > j){
					arithTrig[i] = arithTrig[i - 1];
					i--;
				}
				arithTrig[i] = '*';
			}
		}

		for (i = 0; arithTrig[i] != '\0'; i++){
			if (arithTrig[i - 1] == '1' && arithTrig[i] == 'i' && (verifyLetter(arithTrig[i + 1]) == 1 && arithTrig[i + 1] != 'D'&&arithTrig[i + 1] != 'b' || verifyNumber(arithTrig[i + 1]) == 1)){
				needAst = 1;
			}
		}
	}

	s = 0;
	for (s = 0; arithTrig[s] != '\0'; s++){
		paTrig[s] = arithTrig[s];
	}
	paTrig[s] = '\0';

	s = 0;

	s = 0;
	for (s; paTrig[s] != '\0'; s++){
		if ((paTrig[s] == 'e'&&paTrig[s + 1] != 'b' || paTrig[s] == 'i'&&paTrig[s - 1] == 'p'&&paTrig[s + 1] != 'b' || paTrig[s] == '1' || paTrig[s] == '2' || paTrig[s] == '3' || paTrig[s] == '4' || paTrig[s] == '5' || paTrig[s] == '6' || paTrig[s] == '7' || paTrig[s] == '8' || paTrig[s] == '9' || paTrig[s] == '0' || paTrig[s] == '.') && (paTrig[s + 1] == '#' || paTrig[s + 1] == 'w' || paTrig[s + 1] == 'y' || paTrig[s + 1] == 'u' || paTrig[s + 1] == 'o' || paTrig[s + 1] == 'p' || paTrig[s + 1] == 'f' || paTrig[s + 1] == 'h' || paTrig[s + 1] == 'j' || paTrig[s + 1] == 'k' || paTrig[s + 1] == 'z' || paTrig[s + 1] == 'x' || paTrig[s + 1] == 'v' || paTrig[s + 1] == 'm' || paTrig[s + 1] == 'Q' || paTrig[s + 1] == 'W' || paTrig[s + 1] == 'R' || paTrig[s + 1] == 'T' || paTrig[s + 1] == 'Y' || paTrig[s + 1] == 'U' || paTrig[s + 1] == 'I' || paTrig[s + 1] == 'S' || paTrig[s + 1] == 'G' || paTrig[s + 1] == 'J' || paTrig[s + 1] == 'K' || paTrig[s + 1] == 'L' || paTrig[s + 1] == 'Z' || paTrig[s + 1] == 'X' || paTrig[s + 1] == 'V' || paTrig[s + 1] == 'N' || paTrig[s + 1] == 'M')){
			s++;
			arithTrig[s] = '*';
			for (s; paTrig[s] != '\0'; s++){
				arithTrig[s + 1] = paTrig[s];
			}
			arithTrig[s + 1] = '\0';
			s = 0;
			for (s = 0; arithTrig[s] != '\0'; s++){
				paTrig[s] = arithTrig[s];
			}
			paTrig[s] = '\0';
			s = 0;
		}
	}
	s = 0;
	for (s; paTrig[s] != '\0'; s++){
		if ((paTrig[s + 1] == 'e'&&paTrig[s] != 'b' || paTrig[s + 1] == 'p'&&paTrig[s + 2] == 'i'&&paTrig[s] != 'b' || paTrig[s + 1] == '1' || paTrig[s + 1] == '2' || paTrig[s + 1] == '3' || paTrig[s + 1] == '4' || paTrig[s + 1] == '5' || paTrig[s + 1] == '6' || paTrig[s + 1] == '7' || paTrig[s + 1] == '8' || paTrig[s + 1] == '9' || paTrig[s + 1] == '0' || paTrig[s + 1] == '.') && (paTrig[s] == 'q' || paTrig[s] == 'w' || paTrig[s] == 't' || paTrig[s] == 'y' || paTrig[s] == 'u' || paTrig[s] == 'o' || paTrig[s] == 'p' || paTrig[s] == 'a' || paTrig[s] == 'f' || paTrig[s] == 'h' || paTrig[s] == 'j' || paTrig[s] == 'k' || paTrig[s] == 'l' || paTrig[s] == 'z' || paTrig[s] == 'c' || paTrig[s] == 'v' || paTrig[s] == 'n' || paTrig[s] == 'm' || paTrig[s] == 'Q' || paTrig[s] == 'W' || paTrig[s] == 'R' || paTrig[s] == 'T' || paTrig[s] == 'Y' || paTrig[s] == 'U' || paTrig[s] == 'I' || paTrig[s] == 'S' || paTrig[s] == 'G' || paTrig[s] == 'J' || paTrig[s] == 'K' || paTrig[s] == 'L' || paTrig[s] == 'Z' || paTrig[s] == 'X' || paTrig[s] == 'V' || paTrig[s] == 'N' || paTrig[s] == 'M')){
			s++;
			arithTrig[s] = '*';
			for (s; paTrig[s] != '\0'; s++){
				arithTrig[s + 1] = paTrig[s];
			}
			arithTrig[s + 1] = '\0';
			s = 0;
			for (s = 0; arithTrig[s] != '\0'; s++){
				paTrig[s] = arithTrig[s];
			}
			paTrig[s] = '\0';
			s = 0;
		}
	}
	toMultiply(arithTrig, result1);
	for (i = 0; expressionF[i] != '\0'; i++){
		arithTrig[i] = expressionF[i];
	}
	arithTrig[i] = '\0';
	for (i = 0; arithTrig[i] != '\0'; i++){
		expressionF[i] = arithTrig[i];
	}
	expressionF[i] = '\0';
}

void openTxt(){
	char openFile[DIM] = "";
	sprintf(openFile, "notepad.exe %s", expressionF);
	system(openFile);
}

void cls()
{
	HANDLE hConsole;

	hConsole = GetStdHandle(STD_OUTPUT_HANDLE);

	COORD coordScreen = { 0, 0 };    // home for the cursor 
	DWORD cCharsWritten;
	CONSOLE_SCREEN_BUFFER_INFO csbi;
	DWORD dwConSize;

	// Get the number of character cells in the current buffer. 

	if (!GetConsoleScreenBufferInfo(hConsole, &csbi))
	{
		return;
	}

	dwConSize = csbi.dwSize.X * csbi.dwSize.Y;

	// Fill the entire screen with blanks.

	if (!FillConsoleOutputCharacter(hConsole,        // Handle to console screen buffer 
		(TCHAR) ' ',     // Character to write to the buffer
		dwConSize,       // Number of cells to write 
		coordScreen,     // Coordinates of first cell 
		&cCharsWritten))// Receive number of characters written
	{
		return;
	}

	// Get the current text attribute.

	if (!GetConsoleScreenBufferInfo(hConsole, &csbi))
	{
		return;
	}

	// Set the buffer's attributes accordingly.

	if (!FillConsoleOutputAttribute(hConsole,         // Handle to console screen buffer 
		csbi.wAttributes, // Character attributes to use
		dwConSize,        // Number of cells to set attribute 
		coordScreen,      // Coordinates of first cell 
		&cCharsWritten)) // Receive number of characters written
	{
		return;
	}

	// Put the cursor at its home coordinates.

	SetConsoleCursorPosition(hConsole, coordScreen);
}

void wait(int seconds){
	int sec = 0;
	char seco[3] = "";
	char *tim;
	time_t hour1;
	time(&hour1);
	tim = ctime(&hour1);
	tim[24] = '\0';
	seco[0] = tim[17]; seco[1] = tim[18]; seco[2] = '\0';
	sec = atoi(seco);
	if (seconds == sec){
		while (seconds == sec){
			char *tim;
			time_t hour1;
			time(&hour1);
			tim = ctime(&hour1);
			tim[24] = '\0';
			seco[0] = tim[17]; seco[1] = tim[18]; seco[2] = '\0';
			sec = atoi(seco);
			Sleep(1);
		}
	}
}
